var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/leaflet/dist/leaflet-src.js
var require_leaflet_src = __commonJS({
  "node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.leaflet = {}));
    })(exports, function(exports2) {
      "use strict";
      var version = "1.9.4";
      function extend(dest) {
        var i, j, len, src;
        for (j = 1, len = arguments.length; j < len; j++) {
          src = arguments[j];
          for (i in src) {
            dest[i] = src[i];
          }
        }
        return dest;
      }
      var create$2 = Object.create || /* @__PURE__ */ function() {
        function F() {
        }
        return function(proto) {
          F.prototype = proto;
          return new F();
        };
      }();
      function bind(fn, obj) {
        var slice = Array.prototype.slice;
        if (fn.bind) {
          return fn.bind.apply(fn, slice.call(arguments, 1));
        }
        var args = slice.call(arguments, 2);
        return function() {
          return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
      }
      var lastId = 0;
      function stamp(obj) {
        if (!("_leaflet_id" in obj)) {
          obj["_leaflet_id"] = ++lastId;
        }
        return obj._leaflet_id;
      }
      function throttle(fn, time, context) {
        var lock, args, wrapperFn, later;
        later = function() {
          lock = false;
          if (args) {
            wrapperFn.apply(context, args);
            args = false;
          }
        };
        wrapperFn = function() {
          if (lock) {
            args = arguments;
          } else {
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
          }
        };
        return wrapperFn;
      }
      function wrapNum(x, range, includeMax) {
        var max = range[1], min = range[0], d = max - min;
        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
      }
      function falseFn() {
        return false;
      }
      function formatNum(num, precision) {
        if (precision === false) {
          return num;
        }
        var pow = Math.pow(10, precision === void 0 ? 6 : precision);
        return Math.round(num * pow) / pow;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function splitWords(str) {
        return trim(str).split(/\s+/);
      }
      function setOptions(obj, options) {
        if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
          obj.options = obj.options ? create$2(obj.options) : {};
        }
        for (var i in options) {
          obj.options[i] = options[i];
        }
        return obj.options;
      }
      function getParamString(obj, existingUrl, uppercase) {
        var params = [];
        for (var i in obj) {
          params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
        }
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
      }
      var templateRe = /\{ *([\w_ -]+) *\}/g;
      function template(str, data) {
        return str.replace(templateRe, function(str2, key) {
          var value = data[key];
          if (value === void 0) {
            throw new Error("No value provided for variable " + str2);
          } else if (typeof value === "function") {
            value = value(data);
          }
          return value;
        });
      }
      var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      function indexOf(array, el) {
        for (var i = 0; i < array.length; i++) {
          if (array[i] === el) {
            return i;
          }
        }
        return -1;
      }
      var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function getPrefixed(name) {
        return window["webkit" + name] || window["moz" + name] || window["ms" + name];
      }
      var lastTime = 0;
      function timeoutDefer(fn) {
        var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
      }
      var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
      var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
        window.clearTimeout(id);
      };
      function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
          fn.call(context);
        } else {
          return requestFn.call(window, bind(fn, context));
        }
      }
      function cancelAnimFrame(id) {
        if (id) {
          cancelFn.call(window, id);
        }
      }
      var Util = {
        __proto__: null,
        extend,
        create: create$2,
        bind,
        get lastId() {
          return lastId;
        },
        stamp,
        throttle,
        wrapNum,
        falseFn,
        formatNum,
        trim,
        splitWords,
        setOptions,
        getParamString,
        template,
        isArray,
        indexOf,
        emptyImageUrl,
        requestFn,
        cancelFn,
        requestAnimFrame,
        cancelAnimFrame
      };
      function Class() {
      }
      Class.extend = function(props) {
        var NewClass = function() {
          setOptions(this);
          if (this.initialize) {
            this.initialize.apply(this, arguments);
          }
          this.callInitHooks();
        };
        var parentProto = NewClass.__super__ = this.prototype;
        var proto = create$2(parentProto);
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        for (var i in this) {
          if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
            NewClass[i] = this[i];
          }
        }
        if (props.statics) {
          extend(NewClass, props.statics);
        }
        if (props.includes) {
          checkDeprecatedMixinEvents(props.includes);
          extend.apply(null, [proto].concat(props.includes));
        }
        extend(proto, props);
        delete proto.statics;
        delete proto.includes;
        if (proto.options) {
          proto.options = parentProto.options ? create$2(parentProto.options) : {};
          extend(proto.options, props.options);
        }
        proto._initHooks = [];
        proto.callInitHooks = function() {
          if (this._initHooksCalled) {
            return;
          }
          if (parentProto.callInitHooks) {
            parentProto.callInitHooks.call(this);
          }
          this._initHooksCalled = true;
          for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
            proto._initHooks[i2].call(this);
          }
        };
        return NewClass;
      };
      Class.include = function(props) {
        var parentOptions = this.prototype.options;
        extend(this.prototype, props);
        if (props.options) {
          this.prototype.options = parentOptions;
          this.mergeOptions(props.options);
        }
        return this;
      };
      Class.mergeOptions = function(options) {
        extend(this.prototype.options, options);
        return this;
      };
      Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function() {
          this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
      };
      function checkDeprecatedMixinEvents(includes) {
        if (typeof L === "undefined" || !L || !L.Mixin) {
          return;
        }
        includes = isArray(includes) ? includes : [includes];
        for (var i = 0; i < includes.length; i++) {
          if (includes[i] === L.Mixin.Events) {
            console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
          }
        }
      }
      var Events = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              this._on(types[i], fn, context);
            }
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(types, fn, context) {
          if (!arguments.length) {
            delete this._events;
          } else if (typeof types === "object") {
            for (var type in types) {
              this._off(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            var removeAll = arguments.length === 1;
            for (var i = 0, len = types.length; i < len; i++) {
              if (removeAll) {
                this._off(types[i]);
              } else {
                this._off(types[i], fn, context);
              }
            }
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(type, fn, context, _once) {
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          if (this._listens(type, fn, context) !== false) {
            return;
          }
          if (context === this) {
            context = void 0;
          }
          var newListener = { fn, ctx: context };
          if (_once) {
            newListener.once = true;
          }
          this._events = this._events || {};
          this._events[type] = this._events[type] || [];
          this._events[type].push(newListener);
        },
        _off: function(type, fn, context) {
          var listeners, i, len;
          if (!this._events) {
            return;
          }
          listeners = this._events[type];
          if (!listeners) {
            return;
          }
          if (arguments.length === 1) {
            if (this._firingCount) {
              for (i = 0, len = listeners.length; i < len; i++) {
                listeners[i].fn = falseFn;
              }
            }
            delete this._events[type];
            return;
          }
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          var index2 = this._listens(type, fn, context);
          if (index2 !== false) {
            var listener = listeners[index2];
            if (this._firingCount) {
              listener.fn = falseFn;
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(index2, 1);
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object — the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(type, data, propagate) {
          if (!this.listens(type, propagate)) {
            return this;
          }
          var event = extend({}, data, {
            type,
            target: this,
            sourceTarget: data && data.sourceTarget || this
          });
          if (this._events) {
            var listeners = this._events[type];
            if (listeners) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var i = 0, len = listeners.length; i < len; i++) {
                var l = listeners[i];
                var fn = l.fn;
                if (l.once) {
                  this.off(type, fn, l.ctx);
                }
                fn.call(l.ctx || this, event);
              }
              this._firingCount--;
            }
          }
          if (propagate) {
            this._propagateEvent(event);
          }
          return this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(type, fn, context, propagate) {
          if (typeof type !== "string") {
            console.warn('"string" type argument expected');
          }
          var _fn = fn;
          if (typeof fn !== "function") {
            propagate = !!fn;
            _fn = void 0;
            context = void 0;
          }
          var listeners = this._events && this._events[type];
          if (listeners && listeners.length) {
            if (this._listens(type, _fn, context) !== false) {
              return true;
            }
          }
          if (propagate) {
            for (var id in this._eventParents) {
              if (this._eventParents[id].listens(type, fn, context, propagate)) {
                return true;
              }
            }
          }
          return false;
        },
        // returns the index (number) or false
        _listens: function(type, fn, context) {
          if (!this._events) {
            return false;
          }
          var listeners = this._events[type] || [];
          if (!fn) {
            return !!listeners.length;
          }
          if (context === this) {
            context = void 0;
          }
          for (var i = 0, len = listeners.length; i < len; i++) {
            if (listeners[i].fn === fn && listeners[i].ctx === context) {
              return i;
            }
          }
          return false;
        },
        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        once: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn, true);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              this._on(types[i], fn, context, true);
            }
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(obj) {
          this._eventParents = this._eventParents || {};
          this._eventParents[stamp(obj)] = obj;
          return this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(obj) {
          if (this._eventParents) {
            delete this._eventParents[stamp(obj)];
          }
          return this;
        },
        _propagateEvent: function(e) {
          for (var id in this._eventParents) {
            this._eventParents[id].fire(e.type, extend({
              layer: e.target,
              propagatedFrom: e.target
            }, e), true);
          }
        }
      };
      Events.addEventListener = Events.on;
      Events.removeEventListener = Events.clearAllEventListeners = Events.off;
      Events.addOneTimeEventListener = Events.once;
      Events.fireEvent = Events.fire;
      Events.hasEventListeners = Events.listens;
      var Evented = Class.extend(Events);
      function Point(x, y, round) {
        this.x = round ? Math.round(x) : x;
        this.y = round ? Math.round(y) : y;
      }
      var trunc = Math.trunc || function(v) {
        return v > 0 ? Math.floor(v) : Math.ceil(v);
      };
      Point.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new Point(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(point) {
          return this.clone()._add(toPoint(point));
        },
        _add: function(point) {
          this.x += point.x;
          this.y += point.y;
          return this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(point) {
          return this.clone()._subtract(toPoint(point));
        },
        _subtract: function(point) {
          this.x -= point.x;
          this.y -= point.y;
          return this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(num) {
          return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
          this.x /= num;
          this.y /= num;
          return this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(num) {
          return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
          this.x *= num;
          this.y *= num;
          return this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(point) {
          return new Point(this.x * point.x, this.y * point.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(point) {
          return new Point(this.x / point.x, this.y / point.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          this.x = trunc(this.x);
          this.y = trunc(this.y);
          return this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(point) {
          point = toPoint(point);
          var x = point.x - this.x, y = point.y - this.y;
          return Math.sqrt(x * x + y * y);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(point) {
          point = toPoint(point);
          return point.x === this.x && point.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(point) {
          point = toPoint(point);
          return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
        }
      };
      function toPoint(x, y, round) {
        if (x instanceof Point) {
          return x;
        }
        if (isArray(x)) {
          return new Point(x[0], x[1]);
        }
        if (x === void 0 || x === null) {
          return x;
        }
        if (typeof x === "object" && "x" in x && "y" in x) {
          return new Point(x.x, x.y);
        }
        return new Point(x, y, round);
      }
      function Bounds(a, b) {
        if (!a) {
          return;
        }
        var points = b ? [a, b] : a;
        for (var i = 0, len = points.length; i < len; i++) {
          this.extend(points[i]);
        }
      }
      Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var min2, max2;
          if (!obj) {
            return this;
          }
          if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
            min2 = max2 = toPoint(obj);
          } else {
            obj = toBounds(obj);
            min2 = obj.min;
            max2 = obj.max;
            if (!min2 || !max2) {
              return this;
            }
          }
          if (!this.min && !this.max) {
            this.min = min2.clone();
            this.max = max2.clone();
          } else {
            this.min.x = Math.min(min2.x, this.min.x);
            this.max.x = Math.max(max2.x, this.max.x);
            this.min.y = Math.min(min2.y, this.min.y);
            this.max.y = Math.max(max2.y, this.max.y);
          }
          return this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(round) {
          return toPoint(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            round
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return toPoint(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return toPoint(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          var min, max;
          if (typeof obj[0] === "number" || obj instanceof Point) {
            obj = toPoint(obj);
          } else {
            obj = toBounds(obj);
          }
          if (obj instanceof Bounds) {
            min = obj.min;
            max = obj.max;
          } else {
            min = max = obj;
          }
          return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toBounds(bounds);
          var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
          return xIntersects && yIntersects;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toBounds(bounds);
          var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
          return xOverlaps && yOverlaps;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
          return toBounds(
            toPoint(min.x - heightBuffer, min.y - widthBuffer),
            toPoint(max.x + heightBuffer, max.y + widthBuffer)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(bounds) {
          if (!bounds) {
            return false;
          }
          bounds = toBounds(bounds);
          return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
        }
      };
      function toBounds(a, b) {
        if (!a || a instanceof Bounds) {
          return a;
        }
        return new Bounds(a, b);
      }
      function LatLngBounds(corner1, corner2) {
        if (!corner1) {
          return;
        }
        var latlngs = corner2 ? [corner1, corner2] : corner1;
        for (var i = 0, len = latlngs.length; i < len; i++) {
          this.extend(latlngs[i]);
        }
      }
      LatLngBounds.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLng2) {
            sw2 = obj;
            ne2 = obj;
          } else if (obj instanceof LatLngBounds) {
            sw2 = obj._southWest;
            ne2 = obj._northEast;
            if (!sw2 || !ne2) {
              return this;
            }
          } else {
            return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
          }
          if (!sw && !ne) {
            this._southWest = new LatLng2(sw2.lat, sw2.lng);
            this._northEast = new LatLng2(ne2.lat, ne2.lng);
          } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
          }
          return this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
          return new LatLngBounds(
            new LatLng2(sw.lat - heightBuffer, sw.lng - widthBuffer),
            new LatLng2(ne.lat + heightBuffer, ne.lng + widthBuffer)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new LatLng2(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new LatLng2(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new LatLng2(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          if (typeof obj[0] === "number" || obj instanceof LatLng2 || "lat" in obj) {
            obj = toLatLng(obj);
          } else {
            obj = toLatLngBounds(obj);
          }
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLngBounds) {
            sw2 = obj.getSouthWest();
            ne2 = obj.getNorthEast();
          } else {
            sw2 = ne2 = obj;
          }
          return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
          return latIntersects && lngIntersects;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
          return latOverlaps && lngOverlaps;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(bounds, maxMargin) {
          if (!bounds) {
            return false;
          }
          bounds = toLatLngBounds(bounds);
          return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function toLatLngBounds(a, b) {
        if (a instanceof LatLngBounds) {
          return a;
        }
        return new LatLngBounds(a, b);
      }
      function LatLng2(lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
          throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== void 0) {
          this.alt = +alt;
        }
      }
      LatLng2.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(obj, maxMargin) {
          if (!obj) {
            return false;
          }
          obj = toLatLng(obj);
          var margin = Math.max(
            Math.abs(this.lat - obj.lat),
            Math.abs(this.lng - obj.lng)
          );
          return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(precision) {
          return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(other) {
          return Earth.distance(this, toLatLng(other));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return Earth.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(sizeInMeters) {
          var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
          return toLatLngBounds(
            [this.lat - latAccuracy, this.lng - lngAccuracy],
            [this.lat + latAccuracy, this.lng + lngAccuracy]
          );
        },
        clone: function() {
          return new LatLng2(this.lat, this.lng, this.alt);
        }
      };
      function toLatLng(a, b, c) {
        if (a instanceof LatLng2) {
          return a;
        }
        if (isArray(a) && typeof a[0] !== "object") {
          if (a.length === 3) {
            return new LatLng2(a[0], a[1], a[2]);
          }
          if (a.length === 2) {
            return new LatLng2(a[0], a[1]);
          }
          return null;
        }
        if (a === void 0 || a === null) {
          return a;
        }
        if (typeof a === "object" && "lat" in a) {
          return new LatLng2(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
        }
        if (b === void 0) {
          return null;
        }
        return new LatLng2(a, b, c);
      }
      var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(latlng, zoom2) {
          var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
          return this.transformation._transform(projectedPoint, scale2);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(point, zoom2) {
          var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
          return this.projection.unproject(untransformedPoint);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(latlng) {
          return this.projection.project(latlng);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(point) {
          return this.projection.unproject(point);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(zoom2) {
          return 256 * Math.pow(2, zoom2);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(scale2) {
          return Math.log(scale2 / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(zoom2) {
          if (this.infinite) {
            return null;
          }
          var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
          return new Bounds(min, max);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(latlng) {
          var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
          return new LatLng2(lat, lng, alt);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(bounds) {
          var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
          if (latShift === 0 && lngShift === 0) {
            return bounds;
          }
          var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng2(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng2(ne.lat - latShift, ne.lng - lngShift);
          return new LatLngBounds(newSw, newNe);
        }
      };
      var Earth = extend({}, CRS, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(latlng1, latlng2) {
          var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return this.R * c;
        }
      });
      var earthRadius = 6378137;
      var SphericalMercator = {
        R: earthRadius,
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
          var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
          return new Point(
            this.R * latlng.lng * d,
            this.R * Math.log((1 + sin) / (1 - sin)) / 2
          );
        },
        unproject: function(point) {
          var d = 180 / Math.PI;
          return new LatLng2(
            (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d,
            point.x * d / this.R
          );
        },
        bounds: function() {
          var d = earthRadius * Math.PI;
          return new Bounds([-d, -d], [d, d]);
        }()
      };
      function Transformation(a, b, c, d) {
        if (isArray(a)) {
          this._a = a[0];
          this._b = a[1];
          this._c = a[2];
          this._d = a[3];
          return;
        }
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
      }
      Transformation.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(point, scale2) {
          return this._transform(point.clone(), scale2);
        },
        // destructive transform (faster)
        _transform: function(point, scale2) {
          scale2 = scale2 || 1;
          point.x = scale2 * (this._a * point.x + this._b);
          point.y = scale2 * (this._c * point.y + this._d);
          return point;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(point, scale2) {
          scale2 = scale2 || 1;
          return new Point(
            (point.x / scale2 - this._b) / this._a,
            (point.y / scale2 - this._d) / this._c
          );
        }
      };
      function toTransformation(a, b, c, d) {
        return new Transformation(a, b, c, d);
      }
      var EPSG3857 = extend({}, Earth, {
        code: "EPSG:3857",
        projection: SphericalMercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG900913 = extend({}, EPSG3857, {
        code: "EPSG:900913"
      });
      function svgCreate(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
      }
      function pointsToPath(rings, closed) {
        var str = "", i, j, len, len2, points, p;
        for (i = 0, len = rings.length; i < len; i++) {
          points = rings[i];
          for (j = 0, len2 = points.length; j < len2; j++) {
            p = points[j];
            str += (j ? "L" : "M") + p.x + " " + p.y;
          }
          str += closed ? Browser.svg ? "z" : "x" : "";
        }
        return str || "M0 0";
      }
      var style = document.documentElement.style;
      var ie = "ActiveXObject" in window;
      var ielt9 = ie && !document.addEventListener;
      var edge = "msLaunchUri" in navigator && !("documentMode" in document);
      var webkit = userAgentContains("webkit");
      var android = userAgentContains("android");
      var android23 = userAgentContains("android 2") || userAgentContains("android 3");
      var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
      var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
      var opera = !!window.opera;
      var chrome = !edge && userAgentContains("chrome");
      var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
      var safari = !chrome && userAgentContains("safari");
      var phantom = userAgentContains("phantom");
      var opera12 = "OTransition" in style;
      var win = navigator.platform.indexOf("Win") === 0;
      var ie3d = ie && "transition" in style;
      var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
      var gecko3d = "MozPerspective" in style;
      var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
      var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
      var mobileWebkit = mobile && webkit;
      var mobileWebkit3d = mobile && webkit3d;
      var msPointer = !window.PointerEvent && window.MSPointerEvent;
      var pointer = !!(window.PointerEvent || msPointer);
      var touchNative = "ontouchstart" in window || !!window.TouchEvent;
      var touch = !window.L_NO_TOUCH && (touchNative || pointer);
      var mobileOpera = mobile && opera;
      var mobileGecko = mobile && gecko;
      var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
      var passiveEvents = function() {
        var supportsPassiveOption = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassiveOption = true;
            }
          });
          window.addEventListener("testPassiveEventSupport", falseFn, opts);
          window.removeEventListener("testPassiveEventSupport", falseFn, opts);
        } catch (e) {
        }
        return supportsPassiveOption;
      }();
      var canvas$1 = function() {
        return !!document.createElement("canvas").getContext;
      }();
      var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
      var inlineSvg = !!svg$1 && function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }();
      var vml = !svg$1 && function() {
        try {
          var div = document.createElement("div");
          div.innerHTML = '<v:shape adj="1"/>';
          var shape = div.firstChild;
          shape.style.behavior = "url(#default#VML)";
          return shape && typeof shape.adj === "object";
        } catch (e) {
          return false;
        }
      }();
      var mac = navigator.platform.indexOf("Mac") === 0;
      var linux = navigator.platform.indexOf("Linux") === 0;
      function userAgentContains(str) {
        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
      }
      var Browser = {
        ie,
        ielt9,
        edge,
        webkit,
        android,
        android23,
        androidStock,
        opera,
        chrome,
        gecko,
        safari,
        phantom,
        opera12,
        win,
        ie3d,
        webkit3d,
        gecko3d,
        any3d,
        mobile,
        mobileWebkit,
        mobileWebkit3d,
        msPointer,
        pointer,
        touch,
        touchNative,
        mobileOpera,
        mobileGecko,
        retina,
        passiveEvents,
        canvas: canvas$1,
        svg: svg$1,
        vml,
        inlineSvg,
        mac,
        linux
      };
      var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
      var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
      var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
      var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
      var pEvent = {
        touchstart: POINTER_DOWN,
        touchmove: POINTER_MOVE,
        touchend: POINTER_UP,
        touchcancel: POINTER_CANCEL
      };
      var handle = {
        touchstart: _onPointerStart,
        touchmove: _handlePointer,
        touchend: _handlePointer,
        touchcancel: _handlePointer
      };
      var _pointers = {};
      var _pointerDocListener = false;
      function addPointerListener(obj, type, handler) {
        if (type === "touchstart") {
          _addPointerDocListener();
        }
        if (!handle[type]) {
          console.warn("wrong event specified:", type);
          return falseFn;
        }
        handler = handle[type].bind(this, handler);
        obj.addEventListener(pEvent[type], handler, false);
        return handler;
      }
      function removePointerListener(obj, type, handler) {
        if (!pEvent[type]) {
          console.warn("wrong event specified:", type);
          return;
        }
        obj.removeEventListener(pEvent[type], handler, false);
      }
      function _globalPointerDown(e) {
        _pointers[e.pointerId] = e;
      }
      function _globalPointerMove(e) {
        if (_pointers[e.pointerId]) {
          _pointers[e.pointerId] = e;
        }
      }
      function _globalPointerUp(e) {
        delete _pointers[e.pointerId];
      }
      function _addPointerDocListener() {
        if (!_pointerDocListener) {
          document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
          document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
          document.addEventListener(POINTER_UP, _globalPointerUp, true);
          document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
          _pointerDocListener = true;
        }
      }
      function _handlePointer(handler, e) {
        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
          return;
        }
        e.touches = [];
        for (var i in _pointers) {
          e.touches.push(_pointers[i]);
        }
        e.changedTouches = [e];
        handler(e);
      }
      function _onPointerStart(handler, e) {
        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e);
        }
        _handlePointer(handler, e);
      }
      function makeDblclick(event) {
        var newEvent = {}, prop, i;
        for (i in event) {
          prop = event[i];
          newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
        }
        event = newEvent;
        newEvent.type = "dblclick";
        newEvent.detail = 2;
        newEvent.isTrusted = false;
        newEvent._simulated = true;
        return newEvent;
      }
      var delay = 200;
      function addDoubleTapListener(obj, handler) {
        obj.addEventListener("dblclick", handler);
        var last = 0, detail;
        function simDblclick(e) {
          if (e.detail !== 1) {
            detail = e.detail;
            return;
          }
          if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
            return;
          }
          var path = getPropagationPath(e);
          if (path.some(function(el) {
            return el instanceof HTMLLabelElement && el.attributes.for;
          }) && !path.some(function(el) {
            return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
          })) {
            return;
          }
          var now = Date.now();
          if (now - last <= delay) {
            detail++;
            if (detail === 2) {
              handler(makeDblclick(e));
            }
          } else {
            detail = 1;
          }
          last = now;
        }
        obj.addEventListener("click", simDblclick);
        return {
          dblclick: handler,
          simDblclick
        };
      }
      function removeDoubleTapListener(obj, handlers) {
        obj.removeEventListener("dblclick", handlers.dblclick);
        obj.removeEventListener("click", handlers.simDblclick);
      }
      var TRANSFORM = testProp(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      );
      var TRANSITION = testProp(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      );
      var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
      function get(id) {
        return typeof id === "string" ? document.getElementById(id) : id;
      }
      function getStyle(el, style2) {
        var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
        if ((!value || value === "auto") && document.defaultView) {
          var css = document.defaultView.getComputedStyle(el, null);
          value = css ? css[style2] : null;
        }
        return value === "auto" ? null : value;
      }
      function create$1(tagName, className, container) {
        var el = document.createElement(tagName);
        el.className = className || "";
        if (container) {
          container.appendChild(el);
        }
        return el;
      }
      function remove(el) {
        var parent = el.parentNode;
        if (parent) {
          parent.removeChild(el);
        }
      }
      function empty(el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      }
      function toFront(el) {
        var parent = el.parentNode;
        if (parent && parent.lastChild !== el) {
          parent.appendChild(el);
        }
      }
      function toBack(el) {
        var parent = el.parentNode;
        if (parent && parent.firstChild !== el) {
          parent.insertBefore(el, parent.firstChild);
        }
      }
      function hasClass(el, name) {
        if (el.classList !== void 0) {
          return el.classList.contains(name);
        }
        var className = getClass(el);
        return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
      }
      function addClass(el, name) {
        if (el.classList !== void 0) {
          var classes = splitWords(name);
          for (var i = 0, len = classes.length; i < len; i++) {
            el.classList.add(classes[i]);
          }
        } else if (!hasClass(el, name)) {
          var className = getClass(el);
          setClass(el, (className ? className + " " : "") + name);
        }
      }
      function removeClass(el, name) {
        if (el.classList !== void 0) {
          el.classList.remove(name);
        } else {
          setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
        }
      }
      function setClass(el, name) {
        if (el.className.baseVal === void 0) {
          el.className = name;
        } else {
          el.className.baseVal = name;
        }
      }
      function getClass(el) {
        if (el.correspondingElement) {
          el = el.correspondingElement;
        }
        return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
      }
      function setOpacity(el, value) {
        if ("opacity" in el.style) {
          el.style.opacity = value;
        } else if ("filter" in el.style) {
          _setOpacityIE(el, value);
        }
      }
      function _setOpacityIE(el, value) {
        var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
        try {
          filter = el.filters.item(filterName);
        } catch (e) {
          if (value === 1) {
            return;
          }
        }
        value = Math.round(value * 100);
        if (filter) {
          filter.Enabled = value !== 100;
          filter.Opacity = value;
        } else {
          el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
        }
      }
      function testProp(props) {
        var style2 = document.documentElement.style;
        for (var i = 0; i < props.length; i++) {
          if (props[i] in style2) {
            return props[i];
          }
        }
        return false;
      }
      function setTransform(el, offset, scale2) {
        var pos = offset || new Point(0, 0);
        el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
      }
      function setPosition(el, point) {
        el._leaflet_pos = point;
        if (Browser.any3d) {
          setTransform(el, point);
        } else {
          el.style.left = point.x + "px";
          el.style.top = point.y + "px";
        }
      }
      function getPosition(el) {
        return el._leaflet_pos || new Point(0, 0);
      }
      var disableTextSelection;
      var enableTextSelection;
      var _userSelect;
      if ("onselectstart" in document) {
        disableTextSelection = function() {
          on(window, "selectstart", preventDefault);
        };
        enableTextSelection = function() {
          off(window, "selectstart", preventDefault);
        };
      } else {
        var userSelectProperty = testProp(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        disableTextSelection = function() {
          if (userSelectProperty) {
            var style2 = document.documentElement.style;
            _userSelect = style2[userSelectProperty];
            style2[userSelectProperty] = "none";
          }
        };
        enableTextSelection = function() {
          if (userSelectProperty) {
            document.documentElement.style[userSelectProperty] = _userSelect;
            _userSelect = void 0;
          }
        };
      }
      function disableImageDrag() {
        on(window, "dragstart", preventDefault);
      }
      function enableImageDrag() {
        off(window, "dragstart", preventDefault);
      }
      var _outlineElement, _outlineStyle;
      function preventOutline(element) {
        while (element.tabIndex === -1) {
          element = element.parentNode;
        }
        if (!element.style) {
          return;
        }
        restoreOutline();
        _outlineElement = element;
        _outlineStyle = element.style.outlineStyle;
        element.style.outlineStyle = "none";
        on(window, "keydown", restoreOutline);
      }
      function restoreOutline() {
        if (!_outlineElement) {
          return;
        }
        _outlineElement.style.outlineStyle = _outlineStyle;
        _outlineElement = void 0;
        _outlineStyle = void 0;
        off(window, "keydown", restoreOutline);
      }
      function getSizedParentNode(element) {
        do {
          element = element.parentNode;
        } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
        return element;
      }
      function getScale(element) {
        var rect = element.getBoundingClientRect();
        return {
          x: rect.width / element.offsetWidth || 1,
          y: rect.height / element.offsetHeight || 1,
          boundingClientRect: rect
        };
      }
      var DomUtil = {
        __proto__: null,
        TRANSFORM,
        TRANSITION,
        TRANSITION_END,
        get,
        getStyle,
        create: create$1,
        remove,
        empty,
        toFront,
        toBack,
        hasClass,
        addClass,
        removeClass,
        setClass,
        getClass,
        setOpacity,
        testProp,
        setTransform,
        setPosition,
        getPosition,
        get disableTextSelection() {
          return disableTextSelection;
        },
        get enableTextSelection() {
          return enableTextSelection;
        },
        disableImageDrag,
        enableImageDrag,
        preventOutline,
        restoreOutline,
        getSizedParentNode,
        getScale
      };
      function on(obj, types, fn, context) {
        if (types && typeof types === "object") {
          for (var type in types) {
            addOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          for (var i = 0, len = types.length; i < len; i++) {
            addOne(obj, types[i], fn, context);
          }
        }
        return this;
      }
      var eventsKey = "_leaflet_events";
      function off(obj, types, fn, context) {
        if (arguments.length === 1) {
          batchRemove(obj);
          delete obj[eventsKey];
        } else if (types && typeof types === "object") {
          for (var type in types) {
            removeOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          if (arguments.length === 2) {
            batchRemove(obj, function(type2) {
              return indexOf(types, type2) !== -1;
            });
          } else {
            for (var i = 0, len = types.length; i < len; i++) {
              removeOne(obj, types[i], fn, context);
            }
          }
        }
        return this;
      }
      function batchRemove(obj, filterFn) {
        for (var id in obj[eventsKey]) {
          var type = id.split(/\d/)[0];
          if (!filterFn || filterFn(type)) {
            removeOne(obj, type, null, null, id);
          }
        }
      }
      var mouseSubst = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function addOne(obj, type, fn, context) {
        var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
        if (obj[eventsKey] && obj[eventsKey][id]) {
          return this;
        }
        var handler = function(e) {
          return fn.call(context || obj, e || window.event);
        };
        var originalHandler = handler;
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          handler = addPointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          handler = addDoubleTapListener(obj, handler);
        } else if ("addEventListener" in obj) {
          if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
            obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
          } else if (type === "mouseenter" || type === "mouseleave") {
            handler = function(e) {
              e = e || window.event;
              if (isExternalTarget(obj, e)) {
                originalHandler(e);
              }
            };
            obj.addEventListener(mouseSubst[type], handler, false);
          } else {
            obj.addEventListener(type, originalHandler, false);
          }
        } else {
          obj.attachEvent("on" + type, handler);
        }
        obj[eventsKey] = obj[eventsKey] || {};
        obj[eventsKey][id] = handler;
      }
      function removeOne(obj, type, fn, context, id) {
        id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
        var handler = obj[eventsKey] && obj[eventsKey][id];
        if (!handler) {
          return this;
        }
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          removePointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          removeDoubleTapListener(obj, handler);
        } else if ("removeEventListener" in obj) {
          obj.removeEventListener(mouseSubst[type] || type, handler, false);
        } else {
          obj.detachEvent("on" + type, handler);
        }
        obj[eventsKey][id] = null;
      }
      function stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else if (e.originalEvent) {
          e.originalEvent._stopped = true;
        } else {
          e.cancelBubble = true;
        }
        return this;
      }
      function disableScrollPropagation(el) {
        addOne(el, "wheel", stopPropagation);
        return this;
      }
      function disableClickPropagation(el) {
        on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
        el["_leaflet_disable_click"] = true;
        return this;
      }
      function preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
        return this;
      }
      function stop(e) {
        preventDefault(e);
        stopPropagation(e);
        return this;
      }
      function getPropagationPath(ev) {
        if (ev.composedPath) {
          return ev.composedPath();
        }
        var path = [];
        var el = ev.target;
        while (el) {
          path.push(el);
          el = el.parentNode;
        }
        return path;
      }
      function getMousePosition(e, container) {
        if (!container) {
          return new Point(e.clientX, e.clientY);
        }
        var scale2 = getScale(container), offset = scale2.boundingClientRect;
        return new Point(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (e.clientX - offset.left) / scale2.x - container.clientLeft,
          (e.clientY - offset.top) / scale2.y - container.clientTop
        );
      }
      var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function getWheelDelta(e) {
        return Browser.edge ? e.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : (
            // Pixels
            e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : (
              // Lines
              e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : (
                // Pages
                e.deltaX || e.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : (
                      // Legacy Moz lines
                      e.detail ? e.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function isExternalTarget(el, e) {
        var related = e.relatedTarget;
        if (!related) {
          return true;
        }
        try {
          while (related && related !== el) {
            related = related.parentNode;
          }
        } catch (err) {
          return false;
        }
        return related !== el;
      }
      var DomEvent = {
        __proto__: null,
        on,
        off,
        stopPropagation,
        disableScrollPropagation,
        disableClickPropagation,
        preventDefault,
        stop,
        getPropagationPath,
        getMousePosition,
        getWheelDelta,
        isExternalTarget,
        addListener: on,
        removeListener: off
      };
      var PosAnimation = Evented.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(el, newPos, duration, easeLinearity) {
          this.stop();
          this._el = el;
          this._inProgress = true;
          this._duration = duration || 0.25;
          this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
          this._startPos = getPosition(el);
          this._offset = newPos.subtract(this._startPos);
          this._startTime = +/* @__PURE__ */ new Date();
          this.fire("start");
          this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          if (!this._inProgress) {
            return;
          }
          this._step(true);
          this._complete();
        },
        _animate: function() {
          this._animId = requestAnimFrame(this._animate, this);
          this._step();
        },
        _step: function(round) {
          var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
          if (elapsed < duration) {
            this._runFrame(this._easeOut(elapsed / duration), round);
          } else {
            this._runFrame(1);
            this._complete();
          }
        },
        _runFrame: function(progress, round) {
          var pos = this._startPos.add(this._offset.multiplyBy(progress));
          if (round) {
            pos._round();
          }
          setPosition(this._el, pos);
          this.fire("step");
        },
        _complete: function() {
          cancelAnimFrame(this._animId);
          this._inProgress = false;
          this.fire("end");
        },
        _easeOut: function(t) {
          return 1 - Math.pow(1 - t, this._easeOutPower);
        }
      });
      var Map = Evented.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: EPSG3857,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: true,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: true,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: true,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: true
        },
        initialize: function(id, options) {
          options = setOptions(this, options);
          this._handlers = [];
          this._layers = {};
          this._zoomBoundLayers = {};
          this._sizeChanged = true;
          this._initContainer(id);
          this._initLayout();
          this._onResize = bind(this._onResize, this);
          this._initEvents();
          if (options.maxBounds) {
            this.setMaxBounds(options.maxBounds);
          }
          if (options.zoom !== void 0) {
            this._zoom = this._limitZoom(options.zoom);
          }
          if (options.center && options.zoom !== void 0) {
            this.setView(toLatLng(options.center), options.zoom, { reset: true });
          }
          this.callInitHooks();
          this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
          if (this._zoomAnimated) {
            this._createAnimProxy();
            on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
          }
          this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(center, zoom2, options) {
          zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
          center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
          options = options || {};
          this._stop();
          if (this._loaded && !options.reset && options !== true) {
            if (options.animate !== void 0) {
              options.zoom = extend({ animate: options.animate }, options.zoom);
              options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
            }
            var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
            if (moved) {
              clearTimeout(this._sizeTimer);
              return this;
            }
          }
          this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
          return this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(zoom2, options) {
          if (!this._loaded) {
            this._zoom = zoom2;
            return this;
          }
          return this.setView(this.getCenter(), zoom2, { zoom: options });
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(delta, options) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom + delta, options);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(delta, options) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom - delta, options);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(latlng, zoom2, options) {
          var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
          return this.setView(newCenter, zoom2, { zoom: options });
        },
        _getBoundsCenterZoom: function(bounds, options) {
          options = options || {};
          bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
          zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
          if (zoom2 === Infinity) {
            return {
              center: bounds.getCenter(),
              zoom: zoom2
            };
          }
          var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
          return {
            center,
            zoom: zoom2
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(bounds, options) {
          bounds = toLatLngBounds(bounds);
          if (!bounds.isValid()) {
            throw new Error("Bounds are not valid.");
          }
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.setView(target.center, target.zoom, options);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(options) {
          return this.fitBounds([[-90, -180], [90, 180]], options);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(center, options) {
          return this.setView(center, this._zoom, { pan: options });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(offset, options) {
          offset = toPoint(offset).round();
          options = options || {};
          if (!offset.x && !offset.y) {
            return this.fire("moveend");
          }
          if (options.animate !== true && !this.getSize().contains(offset)) {
            this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
            return this;
          }
          if (!this._panAnim) {
            this._panAnim = new PosAnimation();
            this._panAnim.on({
              "step": this._onPanTransitionStep,
              "end": this._onPanTransitionEnd
            }, this);
          }
          if (!options.noMoveStart) {
            this.fire("movestart");
          }
          if (options.animate !== false) {
            addClass(this._mapPane, "leaflet-pan-anim");
            var newPos = this._getMapPanePos().subtract(offset).round();
            this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
          } else {
            this._rawPanBy(offset);
            this.fire("move").fire("moveend");
          }
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(targetCenter, targetZoom, options) {
          options = options || {};
          if (options.animate === false || !Browser.any3d) {
            return this.setView(targetCenter, targetZoom, options);
          }
          this._stop();
          var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
          targetCenter = toLatLng(targetCenter);
          targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
          var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
          function r(i) {
            var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
            var log = sq < 1e-9 ? -18 : Math.log(sq);
            return log;
          }
          function sinh(n) {
            return (Math.exp(n) - Math.exp(-n)) / 2;
          }
          function cosh(n) {
            return (Math.exp(n) + Math.exp(-n)) / 2;
          }
          function tanh(n) {
            return sinh(n) / cosh(n);
          }
          var r0 = r(0);
          function w(s) {
            return w0 * (cosh(r0) / cosh(r0 + rho * s));
          }
          function u(s) {
            return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
          }
          function easeOut(t) {
            return 1 - Math.pow(1 - t, 1.5);
          }
          var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
          function frame() {
            var t = (Date.now() - start) / duration, s = easeOut(t) * S;
            if (t <= 1) {
              this._flyToFrame = requestAnimFrame(frame, this);
              this._move(
                this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                this.getScaleZoom(w0 / w(s), startZoom),
                { flyTo: true }
              );
            } else {
              this._move(targetCenter, targetZoom)._moveEnd(true);
            }
          }
          this._moveStart(true, options.noMoveStart);
          frame.call(this);
          return this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(bounds, options) {
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.flyTo(target.center, target.zoom, options);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(bounds) {
          bounds = toLatLngBounds(bounds);
          if (this.listens("moveend", this._panInsideMaxBounds)) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (!bounds.isValid()) {
            this.options.maxBounds = null;
            return this;
          }
          this.options.maxBounds = bounds;
          if (this._loaded) {
            this._panInsideMaxBounds();
          }
          return this.on("moveend", this._panInsideMaxBounds);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(zoom2) {
          var oldZoom = this.options.minZoom;
          this.options.minZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() < this.options.minZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(zoom2) {
          var oldZoom = this.options.maxZoom;
          this.options.maxZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() > this.options.maxZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(bounds, options) {
          this._enforcingBounds = true;
          var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
          if (!center.equals(newCenter)) {
            this.panTo(newCenter, options);
          }
          this._enforcingBounds = false;
          return this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(latlng, options) {
          options = options || {};
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
          if (!paddedBounds.contains(pixelPoint)) {
            this._enforcingBounds = true;
            var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
            var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
            pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
            pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
            this.panTo(this.unproject(pixelCenter), options);
            this._enforcingBounds = false;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(options) {
          if (!this._loaded) {
            return this;
          }
          options = extend({
            animate: false,
            pan: true
          }, options === true ? { animate: true } : options);
          var oldSize = this.getSize();
          this._sizeChanged = true;
          this._lastCenter = null;
          var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
          if (!offset.x && !offset.y) {
            return this;
          }
          if (options.animate && options.pan) {
            this.panBy(offset);
          } else {
            if (options.pan) {
              this._rawPanBy(offset);
            }
            this.fire("move");
            if (options.debounceMoveend) {
              clearTimeout(this._sizeTimer);
              this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
            } else {
              this.fire("moveend");
            }
          }
          return this.fire("resize", {
            oldSize,
            newSize
          });
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          this.setZoom(this._limitZoom(this._zoom));
          if (!this.options.zoomSnap) {
            this.fire("viewreset");
          }
          return this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(options) {
          options = this._locateOptions = extend({
            timeout: 1e4,
            watch: false
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, options);
          if (!("geolocation" in navigator)) {
            this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            });
            return this;
          }
          var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
          if (options.watch) {
            this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
          } else {
            navigator.geolocation.getCurrentPosition(onResponse, onError, options);
          }
          return this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          if (navigator.geolocation && navigator.geolocation.clearWatch) {
            navigator.geolocation.clearWatch(this._locationWatchId);
          }
          if (this._locateOptions) {
            this._locateOptions.setView = false;
          }
          return this;
        },
        _handleGeolocationError: function(error) {
          if (!this._container._leaflet_id) {
            return;
          }
          var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
          if (this._locateOptions.setView && !this._loaded) {
            this.fitWorld();
          }
          this.fire("locationerror", {
            code: c,
            message: "Geolocation error: " + message + "."
          });
        },
        _handleGeolocationResponse: function(pos) {
          if (!this._container._leaflet_id) {
            return;
          }
          var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng2(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
          if (options.setView) {
            var zoom2 = this.getBoundsZoom(bounds);
            this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
          }
          var data = {
            latlng,
            bounds,
            timestamp: pos.timestamp
          };
          for (var i in pos.coords) {
            if (typeof pos.coords[i] === "number") {
              data[i] = pos.coords[i];
            }
          }
          this.fire("locationfound", data);
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(name, HandlerClass) {
          if (!HandlerClass) {
            return this;
          }
          var handler = this[name] = new HandlerClass(this);
          this._handlers.push(handler);
          if (this.options[name]) {
            handler.enable();
          }
          return this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          this._initEvents(true);
          if (this.options.maxBounds) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (this._containerId !== this._container._leaflet_id) {
            throw new Error("Map container is being reused by another instance");
          }
          try {
            delete this._container._leaflet_id;
            delete this._containerId;
          } catch (e) {
            this._container._leaflet_id = void 0;
            this._containerId = void 0;
          }
          if (this._locationWatchId !== void 0) {
            this.stopLocate();
          }
          this._stop();
          remove(this._mapPane);
          if (this._clearControlPos) {
            this._clearControlPos();
          }
          if (this._resizeRequest) {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = null;
          }
          this._clearHandlers();
          if (this._loaded) {
            this.fire("unload");
          }
          var i;
          for (i in this._layers) {
            this._layers[i].remove();
          }
          for (i in this._panes) {
            remove(this._panes[i]);
          }
          this._layers = [];
          this._panes = [];
          delete this._mapPane;
          delete this._renderer;
          return this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(name, container) {
          var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
          if (name) {
            this._panes[name] = pane;
          }
          return pane;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          this._checkIfLoaded();
          if (this._lastCenter && !this._moved()) {
            return this._lastCenter.clone();
          }
          return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
          return new LatLngBounds(sw, ne);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(bounds, inside, padding) {
          bounds = toLatLngBounds(bounds);
          padding = toPoint(padding || [0, 0]);
          var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
          zoom2 = this.getScaleZoom(scale2, zoom2);
          if (snap) {
            zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
            zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
          }
          return Math.max(min, Math.min(max, zoom2));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          if (!this._size || this._sizeChanged) {
            this._size = new Point(
              this._container.clientWidth || 0,
              this._container.clientHeight || 0
            );
            this._sizeChanged = false;
          }
          return this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(center, zoom2) {
          var topLeftPoint = this._getTopLeftPoint(center, zoom2);
          return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          this._checkIfLoaded();
          return this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(zoom2) {
          return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(pane) {
          return typeof pane === "string" ? this._panes[pane] : pane;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(toZoom, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          return crs.scale(toZoom) / crs.scale(fromZoom);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(scale2, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
          return isNaN(zoom2) ? Infinity : zoom2;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(latlng, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(point, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.pointToLatLng(toPoint(point), zoom2);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(point) {
          var projectedPoint = toPoint(point).add(this.getPixelOrigin());
          return this.unproject(projectedPoint);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(latlng) {
          var projectedPoint = this.project(toLatLng(latlng))._round();
          return projectedPoint._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(latlng) {
          return this.options.crs.wrapLatLng(toLatLng(latlng));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(latlng) {
          return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(latlng1, latlng2) {
          return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(point) {
          return toPoint(point).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(point) {
          return toPoint(point).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(point) {
          var layerPoint = this.containerPointToLayerPoint(toPoint(point));
          return this.layerPointToLatLng(layerPoint);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(latlng) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(e) {
          return getMousePosition(e, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(e) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(e) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        // map initialization methods
        _initContainer: function(id) {
          var container = this._container = get(id);
          if (!container) {
            throw new Error("Map container not found.");
          } else if (container._leaflet_id) {
            throw new Error("Map container is already initialized.");
          }
          on(container, "scroll", this._onScroll, this);
          this._containerId = stamp(container);
        },
        _initLayout: function() {
          var container = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
          addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var position = getStyle(container, "position");
          if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
            container.style.position = "relative";
          }
          this._initPanes();
          if (this._initControlPos) {
            this._initControlPos();
          }
        },
        _initPanes: function() {
          var panes = this._panes = {};
          this._paneRenderers = {};
          this._mapPane = this.createPane("mapPane", this._container);
          setPosition(this._mapPane, new Point(0, 0));
          this.createPane("tilePane");
          this.createPane("overlayPane");
          this.createPane("shadowPane");
          this.createPane("markerPane");
          this.createPane("tooltipPane");
          this.createPane("popupPane");
          if (!this.options.markerZoomAnimation) {
            addClass(panes.markerPane, "leaflet-zoom-hide");
            addClass(panes.shadowPane, "leaflet-zoom-hide");
          }
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(center, zoom2, noMoveStart) {
          setPosition(this._mapPane, new Point(0, 0));
          var loading = !this._loaded;
          this._loaded = true;
          zoom2 = this._limitZoom(zoom2);
          this.fire("viewprereset");
          var zoomChanged = this._zoom !== zoom2;
          this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
          this.fire("viewreset");
          if (loading) {
            this.fire("load");
          }
        },
        _moveStart: function(zoomChanged, noMoveStart) {
          if (zoomChanged) {
            this.fire("zoomstart");
          }
          if (!noMoveStart) {
            this.fire("movestart");
          }
          return this;
        },
        _move: function(center, zoom2, data, supressEvent) {
          if (zoom2 === void 0) {
            zoom2 = this._zoom;
          }
          var zoomChanged = this._zoom !== zoom2;
          this._zoom = zoom2;
          this._lastCenter = center;
          this._pixelOrigin = this._getNewPixelOrigin(center);
          if (!supressEvent) {
            if (zoomChanged || data && data.pinch) {
              this.fire("zoom", data);
            }
            this.fire("move", data);
          } else if (data && data.pinch) {
            this.fire("zoom", data);
          }
          return this;
        },
        _moveEnd: function(zoomChanged) {
          if (zoomChanged) {
            this.fire("zoomend");
          }
          return this.fire("moveend");
        },
        _stop: function() {
          cancelAnimFrame(this._flyToFrame);
          if (this._panAnim) {
            this._panAnim.stop();
          }
          return this;
        },
        _rawPanBy: function(offset) {
          setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          if (!this._enforcingBounds) {
            this.panInsideBounds(this.options.maxBounds);
          }
        },
        _checkIfLoaded: function() {
          if (!this._loaded) {
            throw new Error("Set map center and zoom first.");
          }
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(remove2) {
          this._targets = {};
          this._targets[stamp(this._container)] = this;
          var onOff = remove2 ? off : on;
          onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
          if (this.options.trackResize) {
            onOff(window, "resize", this._onResize, this);
          }
          if (Browser.any3d && this.options.transform3DLimit) {
            (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
          }
        },
        _onResize: function() {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = requestAnimFrame(
            function() {
              this.invalidateSize({ debounceMoveend: true });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0;
          this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var pos = this._getMapPanePos();
          if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
            this._resetView(this.getCenter(), this.getZoom());
          }
        },
        _findEventTargets: function(e, type) {
          var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
          while (src) {
            target = this._targets[stamp(src)];
            if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
              dragging = true;
              break;
            }
            if (target && target.listens(type, true)) {
              if (isHover && !isExternalTarget(src, e)) {
                break;
              }
              targets.push(target);
              if (isHover) {
                break;
              }
            }
            if (src === this._container) {
              break;
            }
            src = src.parentNode;
          }
          if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
            targets = [this];
          }
          return targets;
        },
        _isClickDisabled: function(el) {
          while (el && el !== this._container) {
            if (el["_leaflet_disable_click"]) {
              return true;
            }
            el = el.parentNode;
          }
        },
        _handleDOMEvent: function(e) {
          var el = e.target || e.srcElement;
          if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
            return;
          }
          var type = e.type;
          if (type === "mousedown") {
            preventOutline(el);
          }
          this._fireDOMEvent(e, type);
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(e, type, canvasTargets) {
          if (e.type === "click") {
            var synth = extend({}, e);
            synth.type = "preclick";
            this._fireDOMEvent(synth, synth.type, canvasTargets);
          }
          var targets = this._findEventTargets(e, type);
          if (canvasTargets) {
            var filtered = [];
            for (var i = 0; i < canvasTargets.length; i++) {
              if (canvasTargets[i].listens(type, true)) {
                filtered.push(canvasTargets[i]);
              }
            }
            targets = filtered.concat(targets);
          }
          if (!targets.length) {
            return;
          }
          if (type === "contextmenu") {
            preventDefault(e);
          }
          var target = targets[0];
          var data = {
            originalEvent: e
          };
          if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
          }
          for (i = 0; i < targets.length; i++) {
            targets[i].fire(type, data, true);
            if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
              return;
            }
          }
        },
        _draggableMoved: function(obj) {
          obj = obj.dragging && obj.dragging.enabled() ? obj : this;
          return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var i = 0, len = this._handlers.length; i < len; i++) {
            this._handlers[i].disable();
          }
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(callback, context) {
          if (this._loaded) {
            callback.call(context || this, { target: this });
          } else {
            this.on("load", callback, context);
          }
          return this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return getPosition(this._mapPane) || new Point(0, 0);
        },
        _moved: function() {
          var pos = this._getMapPanePos();
          return pos && !pos.equals([0, 0]);
        },
        _getTopLeftPoint: function(center, zoom2) {
          var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
          return pixelOrigin.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(center, zoom2) {
          var viewHalf = this.getSize()._divideBy(2);
          return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(latlng, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return this.project(latlng, zoom2)._subtract(topLeft);
        },
        _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return toBounds([
            this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(latlng) {
          return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(center, zoom2, bounds) {
          if (!bounds) {
            return center;
          }
          var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
          if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
            return center;
          }
          return this.unproject(centerPoint.add(offset), zoom2);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(offset, bounds) {
          if (!bounds) {
            return offset;
          }
          var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
          return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
          var projectedMaxBounds = toBounds(
            this.project(maxBounds.getNorthEast(), zoom2),
            this.project(maxBounds.getSouthWest(), zoom2)
          ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
          return new Point(dx, dy);
        },
        _rebound: function(left, right) {
          return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom2) {
          var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
          if (snap) {
            zoom2 = Math.round(zoom2 / snap) * snap;
          }
          return Math.max(min, Math.min(max, zoom2));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          removeClass(this._mapPane, "leaflet-pan-anim");
          this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options) {
          var offset = this._getCenterOffset(center)._trunc();
          if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
            return false;
          }
          this.panBy(offset, options);
          return true;
        },
        _createAnimProxy: function() {
          var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(proxy);
          this.on("zoomanim", function(e) {
            var prop = TRANSFORM, transform = this._proxy.style[prop];
            setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
            if (transform === this._proxy.style[prop] && this._animatingZoom) {
              this._onZoomTransitionEnd();
            }
          }, this);
          this.on("load moveend", this._animMoveEnd, this);
          this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          remove(this._proxy);
          this.off("load moveend", this._animMoveEnd, this);
          delete this._proxy;
        },
        _animMoveEnd: function() {
          var c = this.getCenter(), z = this.getZoom();
          setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
        },
        _catchTransitionEnd: function(e) {
          if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
            this._onZoomTransitionEnd();
          }
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom2, options) {
          if (this._animatingZoom) {
            return true;
          }
          options = options || {};
          if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
            return false;
          }
          var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
          if (options.animate !== true && !this.getSize().contains(offset)) {
            return false;
          }
          requestAnimFrame(function() {
            this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
          }, this);
          return true;
        },
        _animateZoom: function(center, zoom2, startAnim, noUpdate) {
          if (!this._mapPane) {
            return;
          }
          if (startAnim) {
            this._animatingZoom = true;
            this._animateToCenter = center;
            this._animateToZoom = zoom2;
            addClass(this._mapPane, "leaflet-zoom-anim");
          }
          this.fire("zoomanim", {
            center,
            zoom: zoom2,
            noUpdate
          });
          if (!this._tempFireZoomEvent) {
            this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
          }
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          setTimeout(bind(this._onZoomTransitionEnd, this), 250);
        },
        _onZoomTransitionEnd: function() {
          if (!this._animatingZoom) {
            return;
          }
          if (this._mapPane) {
            removeClass(this._mapPane, "leaflet-zoom-anim");
          }
          this._animatingZoom = false;
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          if (this._tempFireZoomEvent) {
            this.fire("zoom");
          }
          delete this._tempFireZoomEvent;
          this.fire("move");
          this._moveEnd(true);
        }
      });
      function createMap(id, options) {
        return new Map(id, options);
      }
      var Control = Class.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(position) {
          var map2 = this._map;
          if (map2) {
            map2.removeControl(this);
          }
          this.options.position = position;
          if (map2) {
            map2.addControl(this);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(map2) {
          this.remove();
          this._map = map2;
          var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
          addClass(container, "leaflet-control");
          if (pos.indexOf("bottom") !== -1) {
            corner.insertBefore(container, corner.firstChild);
          } else {
            corner.appendChild(container);
          }
          this._map.on("unload", this.remove, this);
          return this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          if (!this._map) {
            return this;
          }
          remove(this._container);
          if (this.onRemove) {
            this.onRemove(this._map);
          }
          this._map.off("unload", this.remove, this);
          this._map = null;
          return this;
        },
        _refocusOnMap: function(e) {
          if (this._map && e && e.screenX > 0 && e.screenY > 0) {
            this._map.getContainer().focus();
          }
        }
      });
      var control = function(options) {
        return new Control(options);
      };
      Map.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(control2) {
          control2.addTo(this);
          return this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(control2) {
          control2.remove();
          return this;
        },
        _initControlPos: function() {
          var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
          function createCorner(vSide, hSide) {
            var className = l + vSide + " " + l + hSide;
            corners[vSide + hSide] = create$1("div", className, container);
          }
          createCorner("top", "left");
          createCorner("top", "right");
          createCorner("bottom", "left");
          createCorner("bottom", "right");
        },
        _clearControlPos: function() {
          for (var i in this._controlCorners) {
            remove(this._controlCorners[i]);
          }
          remove(this._controlContainer);
          delete this._controlCorners;
          delete this._controlContainer;
        }
      });
      var Layers = Control.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: true,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: true,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: false,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: false,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(layerA, layerB, nameA, nameB) {
            return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
          }
        },
        initialize: function(baseLayers, overlays, options) {
          setOptions(this, options);
          this._layerControlInputs = [];
          this._layers = [];
          this._lastZIndex = 0;
          this._handlingClick = false;
          this._preventClick = false;
          for (var i in baseLayers) {
            this._addLayer(baseLayers[i], i);
          }
          for (i in overlays) {
            this._addLayer(overlays[i], i, true);
          }
        },
        onAdd: function(map2) {
          this._initLayout();
          this._update();
          this._map = map2;
          map2.on("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.on("add remove", this._onLayerChange, this);
          }
          return this._container;
        },
        addTo: function(map2) {
          Control.prototype.addTo.call(this, map2);
          return this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.off("add remove", this._onLayerChange, this);
          }
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(layer, name) {
          this._addLayer(layer, name);
          return this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(layer, name) {
          this._addLayer(layer, name, true);
          return this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(layer) {
          layer.off("add remove", this._onLayerChange, this);
          var obj = this._getLayer(stamp(layer));
          if (obj) {
            this._layers.splice(this._layers.indexOf(obj), 1);
          }
          return this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          addClass(this._container, "leaflet-control-layers-expanded");
          this._section.style.height = null;
          var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
          if (acceptableHeight < this._section.clientHeight) {
            addClass(this._section, "leaflet-control-layers-scrollbar");
            this._section.style.height = acceptableHeight + "px";
          } else {
            removeClass(this._section, "leaflet-control-layers-scrollbar");
          }
          this._checkDisabledLayers();
          return this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          removeClass(this._container, "leaflet-control-layers-expanded");
          return this;
        },
        _initLayout: function() {
          var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
          container.setAttribute("aria-haspopup", true);
          disableClickPropagation(container);
          disableScrollPropagation(container);
          var section = this._section = create$1("section", className + "-list");
          if (collapsed) {
            this._map.on("click", this.collapse, this);
            on(container, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
            }, this);
          }
          var link = this._layersLink = create$1("a", className + "-toggle", container);
          link.href = "#";
          link.title = "Layers";
          link.setAttribute("role", "button");
          on(link, {
            keydown: function(e) {
              if (e.keyCode === 13) {
                this._expandSafely();
              }
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(e) {
              preventDefault(e);
              this._expandSafely();
            }
          }, this);
          if (!collapsed) {
            this.expand();
          }
          this._baseLayersList = create$1("div", className + "-base", section);
          this._separator = create$1("div", className + "-separator", section);
          this._overlaysList = create$1("div", className + "-overlays", section);
          container.appendChild(section);
        },
        _getLayer: function(id) {
          for (var i = 0; i < this._layers.length; i++) {
            if (this._layers[i] && stamp(this._layers[i].layer) === id) {
              return this._layers[i];
            }
          }
        },
        _addLayer: function(layer, name, overlay) {
          if (this._map) {
            layer.on("add remove", this._onLayerChange, this);
          }
          this._layers.push({
            layer,
            name,
            overlay
          });
          if (this.options.sortLayers) {
            this._layers.sort(bind(function(a, b) {
              return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
            }, this));
          }
          if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
          }
          this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container) {
            return this;
          }
          empty(this._baseLayersList);
          empty(this._overlaysList);
          this._layerControlInputs = [];
          var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
          for (i = 0; i < this._layers.length; i++) {
            obj = this._layers[i];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
            baseLayersCount += !obj.overlay ? 1 : 0;
          }
          if (this.options.hideSingleBase) {
            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
            this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
          }
          this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
          return this;
        },
        _onLayerChange: function(e) {
          if (!this._handlingClick) {
            this._update();
          }
          var obj = this._getLayer(stamp(e.target));
          var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
          if (type) {
            this._map.fire(type, obj);
          }
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(name, checked) {
          var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
          var radioFragment = document.createElement("div");
          radioFragment.innerHTML = radioHtml;
          return radioFragment.firstChild;
        },
        _addItem: function(obj) {
          var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
          if (obj.overlay) {
            input = document.createElement("input");
            input.type = "checkbox";
            input.className = "leaflet-control-layers-selector";
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
          }
          this._layerControlInputs.push(input);
          input.layerId = stamp(obj.layer);
          on(input, "click", this._onInputClick, this);
          var name = document.createElement("span");
          name.innerHTML = " " + obj.name;
          var holder = document.createElement("span");
          label.appendChild(holder);
          holder.appendChild(input);
          holder.appendChild(name);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          this._checkDisabledLayers();
          return label;
        },
        _onInputClick: function() {
          if (this._preventClick) {
            return;
          }
          var inputs = this._layerControlInputs, input, layer;
          var addedLayers = [], removedLayers = [];
          this._handlingClick = true;
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            if (input.checked) {
              addedLayers.push(layer);
            } else if (!input.checked) {
              removedLayers.push(layer);
            }
          }
          for (i = 0; i < removedLayers.length; i++) {
            if (this._map.hasLayer(removedLayers[i])) {
              this._map.removeLayer(removedLayers[i]);
            }
          }
          for (i = 0; i < addedLayers.length; i++) {
            if (!this._map.hasLayer(addedLayers[i])) {
              this._map.addLayer(addedLayers[i]);
            }
          }
          this._handlingClick = false;
          this._refocusOnMap();
        },
        _checkDisabledLayers: function() {
          var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
          }
        },
        _expandIfNotCollapsed: function() {
          if (this._map && !this.options.collapsed) {
            this.expand();
          }
          return this;
        },
        _expandSafely: function() {
          var section = this._section;
          this._preventClick = true;
          on(section, "click", preventDefault);
          this.expand();
          var that = this;
          setTimeout(function() {
            off(section, "click", preventDefault);
            that._preventClick = false;
          });
        }
      });
      var layers = function(baseLayers, overlays, options) {
        return new Layers(baseLayers, overlays, options);
      };
      var Zoom = Control.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(map2) {
          var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
          this._zoomInButton = this._createButton(
            options.zoomInText,
            options.zoomInTitle,
            zoomName + "-in",
            container,
            this._zoomIn
          );
          this._zoomOutButton = this._createButton(
            options.zoomOutText,
            options.zoomOutTitle,
            zoomName + "-out",
            container,
            this._zoomOut
          );
          this._updateDisabled();
          map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
          return container;
        },
        onRemove: function(map2) {
          map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          this._disabled = true;
          this._updateDisabled();
          return this;
        },
        enable: function() {
          this._disabled = false;
          this._updateDisabled();
          return this;
        },
        _zoomIn: function(e) {
          if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
            this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _zoomOut: function(e) {
          if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
            this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _createButton: function(html, title, className, container, fn) {
          var link = create$1("a", className, container);
          link.innerHTML = html;
          link.href = "#";
          link.title = title;
          link.setAttribute("role", "button");
          link.setAttribute("aria-label", title);
          disableClickPropagation(link);
          on(link, "click", stop);
          on(link, "click", fn, this);
          on(link, "click", this._refocusOnMap, this);
          return link;
        },
        _updateDisabled: function() {
          var map2 = this._map, className = "leaflet-disabled";
          removeClass(this._zoomInButton, className);
          removeClass(this._zoomOutButton, className);
          this._zoomInButton.setAttribute("aria-disabled", "false");
          this._zoomOutButton.setAttribute("aria-disabled", "false");
          if (this._disabled || map2._zoom === map2.getMinZoom()) {
            addClass(this._zoomOutButton, className);
            this._zoomOutButton.setAttribute("aria-disabled", "true");
          }
          if (this._disabled || map2._zoom === map2.getMaxZoom()) {
            addClass(this._zoomInButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "true");
          }
        }
      });
      Map.mergeOptions({
        zoomControl: true
      });
      Map.addInitHook(function() {
        if (this.options.zoomControl) {
          this.zoomControl = new Zoom();
          this.addControl(this.zoomControl);
        }
      });
      var zoom = function(options) {
        return new Zoom(options);
      };
      var Scale = Control.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: true,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: true
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(map2) {
          var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
          this._addScales(options, className + "-line", container);
          map2.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
          map2.whenReady(this._update, this);
          return container;
        },
        onRemove: function(map2) {
          map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options, className, container) {
          if (options.metric) {
            this._mScale = create$1("div", className, container);
          }
          if (options.imperial) {
            this._iScale = create$1("div", className, container);
          }
        },
        _update: function() {
          var map2 = this._map, y = map2.getSize().y / 2;
          var maxMeters = map2.distance(
            map2.containerPointToLatLng([0, y]),
            map2.containerPointToLatLng([this.options.maxWidth, y])
          );
          this._updateScales(maxMeters);
        },
        _updateScales: function(maxMeters) {
          if (this.options.metric && maxMeters) {
            this._updateMetric(maxMeters);
          }
          if (this.options.imperial && maxMeters) {
            this._updateImperial(maxMeters);
          }
        },
        _updateMetric: function(maxMeters) {
          var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
          this._updateScale(this._mScale, label, meters / maxMeters);
        },
        _updateImperial: function(maxMeters) {
          var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
          if (maxFeet > 5280) {
            maxMiles = maxFeet / 5280;
            miles = this._getRoundNum(maxMiles);
            this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
          } else {
            feet = this._getRoundNum(maxFeet);
            this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
          }
        },
        _updateScale: function(scale2, text, ratio) {
          scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
          scale2.innerHTML = text;
        },
        _getRoundNum: function(num) {
          var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
          d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
          return pow10 * d;
        }
      });
      var scale = function(options) {
        return new Scale(options);
      };
      var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
      var Attribution = Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
        },
        initialize: function(options) {
          setOptions(this, options);
          this._attributions = {};
        },
        onAdd: function(map2) {
          map2.attributionControl = this;
          this._container = create$1("div", "leaflet-control-attribution");
          disableClickPropagation(this._container);
          for (var i in map2._layers) {
            if (map2._layers[i].getAttribution) {
              this.addAttribution(map2._layers[i].getAttribution());
            }
          }
          this._update();
          map2.on("layeradd", this._addAttribution, this);
          return this._container;
        },
        onRemove: function(map2) {
          map2.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(ev) {
          if (ev.layer.getAttribution) {
            this.addAttribution(ev.layer.getAttribution());
            ev.layer.once("remove", function() {
              this.removeAttribution(ev.layer.getAttribution());
            }, this);
          }
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(prefix) {
          this.options.prefix = prefix;
          this._update();
          return this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (!this._attributions[text]) {
            this._attributions[text] = 0;
          }
          this._attributions[text]++;
          this._update();
          return this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (this._attributions[text]) {
            this._attributions[text]--;
            this._update();
          }
          return this;
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          var attribs = [];
          for (var i in this._attributions) {
            if (this._attributions[i]) {
              attribs.push(i);
            }
          }
          var prefixAndAttribs = [];
          if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
          }
          if (attribs.length) {
            prefixAndAttribs.push(attribs.join(", "));
          }
          this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
        }
      });
      Map.mergeOptions({
        attributionControl: true
      });
      Map.addInitHook(function() {
        if (this.options.attributionControl) {
          new Attribution().addTo(this);
        }
      });
      var attribution = function(options) {
        return new Attribution(options);
      };
      Control.Layers = Layers;
      Control.Zoom = Zoom;
      Control.Scale = Scale;
      Control.Attribution = Attribution;
      control.layers = layers;
      control.zoom = zoom;
      control.scale = scale;
      control.attribution = attribution;
      var Handler = Class.extend({
        initialize: function(map2) {
          this._map = map2;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          if (this._enabled) {
            return this;
          }
          this._enabled = true;
          this.addHooks();
          return this;
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          if (!this._enabled) {
            return this;
          }
          this._enabled = false;
          this.removeHooks();
          return this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      Handler.addTo = function(map2, name) {
        map2.addHandler(name, this);
        return this;
      };
      var Mixin = { Events };
      var START = Browser.touch ? "touchstart mousedown" : "mousedown";
      var Draggable = Evented.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(element, dragStartTarget, preventOutline2, options) {
          setOptions(this, options);
          this._element = element;
          this._dragStartTarget = dragStartTarget || element;
          this._preventOutline = preventOutline2;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          if (this._enabled) {
            return;
          }
          on(this._dragStartTarget, START, this._onDown, this);
          this._enabled = true;
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          if (!this._enabled) {
            return;
          }
          if (Draggable._dragging === this) {
            this.finishDrag(true);
          }
          off(this._dragStartTarget, START, this._onDown, this);
          this._enabled = false;
          this._moved = false;
        },
        _onDown: function(e) {
          if (!this._enabled) {
            return;
          }
          this._moved = false;
          if (hasClass(this._element, "leaflet-zoom-anim")) {
            return;
          }
          if (e.touches && e.touches.length !== 1) {
            if (Draggable._dragging === this) {
              this.finishDrag();
            }
            return;
          }
          if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
            return;
          }
          Draggable._dragging = this;
          if (this._preventOutline) {
            preventOutline(this._element);
          }
          disableImageDrag();
          disableTextSelection();
          if (this._moving) {
            return;
          }
          this.fire("down");
          var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
          this._startPoint = new Point(first.clientX, first.clientY);
          this._startPos = getPosition(this._element);
          this._parentScale = getScale(sizedParent);
          var mouseevent = e.type === "mousedown";
          on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
          on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
        },
        _onMove: function(e) {
          if (!this._enabled) {
            return;
          }
          if (e.touches && e.touches.length > 1) {
            this._moved = true;
            return;
          }
          var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
          if (!offset.x && !offset.y) {
            return;
          }
          if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
            return;
          }
          offset.x /= this._parentScale.x;
          offset.y /= this._parentScale.y;
          preventDefault(e);
          if (!this._moved) {
            this.fire("dragstart");
            this._moved = true;
            addClass(document.body, "leaflet-dragging");
            this._lastTarget = e.target || e.srcElement;
            if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
              this._lastTarget = this._lastTarget.correspondingUseElement;
            }
            addClass(this._lastTarget, "leaflet-drag-target");
          }
          this._newPos = this._startPos.add(offset);
          this._moving = true;
          this._lastEvent = e;
          this._updatePosition();
        },
        _updatePosition: function() {
          var e = { originalEvent: this._lastEvent };
          this.fire("predrag", e);
          setPosition(this._element, this._newPos);
          this.fire("drag", e);
        },
        _onUp: function() {
          if (!this._enabled) {
            return;
          }
          this.finishDrag();
        },
        finishDrag: function(noInertia) {
          removeClass(document.body, "leaflet-dragging");
          if (this._lastTarget) {
            removeClass(this._lastTarget, "leaflet-drag-target");
            this._lastTarget = null;
          }
          off(document, "mousemove touchmove", this._onMove, this);
          off(document, "mouseup touchend touchcancel", this._onUp, this);
          enableImageDrag();
          enableTextSelection();
          var fireDragend = this._moved && this._moving;
          this._moving = false;
          Draggable._dragging = false;
          if (fireDragend) {
            this.fire("dragend", {
              noInertia,
              distance: this._newPos.distanceTo(this._startPos)
            });
          }
        }
      });
      function clipPolygon(points, bounds, round) {
        var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
        for (i = 0, len = points.length; i < len; i++) {
          points[i]._code = _getBitCode(points[i], bounds);
        }
        for (k = 0; k < 4; k++) {
          edge2 = edges[k];
          clippedPoints = [];
          for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
            a = points[i];
            b = points[j];
            if (!(a._code & edge2)) {
              if (b._code & edge2) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
              clippedPoints.push(a);
            } else if (!(b._code & edge2)) {
              p = _getEdgeIntersection(b, a, edge2, bounds, round);
              p._code = _getBitCode(p, bounds);
              clippedPoints.push(p);
            }
          }
          points = clippedPoints;
        }
        return points;
      }
      function polygonCenter(latlngs, crs) {
        var i, j, p1, p2, f, area, x, y, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        area = x = y = 0;
        for (i = 0, j = len - 1; i < len; j = i++) {
          p1 = points[i];
          p2 = points[j];
          f = p1.y * p2.x - p2.y * p1.x;
          x += (p1.x + p2.x) * f;
          y += (p1.y + p2.y) * f;
          area += f * 3;
        }
        if (area === 0) {
          center = points[0];
        } else {
          center = [x / area, y / area];
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      function centroid(coords) {
        var latSum = 0;
        var lngSum = 0;
        var len = 0;
        for (var i = 0; i < coords.length; i++) {
          var latlng = toLatLng(coords[i]);
          latSum += latlng.lat;
          lngSum += latlng.lng;
          len++;
        }
        return toLatLng([latSum / len, lngSum / len]);
      }
      var PolyUtil = {
        __proto__: null,
        clipPolygon,
        polygonCenter,
        centroid
      };
      function simplify(points, tolerance) {
        if (!tolerance || !points.length) {
          return points.slice();
        }
        var sqTolerance = tolerance * tolerance;
        points = _reducePoints(points, sqTolerance);
        points = _simplifyDP(points, sqTolerance);
        return points;
      }
      function pointToSegmentDistance(p, p1, p2) {
        return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
      }
      function closestPointOnSegment(p, p1, p2) {
        return _sqClosestPointOnSegment(p, p1, p2);
      }
      function _simplifyDP(points, sqTolerance) {
        var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
        markers[0] = markers[len - 1] = 1;
        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
        var i, newPoints = [];
        for (i = 0; i < len; i++) {
          if (markers[i]) {
            newPoints.push(points[i]);
          }
        }
        return newPoints;
      }
      function _simplifyDPStep(points, markers, sqTolerance, first, last) {
        var maxSqDist = 0, index2, i, sqDist;
        for (i = first + 1; i <= last - 1; i++) {
          sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
          if (sqDist > maxSqDist) {
            index2 = i;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          markers[index2] = 1;
          _simplifyDPStep(points, markers, sqTolerance, first, index2);
          _simplifyDPStep(points, markers, sqTolerance, index2, last);
        }
      }
      function _reducePoints(points, sqTolerance) {
        var reducedPoints = [points[0]];
        for (var i = 1, prev = 0, len = points.length; i < len; i++) {
          if (_sqDist(points[i], points[prev]) > sqTolerance) {
            reducedPoints.push(points[i]);
            prev = i;
          }
        }
        if (prev < len - 1) {
          reducedPoints.push(points[len - 1]);
        }
        return reducedPoints;
      }
      var _lastCode;
      function clipSegment(a, b, bounds, useLastCode, round) {
        var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
        _lastCode = codeB;
        while (true) {
          if (!(codeA | codeB)) {
            return [a, b];
          }
          if (codeA & codeB) {
            return false;
          }
          codeOut = codeA || codeB;
          p = _getEdgeIntersection(a, b, codeOut, bounds, round);
          newCode = _getBitCode(p, bounds);
          if (codeOut === codeA) {
            a = p;
            codeA = newCode;
          } else {
            b = p;
            codeB = newCode;
          }
        }
      }
      function _getEdgeIntersection(a, b, code, bounds, round) {
        var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
        if (code & 8) {
          x = a.x + dx * (max.y - a.y) / dy;
          y = max.y;
        } else if (code & 4) {
          x = a.x + dx * (min.y - a.y) / dy;
          y = min.y;
        } else if (code & 2) {
          x = max.x;
          y = a.y + dy * (max.x - a.x) / dx;
        } else if (code & 1) {
          x = min.x;
          y = a.y + dy * (min.x - a.x) / dx;
        }
        return new Point(x, y, round);
      }
      function _getBitCode(p, bounds) {
        var code = 0;
        if (p.x < bounds.min.x) {
          code |= 1;
        } else if (p.x > bounds.max.x) {
          code |= 2;
        }
        if (p.y < bounds.min.y) {
          code |= 4;
        } else if (p.y > bounds.max.y) {
          code |= 8;
        }
        return code;
      }
      function _sqDist(p1, p2) {
        var dx = p2.x - p1.x, dy = p2.y - p1.y;
        return dx * dx + dy * dy;
      }
      function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
        if (dot > 0) {
          t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
          if (t > 1) {
            x = p2.x;
            y = p2.y;
          } else if (t > 0) {
            x += dx * t;
            y += dy * t;
          }
        }
        dx = p.x - x;
        dy = p.y - y;
        return sqDist ? dx * dx + dy * dy : new Point(x, y);
      }
      function isFlat(latlngs) {
        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
      }
      function _flat(latlngs) {
        console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
        return isFlat(latlngs);
      }
      function polylineCenter(latlngs, crs) {
        var i, halfDist, segDist, dist, p1, p2, ratio, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        for (i = 0, halfDist = 0; i < len - 1; i++) {
          halfDist += points[i].distanceTo(points[i + 1]) / 2;
        }
        if (halfDist === 0) {
          center = points[0];
        } else {
          for (i = 0, dist = 0; i < len - 1; i++) {
            p1 = points[i];
            p2 = points[i + 1];
            segDist = p1.distanceTo(p2);
            dist += segDist;
            if (dist > halfDist) {
              ratio = (dist - halfDist) / segDist;
              center = [
                p2.x - ratio * (p2.x - p1.x),
                p2.y - ratio * (p2.y - p1.y)
              ];
              break;
            }
          }
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      var LineUtil = {
        __proto__: null,
        simplify,
        pointToSegmentDistance,
        closestPointOnSegment,
        clipSegment,
        _getEdgeIntersection,
        _getBitCode,
        _sqClosestPointOnSegment,
        isFlat,
        _flat,
        polylineCenter
      };
      var LonLat = {
        project: function(latlng) {
          return new Point(latlng.lng, latlng.lat);
        },
        unproject: function(point) {
          return new LatLng2(point.y, point.x);
        },
        bounds: new Bounds([-180, -90], [180, 90])
      };
      var Mercator = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(latlng) {
          var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
          var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
          y = -r * Math.log(Math.max(ts, 1e-10));
          return new Point(latlng.lng * d * r, y);
        },
        unproject: function(point) {
          var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
          for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
            con = e * Math.sin(phi);
            con = Math.pow((1 - con) / (1 + con), e / 2);
            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
            phi += dphi;
          }
          return new LatLng2(phi * d, point.x * d / r);
        }
      };
      var index = {
        __proto__: null,
        LonLat,
        Mercator,
        SphericalMercator
      };
      var EPSG3395 = extend({}, Earth, {
        code: "EPSG:3395",
        projection: Mercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * Mercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG4326 = extend({}, Earth, {
        code: "EPSG:4326",
        projection: LonLat,
        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
      });
      var Simple = extend({}, CRS, {
        projection: LonLat,
        transformation: toTransformation(1, 0, -1, 0),
        scale: function(zoom2) {
          return Math.pow(2, zoom2);
        },
        zoom: function(scale2) {
          return Math.log(scale2) / Math.LN2;
        },
        distance: function(latlng1, latlng2) {
          var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
          return Math.sqrt(dx * dx + dy * dy);
        },
        infinite: true
      });
      CRS.Earth = Earth;
      CRS.EPSG3395 = EPSG3395;
      CRS.EPSG3857 = EPSG3857;
      CRS.EPSG900913 = EPSG900913;
      CRS.EPSG4326 = EPSG4326;
      CRS.Simple = Simple;
      var Layer = Evented.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: true
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(map2) {
          map2.addLayer(this);
          return this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(obj) {
          if (obj) {
            obj.removeLayer(this);
          }
          return this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(name) {
          return this._map.getPane(name ? this.options[name] || name : this.options.pane);
        },
        addInteractiveTarget: function(targetEl) {
          this._map._targets[stamp(targetEl)] = this;
          return this;
        },
        removeInteractiveTarget: function(targetEl) {
          delete this._map._targets[stamp(targetEl)];
          return this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(e) {
          var map2 = e.target;
          if (!map2.hasLayer(this)) {
            return;
          }
          this._map = map2;
          this._zoomAnimated = map2._zoomAnimated;
          if (this.getEvents) {
            var events = this.getEvents();
            map2.on(events, this);
            this.once("remove", function() {
              map2.off(events, this);
            }, this);
          }
          this.onAdd(map2);
          this.fire("add");
          map2.fire("layeradd", { layer: this });
        }
      });
      Map.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(layer) {
          if (!layer._layerAdd) {
            throw new Error("The provided object is not a Layer.");
          }
          var id = stamp(layer);
          if (this._layers[id]) {
            return this;
          }
          this._layers[id] = layer;
          layer._mapToAdd = this;
          if (layer.beforeAdd) {
            layer.beforeAdd(this);
          }
          this.whenReady(layer._layerAdd, layer);
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(layer) {
          var id = stamp(layer);
          if (!this._layers[id]) {
            return this;
          }
          if (this._loaded) {
            layer.onRemove(this);
          }
          delete this._layers[id];
          if (this._loaded) {
            this.fire("layerremove", { layer });
            layer.fire("remove");
          }
          layer._map = layer._mapToAdd = null;
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(layer) {
          return stamp(layer) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        _addLayers: function(layers2) {
          layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
          for (var i = 0, len = layers2.length; i < len; i++) {
            this.addLayer(layers2[i]);
          }
        },
        _addZoomLimit: function(layer) {
          if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
            this._zoomBoundLayers[stamp(layer)] = layer;
            this._updateZoomLevels();
          }
        },
        _removeZoomLimit: function(layer) {
          var id = stamp(layer);
          if (this._zoomBoundLayers[id]) {
            delete this._zoomBoundLayers[id];
            this._updateZoomLevels();
          }
        },
        _updateZoomLevels: function() {
          var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
          for (var i in this._zoomBoundLayers) {
            var options = this._zoomBoundLayers[i].options;
            minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
            maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
          }
          this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
          this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
          if (oldZoomSpan !== this._getZoomSpan()) {
            this.fire("zoomlevelschange");
          }
          if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
            this.setZoom(this._layersMaxZoom);
          }
          if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
            this.setZoom(this._layersMinZoom);
          }
        }
      });
      var LayerGroup = Layer.extend({
        initialize: function(layers2, options) {
          setOptions(this, options);
          this._layers = {};
          var i, len;
          if (layers2) {
            for (i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          }
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(layer) {
          var id = this.getLayerId(layer);
          this._layers[id] = layer;
          if (this._map) {
            this._map.addLayer(layer);
          }
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(layer) {
          var id = layer in this._layers ? layer : this.getLayerId(layer);
          if (this._map && this._layers[id]) {
            this._map.removeLayer(this._layers[id]);
          }
          delete this._layers[id];
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(layer) {
          var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
          return layerId in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, …): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(methodName) {
          var args = Array.prototype.slice.call(arguments, 1), i, layer;
          for (i in this._layers) {
            layer = this._layers[i];
            if (layer[methodName]) {
              layer[methodName].apply(layer, args);
            }
          }
          return this;
        },
        onAdd: function(map2) {
          this.eachLayer(map2.addLayer, map2);
        },
        onRemove: function(map2) {
          this.eachLayer(map2.removeLayer, map2);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(id) {
          return this._layers[id];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var layers2 = [];
          this.eachLayer(layers2.push, layers2);
          return layers2;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(zIndex) {
          return this.invoke("setZIndex", zIndex);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(layer) {
          return stamp(layer);
        }
      });
      var layerGroup = function(layers2, options) {
        return new LayerGroup(layers2, options);
      };
      var FeatureGroup = LayerGroup.extend({
        addLayer: function(layer) {
          if (this.hasLayer(layer)) {
            return this;
          }
          layer.addEventParent(this);
          LayerGroup.prototype.addLayer.call(this, layer);
          return this.fire("layeradd", { layer });
        },
        removeLayer: function(layer) {
          if (!this.hasLayer(layer)) {
            return this;
          }
          if (layer in this._layers) {
            layer = this._layers[layer];
          }
          layer.removeEventParent(this);
          LayerGroup.prototype.removeLayer.call(this, layer);
          return this.fire("layerremove", { layer });
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(style2) {
          return this.invoke("setStyle", style2);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var bounds = new LatLngBounds();
          for (var id in this._layers) {
            var layer = this._layers[id];
            bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
          }
          return bounds;
        }
      });
      var featureGroup = function(layers2, options) {
        return new FeatureGroup(layers2, options);
      };
      var Icon = Class.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(oldIcon) {
          return this._createIcon("icon", oldIcon);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(oldIcon) {
          return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name, oldIcon) {
          var src = this._getIconUrl(name);
          if (!src) {
            if (name === "icon") {
              throw new Error("iconUrl not set in Icon options (see the docs).");
            }
            return null;
          }
          var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
          this._setIconStyles(img, name);
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          return img;
        },
        _setIconStyles: function(img, name) {
          var options = this.options;
          var sizeOption = options[name + "Size"];
          if (typeof sizeOption === "number") {
            sizeOption = [sizeOption, sizeOption];
          }
          var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
          img.className = "leaflet-marker-" + name + " " + (options.className || "");
          if (anchor) {
            img.style.marginLeft = -anchor.x + "px";
            img.style.marginTop = -anchor.y + "px";
          }
          if (size) {
            img.style.width = size.x + "px";
            img.style.height = size.y + "px";
          }
        },
        _createImg: function(src, el) {
          el = el || document.createElement("img");
          el.src = src;
          return el;
        },
        _getIconUrl: function(name) {
          return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
        }
      });
      function icon(options) {
        return new Icon(options);
      }
      var IconDefault = Icon.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(name) {
          if (typeof IconDefault.imagePath !== "string") {
            IconDefault.imagePath = this._detectIconPath();
          }
          return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },
        _stripUrl: function(path) {
          var strip = function(str, re, idx) {
            var match = re.exec(str);
            return match && match[idx];
          };
          path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
          return path && strip(path, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var el = create$1("div", "leaflet-default-icon-path", document.body);
          var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
          document.body.removeChild(el);
          path = this._stripUrl(path);
          if (path) {
            return path;
          }
          var link = document.querySelector('link[href$="leaflet.css"]');
          if (!link) {
            return "";
          }
          return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
        }
      });
      var MarkerDrag = Handler.extend({
        initialize: function(marker3) {
          this._marker = marker3;
        },
        addHooks: function() {
          var icon2 = this._marker._icon;
          if (!this._draggable) {
            this._draggable = new Draggable(icon2, icon2, true);
          }
          this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable();
          addClass(icon2, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable();
          if (this._marker._icon) {
            removeClass(this._marker._icon, "leaflet-marker-draggable");
          }
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(e) {
          var marker3 = this._marker, map2 = marker3._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker3._icon), bounds = map2.getPixelBounds(), origin = map2.getPixelOrigin();
          var panBounds = toBounds(
            bounds.min._subtract(origin).add(padding),
            bounds.max._subtract(origin).subtract(padding)
          );
          if (!panBounds.contains(iconPos)) {
            var movement = toPoint(
              (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
              (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
            ).multiplyBy(speed);
            map2.panBy(movement, { animate: false });
            this._draggable._newPos._add(movement);
            this._draggable._startPos._add(movement);
            setPosition(marker3._icon, this._draggable._newPos);
            this._onDrag(e);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng();
          this._marker.closePopup && this._marker.closePopup();
          this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(e) {
          if (this._marker.options.autoPan) {
            cancelAnimFrame(this._panRequest);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDrag: function(e) {
          var marker3 = this._marker, shadow = marker3._shadow, iconPos = getPosition(marker3._icon), latlng = marker3._map.layerPointToLatLng(iconPos);
          if (shadow) {
            setPosition(shadow, iconPos);
          }
          marker3._latlng = latlng;
          e.latlng = latlng;
          e.oldLatLng = this._oldLatLng;
          marker3.fire("move", e).fire("drag", e);
        },
        _onDragEnd: function(e) {
          cancelAnimFrame(this._panRequest);
          delete this._oldLatLng;
          this._marker.fire("moveend").fire("dragend", e);
        }
      });
      var Marker = Layer.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new IconDefault(),
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: true,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: false,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: false,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: true,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: false,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: false,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
        },
        onAdd: function(map2) {
          this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
          if (this._zoomAnimated) {
            map2.on("zoomanim", this._animateZoom, this);
          }
          this._initIcon();
          this.update();
        },
        onRemove: function(map2) {
          if (this.dragging && this.dragging.enabled()) {
            this.options.draggable = true;
            this.dragging.removeHooks();
          }
          delete this.dragging;
          if (this._zoomAnimated) {
            map2.off("zoomanim", this._animateZoom, this);
          }
          this._removeIcon();
          this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.update();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(offset) {
          this.options.zIndexOffset = offset;
          return this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(icon2) {
          this.options.icon = icon2;
          if (this._map) {
            this._initIcon();
            this.update();
          }
          if (this._popup) {
            this.bindPopup(this._popup, this._popup.options);
          }
          return this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var pos = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(pos);
          }
          return this;
        },
        _initIcon: function() {
          var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          var icon2 = options.icon.createIcon(this._icon), addIcon = false;
          if (icon2 !== this._icon) {
            if (this._icon) {
              this._removeIcon();
            }
            addIcon = true;
            if (options.title) {
              icon2.title = options.title;
            }
            if (icon2.tagName === "IMG") {
              icon2.alt = options.alt || "";
            }
          }
          addClass(icon2, classToAdd);
          if (options.keyboard) {
            icon2.tabIndex = "0";
            icon2.setAttribute("role", "button");
          }
          this._icon = icon2;
          if (options.riseOnHover) {
            this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            on(icon2, "focus", this._panOnFocus, this);
          }
          var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
          if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
          }
          if (newShadow) {
            addClass(newShadow, classToAdd);
            newShadow.alt = "";
          }
          this._shadow = newShadow;
          if (options.opacity < 1) {
            this._updateOpacity();
          }
          if (addIcon) {
            this.getPane().appendChild(this._icon);
          }
          this._initInteraction();
          if (newShadow && addShadow) {
            this.getPane(options.shadowPane).appendChild(this._shadow);
          }
        },
        _removeIcon: function() {
          if (this.options.riseOnHover) {
            this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            off(this._icon, "focus", this._panOnFocus, this);
          }
          remove(this._icon);
          this.removeInteractiveTarget(this._icon);
          this._icon = null;
        },
        _removeShadow: function() {
          if (this._shadow) {
            remove(this._shadow);
          }
          this._shadow = null;
        },
        _setPos: function(pos) {
          if (this._icon) {
            setPosition(this._icon, pos);
          }
          if (this._shadow) {
            setPosition(this._shadow, pos);
          }
          this._zIndex = pos.y + this.options.zIndexOffset;
          this._resetZIndex();
        },
        _updateZIndex: function(offset) {
          if (this._icon) {
            this._icon.style.zIndex = this._zIndex + offset;
          }
        },
        _animateZoom: function(opt) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
          this._setPos(pos);
        },
        _initInteraction: function() {
          if (!this.options.interactive) {
            return;
          }
          addClass(this._icon, "leaflet-interactive");
          this.addInteractiveTarget(this._icon);
          if (MarkerDrag) {
            var draggable = this.options.draggable;
            if (this.dragging) {
              draggable = this.dragging.enabled();
              this.dragging.disable();
            }
            this.dragging = new MarkerDrag(this);
            if (draggable) {
              this.dragging.enable();
            }
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._map) {
            this._updateOpacity();
          }
          return this;
        },
        _updateOpacity: function() {
          var opacity = this.options.opacity;
          if (this._icon) {
            setOpacity(this._icon, opacity);
          }
          if (this._shadow) {
            setOpacity(this._shadow, opacity);
          }
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var map2 = this._map;
          if (!map2) {
            return;
          }
          var iconOpts = this.options.icon.options;
          var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
          var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
          map2.panInside(this._latlng, {
            paddingTopLeft: anchor,
            paddingBottomRight: size.subtract(anchor)
          });
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function marker2(latlng, options) {
        return new Marker(latlng, options);
      }
      var Path = Layer.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: true,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: false,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: true
        },
        beforeAdd: function(map2) {
          this._renderer = map2.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this);
          this._reset();
          this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          if (this._map) {
            this._renderer._updatePath(this);
          }
          return this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(style2) {
          setOptions(this, style2);
          if (this._renderer) {
            this._renderer._updateStyle(this);
            if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
              this._updateBounds();
            }
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          if (this._renderer) {
            this._renderer._bringToFront(this);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          if (this._renderer) {
            this._renderer._bringToBack(this);
          }
          return this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project();
          this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      });
      var CircleMarker = Path.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: true,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.redraw();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(radius) {
          this.options.radius = this._radius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(options) {
          var radius = options && options.radius || this._radius;
          Path.prototype.setStyle.call(this, options);
          this.setRadius(radius);
          return this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng);
          this._updateBounds();
        },
        _updateBounds: function() {
          var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
          this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
        },
        _update: function() {
          if (this._map) {
            this._updatePath();
          }
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function circleMarker(latlng, options) {
        return new CircleMarker(latlng, options);
      }
      var Circle = CircleMarker.extend({
        initialize: function(latlng, options, legacyOptions) {
          if (typeof options === "number") {
            options = extend({}, legacyOptions, { radius: options });
          }
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          if (isNaN(this.options.radius)) {
            throw new Error("Circle radius cannot be NaN");
          }
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(radius) {
          this._mRadius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var half = [this._radius, this._radiusY || this._radius];
          return new LatLngBounds(
            this._map.layerPointToLatLng(this._point.subtract(half)),
            this._map.layerPointToLatLng(this._point.add(half))
          );
        },
        setStyle: Path.prototype.setStyle,
        _project: function() {
          var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
          if (crs.distance === Earth.distance) {
            var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map2.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
            if (isNaN(lngR) || lngR === 0) {
              lngR = latR / Math.cos(Math.PI / 180 * lat);
            }
            this._point = p.subtract(map2.getPixelOrigin());
            this._radius = isNaN(lngR) ? 0 : p.x - map2.project([lat2, lng - lngR]).x;
            this._radiusY = p.y - top.y;
          } else {
            var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = map2.latLngToLayerPoint(this._latlng);
            this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
          }
          this._updateBounds();
        }
      });
      function circle(latlng, options, legacyOptions) {
        return new Circle(latlng, options, legacyOptions);
      }
      var Polyline = Path.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: false
        },
        initialize: function(latlngs, options) {
          setOptions(this, options);
          this._setLatLngs(latlngs);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(latlngs) {
          this._setLatLngs(latlngs);
          return this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(p) {
          var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
          for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
            var points = this._parts[j];
            for (var i = 1, len = points.length; i < len; i++) {
              p1 = points[i - 1];
              p2 = points[i];
              var sqDist = closest(p, p1, p2, true);
              if (sqDist < minDistance) {
                minDistance = sqDist;
                minPoint = closest(p, p1, p2);
              }
            }
          }
          if (minPoint) {
            minPoint.distance = Math.sqrt(minDistance);
          }
          return minPoint;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polylineCenter(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(latlng, latlngs) {
          latlngs = latlngs || this._defaultShape();
          latlng = toLatLng(latlng);
          latlngs.push(latlng);
          this._bounds.extend(latlng);
          return this.redraw();
        },
        _setLatLngs: function(latlngs) {
          this._bounds = new LatLngBounds();
          this._latlngs = this._convertLatLngs(latlngs);
        },
        _defaultShape: function() {
          return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(latlngs) {
          var result = [], flat = isFlat(latlngs);
          for (var i = 0, len = latlngs.length; i < len; i++) {
            if (flat) {
              result[i] = toLatLng(latlngs[i]);
              this._bounds.extend(result[i]);
            } else {
              result[i] = this._convertLatLngs(latlngs[i]);
            }
          }
          return result;
        },
        _project: function() {
          var pxBounds = new Bounds();
          this._rings = [];
          this._projectLatlngs(this._latlngs, this._rings, pxBounds);
          if (this._bounds.isValid() && pxBounds.isValid()) {
            this._rawPxBounds = pxBounds;
            this._updateBounds();
          }
        },
        _updateBounds: function() {
          var w = this._clickTolerance(), p = new Point(w, w);
          if (!this._rawPxBounds) {
            return;
          }
          this._pxBounds = new Bounds([
            this._rawPxBounds.min.subtract(p),
            this._rawPxBounds.max.add(p)
          ]);
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(latlngs, result, projectedBounds) {
          var flat = latlngs[0] instanceof LatLng2, len = latlngs.length, i, ring;
          if (flat) {
            ring = [];
            for (i = 0; i < len; i++) {
              ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
              projectedBounds.extend(ring[i]);
            }
            result.push(ring);
          } else {
            for (i = 0; i < len; i++) {
              this._projectLatlngs(latlngs[i], result, projectedBounds);
            }
          }
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var bounds = this._renderer._bounds;
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var parts = this._parts, i, j, k, len, len2, segment, points;
          for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
            points = this._rings[i];
            for (j = 0, len2 = points.length; j < len2 - 1; j++) {
              segment = clipSegment(points[j], points[j + 1], bounds, j, true);
              if (!segment) {
                continue;
              }
              parts[k] = parts[k] || [];
              parts[k].push(segment[0]);
              if (segment[1] !== points[j + 1] || j === len2 - 2) {
                parts[k].push(segment[1]);
                k++;
              }
            }
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          var parts = this._parts, tolerance = this.options.smoothFactor;
          for (var i = 0, len = parts.length; i < len; i++) {
            parts[i] = simplify(parts[i], tolerance);
          }
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          this._clipPoints();
          this._simplifyPoints();
          this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p, closed) {
          var i, j, k, len, len2, part, w = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              if (!closed && j === 0) {
                continue;
              }
              if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                return true;
              }
            }
          }
          return false;
        }
      });
      function polyline(latlngs, options) {
        return new Polyline(latlngs, options);
      }
      Polyline._flat = _flat;
      var Polygon = Polyline.extend({
        options: {
          fill: true
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polygonCenter(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(latlngs) {
          var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
          if (len >= 2 && result[0] instanceof LatLng2 && result[0].equals(result[len - 1])) {
            result.pop();
          }
          return result;
        },
        _setLatLngs: function(latlngs) {
          Polyline.prototype._setLatLngs.call(this, latlngs);
          if (isFlat(this._latlngs)) {
            this._latlngs = [this._latlngs];
          }
        },
        _defaultShape: function() {
          return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
          bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
            clipped = clipPolygon(this._rings[i], bounds, true);
            if (clipped.length) {
              this._parts.push(clipped);
            }
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, true);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          var inside = false, part, p1, p2, i, j, k, len, len2;
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              p1 = part[j];
              p2 = part[k];
              if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                inside = !inside;
              }
            }
          }
          return inside || Polyline.prototype._containsPoint.call(this, p, true);
        }
      });
      function polygon(latlngs, options) {
        return new Polygon(latlngs, options);
      }
      var GeoJSON = FeatureGroup.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(geojson, options) {
          setOptions(this, options);
          this._layers = {};
          if (geojson) {
            this.addData(geojson);
          }
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(geojson) {
          var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;
          if (features) {
            for (i = 0, len = features.length; i < len; i++) {
              feature = features[i];
              if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                this.addData(feature);
              }
            }
            return this;
          }
          var options = this.options;
          if (options.filter && !options.filter(geojson)) {
            return this;
          }
          var layer = geometryToLayer(geojson, options);
          if (!layer) {
            return this;
          }
          layer.feature = asFeature(geojson);
          layer.defaultOptions = layer.options;
          this.resetStyle(layer);
          if (options.onEachFeature) {
            options.onEachFeature(geojson, layer);
          }
          return this.addLayer(layer);
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(layer) {
          if (layer === void 0) {
            return this.eachLayer(this.resetStyle, this);
          }
          layer.options = extend({}, layer.defaultOptions);
          this._setLayerStyle(layer, this.options.style);
          return this;
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(style2) {
          return this.eachLayer(function(layer) {
            this._setLayerStyle(layer, style2);
          }, this);
        },
        _setLayerStyle: function(layer, style2) {
          if (layer.setStyle) {
            if (typeof style2 === "function") {
              style2 = style2(layer.feature);
            }
            layer.setStyle(style2);
          }
        }
      });
      function geometryToLayer(geojson, options) {
        var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
        if (!coords && !geometry) {
          return null;
        }
        switch (geometry.type) {
          case "Point":
            latlng = _coordsToLatLng(coords);
            return _pointToLayer(pointToLayer, geojson, latlng, options);
          case "MultiPoint":
            for (i = 0, len = coords.length; i < len; i++) {
              latlng = _coordsToLatLng(coords[i]);
              layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
            }
            return new FeatureGroup(layers2);
          case "LineString":
          case "MultiLineString":
            latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
            return new Polyline(latlngs, options);
          case "Polygon":
          case "MultiPolygon":
            latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
            return new Polygon(latlngs, options);
          case "GeometryCollection":
            for (i = 0, len = geometry.geometries.length; i < len; i++) {
              var geoLayer = geometryToLayer({
                geometry: geometry.geometries[i],
                type: "Feature",
                properties: geojson.properties
              }, options);
              if (geoLayer) {
                layers2.push(geoLayer);
              }
            }
            return new FeatureGroup(layers2);
          case "FeatureCollection":
            for (i = 0, len = geometry.features.length; i < len; i++) {
              var featureLayer = geometryToLayer(geometry.features[i], options);
              if (featureLayer) {
                layers2.push(featureLayer);
              }
            }
            return new FeatureGroup(layers2);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
      }
      function coordsToLatLng(coords) {
        return new LatLng2(coords[1], coords[0], coords[2]);
      }
      function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
        var latlngs = [];
        for (var i = 0, len = coords.length, latlng; i < len; i++) {
          latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
          latlngs.push(latlng);
        }
        return latlngs;
      }
      function latLngToCoords(latlng, precision) {
        latlng = toLatLng(latlng);
        return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
      }
      function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
        var coords = [];
        for (var i = 0, len = latlngs.length; i < len; i++) {
          coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
        }
        if (!levelsDeep && closed && coords.length > 0) {
          coords.push(coords[0].slice());
        }
        return coords;
      }
      function getFeature(layer, newGeometry) {
        return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
      }
      function asFeature(geojson) {
        if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
          return geojson;
        }
        return {
          type: "Feature",
          properties: {},
          geometry: geojson
        };
      }
      var PointToGeoJSON = {
        toGeoJSON: function(precision) {
          return getFeature(this, {
            type: "Point",
            coordinates: latLngToCoords(this.getLatLng(), precision)
          });
        }
      };
      Marker.include(PointToGeoJSON);
      Circle.include(PointToGeoJSON);
      CircleMarker.include(PointToGeoJSON);
      Polyline.include({
        toGeoJSON: function(precision) {
          var multi = !isFlat(this._latlngs);
          var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "LineString",
            coordinates: coords
          });
        }
      });
      Polygon.include({
        toGeoJSON: function(precision) {
          var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
          var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
          if (!holes) {
            coords = [coords];
          }
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "Polygon",
            coordinates: coords
          });
        }
      });
      LayerGroup.include({
        toMultiPoint: function(precision) {
          var coords = [];
          this.eachLayer(function(layer) {
            coords.push(layer.toGeoJSON(precision).geometry.coordinates);
          });
          return getFeature(this, {
            type: "MultiPoint",
            coordinates: coords
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(precision) {
          var type = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (type === "MultiPoint") {
            return this.toMultiPoint(precision);
          }
          var isGeometryCollection = type === "GeometryCollection", jsons = [];
          this.eachLayer(function(layer) {
            if (layer.toGeoJSON) {
              var json = layer.toGeoJSON(precision);
              if (isGeometryCollection) {
                jsons.push(json.geometry);
              } else {
                var feature = asFeature(json);
                if (feature.type === "FeatureCollection") {
                  jsons.push.apply(jsons, feature.features);
                } else {
                  jsons.push(feature);
                }
              }
            }
          });
          if (isGeometryCollection) {
            return getFeature(this, {
              geometries: jsons,
              type: "GeometryCollection"
            });
          }
          return {
            type: "FeatureCollection",
            features: jsons
          };
        }
      });
      function geoJSON(geojson, options) {
        return new GeoJSON(geojson, options);
      }
      var geoJson = geoJSON;
      var ImageOverlay = Layer.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(url, bounds, options) {
          this._url = url;
          this._bounds = toLatLngBounds(bounds);
          setOptions(this, options);
        },
        onAdd: function() {
          if (!this._image) {
            this._initImage();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
          }
          if (this.options.interactive) {
            addClass(this._image, "leaflet-interactive");
            this.addInteractiveTarget(this._image);
          }
          this.getPane().appendChild(this._image);
          this._reset();
        },
        onRemove: function() {
          remove(this._image);
          if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
          }
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._image) {
            this._updateOpacity();
          }
          return this;
        },
        setStyle: function(styleOpts) {
          if (styleOpts.opacity) {
            this.setOpacity(styleOpts.opacity);
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          if (this._map) {
            toFront(this._image);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          if (this._map) {
            toBack(this._image);
          }
          return this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(url) {
          this._url = url;
          if (this._image) {
            this._image.src = url;
          }
          return this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(bounds) {
          this._bounds = toLatLngBounds(bounds);
          if (this._map) {
            this._reset();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            zoom: this._reset,
            viewreset: this._reset
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(value) {
          this.options.zIndex = value;
          this._updateZIndex();
          return this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "IMG";
          var img = this._image = wasElementSupplied ? this._url : create$1("img");
          addClass(img, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(img, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(img, this.options.className);
          }
          img.onselectstart = falseFn;
          img.onmousemove = falseFn;
          img.onload = bind(this.fire, this, "load");
          img.onerror = bind(this._overlayOnError, this, "error");
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (this.options.zIndex) {
            this._updateZIndex();
          }
          if (wasElementSupplied) {
            this._url = img.src;
            return;
          }
          img.src = this._url;
          img.alt = this.options.alt;
        },
        _animateZoom: function(e) {
          var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
          setTransform(this._image, offset, scale2);
        },
        _reset: function() {
          var image = this._image, bounds = new Bounds(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), size = bounds.getSize();
          setPosition(image, bounds.min);
          image.style.width = size.x + "px";
          image.style.height = size.y + "px";
        },
        _updateOpacity: function() {
          setOpacity(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._image.style.zIndex = this.options.zIndex;
          }
        },
        _overlayOnError: function() {
          this.fire("error");
          var errorUrl = this.options.errorOverlayUrl;
          if (errorUrl && this._url !== errorUrl) {
            this._url = errorUrl;
            this._image.src = errorUrl;
          }
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      });
      var imageOverlay = function(url, bounds, options) {
        return new ImageOverlay(url, bounds, options);
      };
      var VideoOverlay = ImageOverlay.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: true,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: true,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: true,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: false,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: true
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "VIDEO";
          var vid = this._image = wasElementSupplied ? this._url : create$1("video");
          addClass(vid, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(vid, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(vid, this.options.className);
          }
          vid.onselectstart = falseFn;
          vid.onmousemove = falseFn;
          vid.onloadeddata = bind(this.fire, this, "load");
          if (wasElementSupplied) {
            var sourceElements = vid.getElementsByTagName("source");
            var sources = [];
            for (var j = 0; j < sourceElements.length; j++) {
              sources.push(sourceElements[j].src);
            }
            this._url = sourceElements.length > 0 ? sources : [vid.src];
            return;
          }
          if (!isArray(this._url)) {
            this._url = [this._url];
          }
          if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
            vid.style["objectFit"] = "fill";
          }
          vid.autoplay = !!this.options.autoplay;
          vid.loop = !!this.options.loop;
          vid.muted = !!this.options.muted;
          vid.playsInline = !!this.options.playsInline;
          for (var i = 0; i < this._url.length; i++) {
            var source = create$1("source");
            source.src = this._url[i];
            vid.appendChild(source);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function videoOverlay(video, bounds, options) {
        return new VideoOverlay(video, bounds, options);
      }
      var SVGOverlay = ImageOverlay.extend({
        _initImage: function() {
          var el = this._image = this._url;
          addClass(el, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(el, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(el, this.options.className);
          }
          el.onselectstart = falseFn;
          el.onmousemove = falseFn;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function svgOverlay(el, bounds, options) {
        return new SVGOverlay(el, bounds, options);
      }
      var DivOverlay = Layer.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: false,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(options, source) {
          if (options && (options instanceof LatLng2 || isArray(options))) {
            this._latlng = toLatLng(options);
            setOptions(this, source);
          } else {
            setOptions(this, options);
            this._source = source;
          }
          if (this.options.content) {
            this._content = this.options.content;
          }
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(map2) {
          map2 = arguments.length ? map2 : this._source._map;
          if (!map2.hasLayer(this)) {
            map2.addLayer(this);
          }
          return this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          if (this._map) {
            this._map.removeLayer(this);
          }
          return this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(layer) {
          if (this._map) {
            this.close();
          } else {
            if (arguments.length) {
              this._source = layer;
            } else {
              layer = this._source;
            }
            this._prepareOpen();
            this.openOn(layer._map);
          }
          return this;
        },
        onAdd: function(map2) {
          this._zoomAnimated = map2._zoomAnimated;
          if (!this._container) {
            this._initLayout();
          }
          if (map2._fadeAnimated) {
            setOpacity(this._container, 0);
          }
          clearTimeout(this._removeTimeout);
          this.getPane().appendChild(this._container);
          this.update();
          if (map2._fadeAnimated) {
            setOpacity(this._container, 1);
          }
          this.bringToFront();
          if (this.options.interactive) {
            addClass(this._container, "leaflet-interactive");
            this.addInteractiveTarget(this._container);
          }
        },
        onRemove: function(map2) {
          if (map2._fadeAnimated) {
            setOpacity(this._container, 0);
            this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
          } else {
            remove(this._container);
          }
          if (this.options.interactive) {
            removeClass(this._container, "leaflet-interactive");
            this.removeInteractiveTarget(this._container);
          }
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(latlng) {
          this._latlng = toLatLng(latlng);
          if (this._map) {
            this._updatePosition();
            this._adjustPan();
          }
          return this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(content) {
          this._content = content;
          this.update();
          return this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          if (!this._map) {
            return;
          }
          this._container.style.visibility = "hidden";
          this._updateContent();
          this._updateLayout();
          this._updatePosition();
          this._container.style.visibility = "";
          this._adjustPan();
        },
        getEvents: function() {
          var events = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
          }
          return this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(latlng) {
          var source = this._source;
          if (!source._map) {
            return false;
          }
          if (source instanceof FeatureGroup) {
            source = null;
            var layers2 = this._source._layers;
            for (var id in layers2) {
              if (layers2[id]._map) {
                source = layers2[id];
                break;
              }
            }
            if (!source) {
              return false;
            }
            this._source = source;
          }
          if (!latlng) {
            if (source.getCenter) {
              latlng = source.getCenter();
            } else if (source.getLatLng) {
              latlng = source.getLatLng();
            } else if (source.getBounds) {
              latlng = source.getBounds().getCenter();
            } else {
              throw new Error("Unable to get source layer LatLng.");
            }
          }
          this.setLatLng(latlng);
          if (this._map) {
            this.update();
          }
          return true;
        },
        _updateContent: function() {
          if (!this._content) {
            return;
          }
          var node = this._contentNode;
          var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
          if (typeof content === "string") {
            node.innerHTML = content;
          } else {
            while (node.hasChildNodes()) {
              node.removeChild(node.firstChild);
            }
            node.appendChild(content);
          }
          this.fire("contentupdate");
        },
        _updatePosition: function() {
          if (!this._map) {
            return;
          }
          var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
          if (this._zoomAnimated) {
            setPosition(this._container, pos.add(anchor));
          } else {
            offset = offset.add(pos).add(anchor);
          }
          var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
          this._container.style.bottom = bottom + "px";
          this._container.style.left = left + "px";
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Map.include({
        _initOverlay: function(OverlayClass, content, latlng, options) {
          var overlay = content;
          if (!(overlay instanceof OverlayClass)) {
            overlay = new OverlayClass(options).setContent(content);
          }
          if (latlng) {
            overlay.setLatLng(latlng);
          }
          return overlay;
        }
      });
      Layer.include({
        _initOverlay: function(OverlayClass, old, content, options) {
          var overlay = content;
          if (overlay instanceof OverlayClass) {
            setOptions(overlay, options);
            overlay._source = this;
          } else {
            overlay = old && !options ? old : new OverlayClass(options, this);
            overlay.setContent(content);
          }
          return overlay;
        }
      });
      var Popup = DivOverlay.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: true,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: false,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: true,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: true,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: true,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(map2) {
          map2 = arguments.length ? map2 : this._source._map;
          if (!map2.hasLayer(this) && map2._popup && map2._popup.options.autoClose) {
            map2.removeLayer(map2._popup);
          }
          map2._popup = this;
          return DivOverlay.prototype.openOn.call(this, map2);
        },
        onAdd: function(map2) {
          DivOverlay.prototype.onAdd.call(this, map2);
          map2.fire("popupopen", { popup: this });
          if (this._source) {
            this._source.fire("popupopen", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.on("preclick", stopPropagation);
            }
          }
        },
        onRemove: function(map2) {
          DivOverlay.prototype.onRemove.call(this, map2);
          map2.fire("popupclose", { popup: this });
          if (this._source) {
            this._source.fire("popupclose", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.off("preclick", stopPropagation);
            }
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
            events.preclick = this.close;
          }
          if (this.options.keepInView) {
            events.moveend = this._adjustPan;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-popup", container = this._container = create$1(
            "div",
            prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
          );
          var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
          this._contentNode = create$1("div", prefix + "-content", wrapper);
          disableClickPropagation(container);
          disableScrollPropagation(this._contentNode);
          on(container, "contextmenu", stopPropagation);
          this._tipContainer = create$1("div", prefix + "-tip-container", container);
          this._tip = create$1("div", prefix + "-tip", this._tipContainer);
          if (this.options.closeButton) {
            var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
            closeButton.setAttribute("role", "button");
            closeButton.setAttribute("aria-label", "Close popup");
            closeButton.href = "#close";
            closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
            on(closeButton, "click", function(ev) {
              preventDefault(ev);
              this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var container = this._contentNode, style2 = container.style;
          style2.width = "";
          style2.whiteSpace = "nowrap";
          var width = container.offsetWidth;
          width = Math.min(width, this.options.maxWidth);
          width = Math.max(width, this.options.minWidth);
          style2.width = width + 1 + "px";
          style2.whiteSpace = "";
          style2.height = "";
          var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
          if (maxHeight && height > maxHeight) {
            style2.height = maxHeight + "px";
            addClass(container, scrolledClass);
          } else {
            removeClass(container, scrolledClass);
          }
          this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
          setPosition(this._container, pos.add(anchor));
        },
        _adjustPan: function() {
          if (!this.options.autoPan) {
            return;
          }
          if (this._map._panAnim) {
            this._map._panAnim.stop();
          }
          if (this._autopanning) {
            this._autopanning = false;
            return;
          }
          var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
          layerPos._add(getPosition(this._container));
          var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map2.getSize(), dx = 0, dy = 0;
          if (containerPos.x + containerWidth + paddingBR.x > size.x) {
            dx = containerPos.x + containerWidth - size.x + paddingBR.x;
          }
          if (containerPos.x - dx - paddingTL.x < 0) {
            dx = containerPos.x - paddingTL.x;
          }
          if (containerPos.y + containerHeight + paddingBR.y > size.y) {
            dy = containerPos.y + containerHeight - size.y + paddingBR.y;
          }
          if (containerPos.y - dy - paddingTL.y < 0) {
            dy = containerPos.y - paddingTL.y;
          }
          if (dx || dy) {
            if (this.options.keepInView) {
              this._autopanning = true;
            }
            map2.fire("autopanstart").panBy([dx, dy]);
          }
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      });
      var popup = function(options, source) {
        return new Popup(options, source);
      };
      Map.mergeOptions({
        closePopupOnClick: true
      });
      Map.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(popup2, latlng, options) {
          this._initOverlay(Popup, popup2, latlng, options).openOn(this);
          return this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(popup2) {
          popup2 = arguments.length ? popup2 : this._popup;
          if (popup2) {
            popup2.close();
          }
          return this;
        }
      });
      Layer.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(content, options) {
          this._popup = this._initOverlay(Popup, this._popup, content, options);
          if (!this._popupHandlersAdded) {
            this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = true;
          }
          return this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          if (this._popup) {
            this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = false;
            this._popup = null;
          }
          return this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(latlng) {
          if (this._popup) {
            if (!(this instanceof FeatureGroup)) {
              this._popup._source = this;
            }
            if (this._popup._prepareOpen(latlng || this._latlng)) {
              this._popup.openOn(this._map);
            }
          }
          return this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          if (this._popup) {
            this._popup.close();
          }
          return this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          if (this._popup) {
            this._popup.toggle(this);
          }
          return this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : false;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(content) {
          if (this._popup) {
            this._popup.setContent(content);
          }
          return this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(e) {
          if (!this._popup || !this._map) {
            return;
          }
          stop(e);
          var target = e.layer || e.target;
          if (this._popup._source === target && !(target instanceof Path)) {
            if (this._map.hasLayer(this._popup)) {
              this.closePopup();
            } else {
              this.openPopup(e.latlng);
            }
            return;
          }
          this._popup._source = target;
          this.openPopup(e.latlng);
        },
        _movePopup: function(e) {
          this._popup.setLatLng(e.latlng);
        },
        _onKeyPress: function(e) {
          if (e.originalEvent.keyCode === 13) {
            this._openPopup(e);
          }
        }
      });
      var Tooltip = DivOverlay.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: false,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: false,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(map2) {
          DivOverlay.prototype.onAdd.call(this, map2);
          this.setOpacity(this.options.opacity);
          map2.fire("tooltipopen", { tooltip: this });
          if (this._source) {
            this.addEventParent(this._source);
            this._source.fire("tooltipopen", { tooltip: this }, true);
          }
        },
        onRemove: function(map2) {
          DivOverlay.prototype.onRemove.call(this, map2);
          map2.fire("tooltipclose", { tooltip: this });
          if (this._source) {
            this.removeEventParent(this._source);
            this._source.fire("tooltipclose", { tooltip: this }, true);
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (!this.options.permanent) {
            events.preclick = this.close;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = create$1("div", className);
          this._container.setAttribute("role", "tooltip");
          this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(pos) {
          var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
          if (direction === "top") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight;
          } else if (direction === "bottom") {
            subX = tooltipWidth / 2;
            subY = 0;
          } else if (direction === "center") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight / 2;
          } else if (direction === "right") {
            subX = 0;
            subY = tooltipHeight / 2;
          } else if (direction === "left") {
            subX = tooltipWidth;
            subY = tooltipHeight / 2;
          } else if (tooltipPoint.x < centerPoint.x) {
            direction = "right";
            subX = 0;
            subY = tooltipHeight / 2;
          } else {
            direction = "left";
            subX = tooltipWidth + (offset.x + anchor.x) * 2;
            subY = tooltipHeight / 2;
          }
          pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
          removeClass(container, "leaflet-tooltip-right");
          removeClass(container, "leaflet-tooltip-left");
          removeClass(container, "leaflet-tooltip-top");
          removeClass(container, "leaflet-tooltip-bottom");
          addClass(container, "leaflet-tooltip-" + direction);
          setPosition(container, pos);
        },
        _updatePosition: function() {
          var pos = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(pos);
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._container) {
            setOpacity(this._container, opacity);
          }
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
          this._setPosition(pos);
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      });
      var tooltip = function(options, source) {
        return new Tooltip(options, source);
      };
      Map.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(tooltip2, latlng, options) {
          this._initOverlay(Tooltip, tooltip2, latlng, options).openOn(this);
          return this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(tooltip2) {
          tooltip2.close();
          return this;
        }
      });
      Layer.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(content, options) {
          if (this._tooltip && this.isTooltipOpen()) {
            this.unbindTooltip();
          }
          this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
          this._initTooltipInteractions();
          if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
            this.openTooltip();
          }
          return this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          if (this._tooltip) {
            this._initTooltipInteractions(true);
            this.closeTooltip();
            this._tooltip = null;
          }
          return this;
        },
        _initTooltipInteractions: function(remove2) {
          if (!remove2 && this._tooltipHandlersAdded) {
            return;
          }
          var onOff = remove2 ? "off" : "on", events = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          if (!this._tooltip.options.permanent) {
            events.mouseover = this._openTooltip;
            events.mouseout = this.closeTooltip;
            events.click = this._openTooltip;
            if (this._map) {
              this._addFocusListeners();
            } else {
              events.add = this._addFocusListeners;
            }
          } else {
            events.add = this._openTooltip;
          }
          if (this._tooltip.options.sticky) {
            events.mousemove = this._moveTooltip;
          }
          this[onOff](events);
          this._tooltipHandlersAdded = !remove2;
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(latlng) {
          if (this._tooltip) {
            if (!(this instanceof FeatureGroup)) {
              this._tooltip._source = this;
            }
            if (this._tooltip._prepareOpen(latlng)) {
              this._tooltip.openOn(this._map);
              if (this.getElement) {
                this._setAriaDescribedByOnLayer(this);
              } else if (this.eachLayer) {
                this.eachLayer(this._setAriaDescribedByOnLayer, this);
              }
            }
          }
          return this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip) {
            return this._tooltip.close();
          }
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          if (this._tooltip) {
            this._tooltip.toggle(this);
          }
          return this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(content) {
          if (this._tooltip) {
            this._tooltip.setContent(content);
          }
          return this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          if (this.getElement) {
            this._addFocusListenersOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._addFocusListenersOnLayer, this);
          }
        },
        _addFocusListenersOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            on(el, "focus", function() {
              this._tooltip._source = layer;
              this.openTooltip();
            }, this);
            on(el, "blur", this.closeTooltip, this);
          }
        },
        _setAriaDescribedByOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            el.setAttribute("aria-describedby", this._tooltip._container.id);
          }
        },
        _openTooltip: function(e) {
          if (!this._tooltip || !this._map) {
            return;
          }
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = true;
            var that = this;
            this._map.once("moveend", function() {
              that._openOnceFlag = false;
              that._openTooltip(e);
            });
            return;
          }
          this._tooltip._source = e.layer || e.target;
          this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
        },
        _moveTooltip: function(e) {
          var latlng = e.latlng, containerPoint, layerPoint;
          if (this._tooltip.options.sticky && e.originalEvent) {
            containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
            layerPoint = this._map.containerPointToLayerPoint(containerPoint);
            latlng = this._map.layerPointToLatLng(layerPoint);
          }
          this._tooltip.setLatLng(latlng);
        }
      });
      var DivIcon = Icon.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: false,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(oldIcon) {
          var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
          if (options.html instanceof Element) {
            empty(div);
            div.appendChild(options.html);
          } else {
            div.innerHTML = options.html !== false ? options.html : "";
          }
          if (options.bgPos) {
            var bgPos = toPoint(options.bgPos);
            div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
          }
          this._setIconStyles(div, "icon");
          return div;
        },
        createShadow: function() {
          return null;
        }
      });
      function divIcon2(options) {
        return new DivIcon(options);
      }
      Icon.Default = IconDefault;
      var GridLayer = Layer.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Browser.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: true,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: false,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        onAdd: function() {
          this._initContainer();
          this._levels = {};
          this._tiles = {};
          this._resetView();
        },
        beforeAdd: function(map2) {
          map2._addZoomLimit(this);
        },
        onRemove: function(map2) {
          this._removeAllTiles();
          remove(this._container);
          map2._removeZoomLimit(this);
          this._container = null;
          this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
            this._setAutoZIndex(Math.max);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
            this._setAutoZIndex(Math.min);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          this._updateOpacity();
          return this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(zIndex) {
          this.options.zIndex = zIndex;
          this._updateZIndex();
          return this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var tileZoom = this._clampZoom(this._map.getZoom());
            if (tileZoom !== this._tileZoom) {
              this._tileZoom = tileZoom;
              this._updateLevels();
            }
            this._update();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          if (!this.options.updateWhenIdle) {
            if (!this._onMove) {
              this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
            }
            events.move = this._onMove;
          }
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var s = this.options.tileSize;
          return s instanceof Point ? s : new Point(s, s);
        },
        _updateZIndex: function() {
          if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._container.style.zIndex = this.options.zIndex;
          }
        },
        _setAutoZIndex: function(compare) {
          var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
          for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
            zIndex = layers2[i].style.zIndex;
            if (layers2[i] !== this._container && zIndex) {
              edgeZIndex = compare(edgeZIndex, +zIndex);
            }
          }
          if (isFinite(edgeZIndex)) {
            this.options.zIndex = edgeZIndex + compare(-1, 1);
            this._updateZIndex();
          }
        },
        _updateOpacity: function() {
          if (!this._map) {
            return;
          }
          if (Browser.ielt9) {
            return;
          }
          setOpacity(this._container, this.options.opacity);
          var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
          for (var key in this._tiles) {
            var tile = this._tiles[key];
            if (!tile.current || !tile.loaded) {
              continue;
            }
            var fade = Math.min(1, (now - tile.loaded) / 200);
            setOpacity(tile.el, fade);
            if (fade < 1) {
              nextFrame = true;
            } else {
              if (tile.active) {
                willPrune = true;
              } else {
                this._onOpaqueTile(tile);
              }
              tile.active = true;
            }
          }
          if (willPrune && !this._noPrune) {
            this._pruneTiles();
          }
          if (nextFrame) {
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          }
        },
        _onOpaqueTile: falseFn,
        _initContainer: function() {
          if (this._container) {
            return;
          }
          this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
          this._updateZIndex();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
          this.getPane().appendChild(this._container);
        },
        _updateLevels: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
          if (zoom2 === void 0) {
            return void 0;
          }
          for (var z in this._levels) {
            z = Number(z);
            if (this._levels[z].el.children.length || z === zoom2) {
              this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
              this._onUpdateLevel(z);
            } else {
              remove(this._levels[z].el);
              this._removeTilesAtZoom(z);
              this._onRemoveLevel(z);
              delete this._levels[z];
            }
          }
          var level = this._levels[zoom2], map2 = this._map;
          if (!level) {
            level = this._levels[zoom2] = {};
            level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
            level.el.style.zIndex = maxZoom;
            level.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
            level.zoom = zoom2;
            this._setZoomTransform(level, map2.getCenter(), map2.getZoom());
            falseFn(level.el.offsetWidth);
            this._onCreateLevel(level);
          }
          this._level = level;
          return level;
        },
        _onUpdateLevel: falseFn,
        _onRemoveLevel: falseFn,
        _onCreateLevel: falseFn,
        _pruneTiles: function() {
          if (!this._map) {
            return;
          }
          var key, tile;
          var zoom2 = this._map.getZoom();
          if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            tile.retain = tile.current;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            if (tile.current && !tile.active) {
              var coords = tile.coords;
              if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
              }
            }
          }
          for (key in this._tiles) {
            if (!this._tiles[key].retain) {
              this._removeTile(key);
            }
          }
        },
        _removeTilesAtZoom: function(zoom2) {
          for (var key in this._tiles) {
            if (this._tiles[key].coords.z !== zoom2) {
              continue;
            }
            this._removeTile(key);
          }
        },
        _removeAllTiles: function() {
          for (var key in this._tiles) {
            this._removeTile(key);
          }
        },
        _invalidateAll: function() {
          for (var z in this._levels) {
            remove(this._levels[z].el);
            this._onRemoveLevel(Number(z));
            delete this._levels[z];
          }
          this._removeAllTiles();
          this._tileZoom = void 0;
        },
        _retainParent: function(x, y, z, minZoom) {
          var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
          coords2.z = +z2;
          var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
          if (tile && tile.active) {
            tile.retain = true;
            return true;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }
          if (z2 > minZoom) {
            return this._retainParent(x2, y2, z2, minZoom);
          }
          return false;
        },
        _retainChildren: function(x, y, z, maxZoom) {
          for (var i = 2 * x; i < 2 * x + 2; i++) {
            for (var j = 2 * y; j < 2 * y + 2; j++) {
              var coords = new Point(i, j);
              coords.z = z + 1;
              var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
              if (tile && tile.active) {
                tile.retain = true;
                continue;
              } else if (tile && tile.loaded) {
                tile.retain = true;
              }
              if (z + 1 < maxZoom) {
                this._retainChildren(i, j, z + 1, maxZoom);
              }
            }
          }
        },
        _resetView: function(e) {
          var animating = e && (e.pinch || e.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },
        _animateZoom: function(e) {
          this._setView(e.center, e.zoom, true, e.noUpdate);
        },
        _clampZoom: function(zoom2) {
          var options = this.options;
          if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
            return options.minNativeZoom;
          }
          if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
            return options.maxNativeZoom;
          }
          return zoom2;
        },
        _setView: function(center, zoom2, noPrune, noUpdate) {
          var tileZoom = Math.round(zoom2);
          if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
            tileZoom = void 0;
          } else {
            tileZoom = this._clampZoom(tileZoom);
          }
          var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
          if (!noUpdate || tileZoomChanged) {
            this._tileZoom = tileZoom;
            if (this._abortLoading) {
              this._abortLoading();
            }
            this._updateLevels();
            this._resetGrid();
            if (tileZoom !== void 0) {
              this._update(center);
            }
            if (!noPrune) {
              this._pruneTiles();
            }
            this._noPrune = !!noPrune;
          }
          this._setZoomTransforms(center, zoom2);
        },
        _setZoomTransforms: function(center, zoom2) {
          for (var i in this._levels) {
            this._setZoomTransform(this._levels[i], center, zoom2);
          }
        },
        _setZoomTransform: function(level, center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
          if (Browser.any3d) {
            setTransform(level.el, translate, scale2);
          } else {
            setPosition(level.el, translate);
          }
        },
        _resetGrid: function() {
          var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
          var bounds = this._map.getPixelWorldBounds(this._tileZoom);
          if (bounds) {
            this._globalTileRange = this._pxBoundsToTileRange(bounds);
          }
          this._wrapX = crs.wrapLng && !this.options.noWrap && [
            Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
            Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
          ];
          this._wrapY = crs.wrapLat && !this.options.noWrap && [
            Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
            Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
          ];
        },
        _onMoveEnd: function() {
          if (!this._map || this._map._animatingZoom) {
            return;
          }
          this._update();
        },
        _getTiledPixelBounds: function(center) {
          var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale2 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale2 * 2);
          return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(center) {
          var map2 = this._map;
          if (!map2) {
            return;
          }
          var zoom2 = this._clampZoom(map2.getZoom());
          if (center === void 0) {
            center = map2.getCenter();
          }
          if (this._tileZoom === void 0) {
            return;
          }
          var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
            tileRange.getBottomLeft().subtract([margin, -margin]),
            tileRange.getTopRight().add([margin, -margin])
          );
          if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
            throw new Error("Attempted to load an infinite number of tiles");
          }
          for (var key in this._tiles) {
            var c = this._tiles[key].coords;
            if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
              this._tiles[key].current = false;
            }
          }
          if (Math.abs(zoom2 - this._tileZoom) > 1) {
            this._setView(center, zoom2);
            return;
          }
          for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
              var coords = new Point(i, j);
              coords.z = this._tileZoom;
              if (!this._isValidTile(coords)) {
                continue;
              }
              var tile = this._tiles[this._tileCoordsToKey(coords)];
              if (tile) {
                tile.current = true;
              } else {
                queue.push(coords);
              }
            }
          }
          queue.sort(function(a, b) {
            return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
          });
          if (queue.length !== 0) {
            if (!this._loading) {
              this._loading = true;
              this.fire("loading");
            }
            var fragment = document.createDocumentFragment();
            for (i = 0; i < queue.length; i++) {
              this._addTile(queue[i], fragment);
            }
            this._level.el.appendChild(fragment);
          }
        },
        _isValidTile: function(coords) {
          var crs = this._map.options.crs;
          if (!crs.infinite) {
            var bounds = this._globalTileRange;
            if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
              return false;
            }
          }
          if (!this.options.bounds) {
            return true;
          }
          var tileBounds = this._tileCoordsToBounds(coords);
          return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
        },
        _keyToBounds: function(key) {
          return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },
        _tileCoordsToNwSe: function(coords) {
          var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords.z), se = map2.unproject(sePoint, coords.z);
          return [nw, se];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(coords) {
          var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
          if (!this.options.noWrap) {
            bounds = this._map.wrapLatLngBounds(bounds);
          }
          return bounds;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(coords) {
          return coords.x + ":" + coords.y + ":" + coords.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(key) {
          var k = key.split(":"), coords = new Point(+k[0], +k[1]);
          coords.z = +k[2];
          return coords;
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          remove(tile.el);
          delete this._tiles[key];
          this.fire("tileunload", {
            tile: tile.el,
            coords: this._keyToTileCoords(key)
          });
        },
        _initTile: function(tile) {
          addClass(tile, "leaflet-tile");
          var tileSize = this.getTileSize();
          tile.style.width = tileSize.x + "px";
          tile.style.height = tileSize.y + "px";
          tile.onselectstart = falseFn;
          tile.onmousemove = falseFn;
          if (Browser.ielt9 && this.options.opacity < 1) {
            setOpacity(tile, this.options.opacity);
          }
        },
        _addTile: function(coords, container) {
          var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
          var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
          this._initTile(tile);
          if (this.createTile.length < 2) {
            requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
          }
          setPosition(tile, tilePos);
          this._tiles[key] = {
            el: tile,
            coords,
            current: true
          };
          container.appendChild(tile);
          this.fire("tileloadstart", {
            tile,
            coords
          });
        },
        _tileReady: function(coords, err, tile) {
          if (err) {
            this.fire("tileerror", {
              error: err,
              tile,
              coords
            });
          }
          var key = this._tileCoordsToKey(coords);
          tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.loaded = +/* @__PURE__ */ new Date();
          if (this._map._fadeAnimated) {
            setOpacity(tile.el, 0);
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          } else {
            tile.active = true;
            this._pruneTiles();
          }
          if (!err) {
            addClass(tile.el, "leaflet-tile-loaded");
            this.fire("tileload", {
              tile: tile.el,
              coords
            });
          }
          if (this._noTilesToLoad()) {
            this._loading = false;
            this.fire("load");
            if (Browser.ielt9 || !this._map._fadeAnimated) {
              requestAnimFrame(this._pruneTiles, this);
            } else {
              setTimeout(bind(this._pruneTiles, this), 250);
            }
          }
        },
        _getTilePos: function(coords) {
          return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(coords) {
          var newCoords = new Point(
            this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
            this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
          );
          newCoords.z = coords.z;
          return newCoords;
        },
        _pxBoundsToTileRange: function(bounds) {
          var tileSize = this.getTileSize();
          return new Bounds(
            bounds.min.unscaleBy(tileSize).floor(),
            bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var key in this._tiles) {
            if (!this._tiles[key].loaded) {
              return false;
            }
          }
          return true;
        }
      });
      function gridLayer(options) {
        return new GridLayer(options);
      }
      var TileLayer = GridLayer.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: false,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: false,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: false
        },
        initialize: function(url, options) {
          this._url = url;
          options = setOptions(this, options);
          if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
            options.tileSize = Math.floor(options.tileSize / 2);
            if (!options.zoomReverse) {
              options.zoomOffset++;
              options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
            } else {
              options.zoomOffset--;
              options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
            }
            options.minZoom = Math.max(0, options.minZoom);
          } else if (!options.zoomReverse) {
            options.maxZoom = Math.max(options.minZoom, options.maxZoom);
          } else {
            options.minZoom = Math.min(options.maxZoom, options.minZoom);
          }
          if (typeof options.subdomains === "string") {
            options.subdomains = options.subdomains.split("");
          }
          this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(url, noRedraw) {
          if (this._url === url && noRedraw === void 0) {
            noRedraw = true;
          }
          this._url = url;
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(coords, done) {
          var tile = document.createElement("img");
          on(tile, "load", bind(this._tileOnLoad, this, done, tile));
          on(tile, "error", bind(this._tileOnError, this, done, tile));
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (typeof this.options.referrerPolicy === "string") {
            tile.referrerPolicy = this.options.referrerPolicy;
          }
          tile.alt = "";
          tile.src = this.getTileUrl(coords);
          return tile;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(coords) {
          var data = {
            r: Browser.retina ? "@2x" : "",
            s: this._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var invertedY = this._globalTileRange.max.y - coords.y;
            if (this.options.tms) {
              data["y"] = invertedY;
            }
            data["-y"] = invertedY;
          }
          return template(this._url, extend(data, this.options));
        },
        _tileOnLoad: function(done, tile) {
          if (Browser.ielt9) {
            setTimeout(bind(done, this, null, tile), 0);
          } else {
            done(null, tile);
          }
        },
        _tileOnError: function(done, tile, e) {
          var errorUrl = this.options.errorTileUrl;
          if (errorUrl && tile.getAttribute("src") !== errorUrl) {
            tile.src = errorUrl;
          }
          done(e, tile);
        },
        _onTileRemove: function(e) {
          e.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
          if (zoomReverse) {
            zoom2 = maxZoom - zoom2;
          }
          return zoom2 + zoomOffset;
        },
        _getSubdomain: function(tilePoint) {
          var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
          return this.options.subdomains[index2];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var i, tile;
          for (i in this._tiles) {
            if (this._tiles[i].coords.z !== this._tileZoom) {
              tile = this._tiles[i].el;
              tile.onload = falseFn;
              tile.onerror = falseFn;
              if (!tile.complete) {
                tile.src = emptyImageUrl;
                var coords = this._tiles[i].coords;
                remove(tile);
                delete this._tiles[i];
                this.fire("tileabort", {
                  tile,
                  coords
                });
              }
            }
          }
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.el.setAttribute("src", emptyImageUrl);
          return GridLayer.prototype._removeTile.call(this, key);
        },
        _tileReady: function(coords, err, tile) {
          if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
            return;
          }
          return GridLayer.prototype._tileReady.call(this, coords, err, tile);
        }
      });
      function tileLayer2(url, options) {
        return new TileLayer(url, options);
      }
      var TileLayerWMS = TileLayer.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: false,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: false
        },
        initialize: function(url, options) {
          this._url = url;
          var wmsParams = extend({}, this.defaultWmsParams);
          for (var i in options) {
            if (!(i in this.options)) {
              wmsParams[i] = options[i];
            }
          }
          options = setOptions(this, options);
          var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
          var tileSize = this.getTileSize();
          wmsParams.width = tileSize.x * realRetina;
          wmsParams.height = tileSize.y * realRetina;
          this.wmsParams = wmsParams;
        },
        onAdd: function(map2) {
          this._crs = this.options.crs || map2.options.crs;
          this._wmsVersion = parseFloat(this.wmsParams.version);
          var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[projectionKey] = this._crs.code;
          TileLayer.prototype.onAdd.call(this, map2);
        },
        getTileUrl: function(coords) {
          var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
          return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(params, noRedraw) {
          extend(this.wmsParams, params);
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        }
      });
      function tileLayerWMS(url, options) {
        return new TileLayerWMS(url, options);
      }
      TileLayer.WMS = TileLayerWMS;
      tileLayer2.wms = tileLayerWMS;
      var Renderer = Layer.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(options) {
          setOptions(this, options);
          stamp(this);
          this._layers = this._layers || {};
        },
        onAdd: function() {
          if (!this._container) {
            this._initContainer();
            addClass(this._container, "leaflet-zoom-animated");
          }
          this.getPane().appendChild(this._container);
          this._update();
          this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this);
          this._destroyContainer();
        },
        getEvents: function() {
          var events = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._onAnimZoom;
          }
          return events;
        },
        _onAnimZoom: function(ev) {
          this._updateTransform(ev.center, ev.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
          if (Browser.any3d) {
            setTransform(this._container, topLeftOffset, scale2);
          } else {
            setPosition(this._container, topLeftOffset);
          }
        },
        _reset: function() {
          this._update();
          this._updateTransform(this._center, this._zoom);
          for (var id in this._layers) {
            this._layers[id]._reset();
          }
        },
        _onZoomEnd: function() {
          for (var id in this._layers) {
            this._layers[id]._project();
          }
        },
        _updatePaths: function() {
          for (var id in this._layers) {
            this._layers[id]._update();
          }
        },
        _update: function() {
          var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
          this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
          this._center = this._map.getCenter();
          this._zoom = this._map.getZoom();
        }
      });
      var Canvas = Renderer.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var events = Renderer.prototype.getEvents.call(this);
          events.viewprereset = this._onViewPreReset;
          return events;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = true;
        },
        onAdd: function() {
          Renderer.prototype.onAdd.call(this);
          this._draw();
        },
        _initContainer: function() {
          var container = this._container = document.createElement("canvas");
          on(container, "mousemove", this._onMouseMove, this);
          on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
          on(container, "mouseout", this._handleMouseOut, this);
          container["_leaflet_disable_events"] = true;
          this._ctx = container.getContext("2d");
        },
        _destroyContainer: function() {
          cancelAnimFrame(this._redrawRequest);
          delete this._ctx;
          remove(this._container);
          off(this._container);
          delete this._container;
        },
        _updatePaths: function() {
          if (this._postponeUpdatePaths) {
            return;
          }
          var layer;
          this._redrawBounds = null;
          for (var id in this._layers) {
            layer = this._layers[id];
            layer._update();
          }
          this._redraw();
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
          setPosition(container, b.min);
          container.width = m * size.x;
          container.height = m * size.y;
          container.style.width = size.x + "px";
          container.style.height = size.y + "px";
          if (Browser.retina) {
            this._ctx.scale(2, 2);
          }
          this._ctx.translate(-b.min.x, -b.min.y);
          this.fire("update");
        },
        _reset: function() {
          Renderer.prototype._reset.call(this);
          if (this._postponeUpdatePaths) {
            this._postponeUpdatePaths = false;
            this._updatePaths();
          }
        },
        _initPath: function(layer) {
          this._updateDashArray(layer);
          this._layers[stamp(layer)] = layer;
          var order = layer._order = {
            layer,
            prev: this._drawLast,
            next: null
          };
          if (this._drawLast) {
            this._drawLast.next = order;
          }
          this._drawLast = order;
          this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(layer) {
          this._requestRedraw(layer);
        },
        _removePath: function(layer) {
          var order = layer._order;
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            this._drawLast = prev;
          }
          if (prev) {
            prev.next = next;
          } else {
            this._drawFirst = next;
          }
          delete layer._order;
          delete this._layers[stamp(layer)];
          this._requestRedraw(layer);
        },
        _updatePath: function(layer) {
          this._extendRedrawBounds(layer);
          layer._project();
          layer._update();
          this._requestRedraw(layer);
        },
        _updateStyle: function(layer) {
          this._updateDashArray(layer);
          this._requestRedraw(layer);
        },
        _updateDashArray: function(layer) {
          if (typeof layer.options.dashArray === "string") {
            var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
            for (i = 0; i < parts.length; i++) {
              dashValue = Number(parts[i]);
              if (isNaN(dashValue)) {
                return;
              }
              dashArray.push(dashValue);
            }
            layer.options._dashArray = dashArray;
          } else {
            layer.options._dashArray = layer.options.dashArray;
          }
        },
        _requestRedraw: function(layer) {
          if (!this._map) {
            return;
          }
          this._extendRedrawBounds(layer);
          this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
        },
        _extendRedrawBounds: function(layer) {
          if (layer._pxBounds) {
            var padding = (layer.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Bounds();
            this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
            this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null;
          if (this._redrawBounds) {
            this._redrawBounds.min._floor();
            this._redrawBounds.max._ceil();
          }
          this._clear();
          this._draw();
          this._redrawBounds = null;
        },
        _clear: function() {
          var bounds = this._redrawBounds;
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
          } else {
            this._ctx.save();
            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
            this._ctx.restore();
          }
        },
        _draw: function() {
          var layer, bounds = this._redrawBounds;
          this._ctx.save();
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.beginPath();
            this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
            this._ctx.clip();
          }
          this._drawing = true;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
              layer._updatePath();
            }
          }
          this._drawing = false;
          this._ctx.restore();
        },
        _updatePoly: function(layer, closed) {
          if (!this._drawing) {
            return;
          }
          var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
          if (!len) {
            return;
          }
          ctx.beginPath();
          for (i = 0; i < len; i++) {
            for (j = 0, len2 = parts[i].length; j < len2; j++) {
              p = parts[i][j];
              ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
            }
            if (closed) {
              ctx.closePath();
            }
          }
          this._fillStroke(ctx, layer);
        },
        _updateCircle: function(layer) {
          if (!this._drawing || layer._empty()) {
            return;
          }
          var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
          if (s !== 1) {
            ctx.save();
            ctx.scale(1, s);
          }
          ctx.beginPath();
          ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
          if (s !== 1) {
            ctx.restore();
          }
          this._fillStroke(ctx, layer);
        },
        _fillStroke: function(ctx, layer) {
          var options = layer.options;
          if (options.fill) {
            ctx.globalAlpha = options.fillOpacity;
            ctx.fillStyle = options.fillColor || options.color;
            ctx.fill(options.fillRule || "evenodd");
          }
          if (options.stroke && options.weight !== 0) {
            if (ctx.setLineDash) {
              ctx.setLineDash(layer.options && layer.options._dashArray || []);
            }
            ctx.globalAlpha = options.opacity;
            ctx.lineWidth = options.weight;
            ctx.strokeStyle = options.color;
            ctx.lineCap = options.lineCap;
            ctx.lineJoin = options.lineJoin;
            ctx.stroke();
          }
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(e) {
          var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
              if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                clickedLayer = layer;
              }
            }
          }
          this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
        },
        _onMouseMove: function(e) {
          if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
            return;
          }
          var point = this._map.mouseEventToLayerPoint(e);
          this._handleMouseHover(e, point);
        },
        _handleMouseOut: function(e) {
          var layer = this._hoveredLayer;
          if (layer) {
            removeClass(this._container, "leaflet-interactive");
            this._fireEvent([layer], e, "mouseout");
            this._hoveredLayer = null;
            this._mouseHoverThrottled = false;
          }
        },
        _handleMouseHover: function(e, point) {
          if (this._mouseHoverThrottled) {
            return;
          }
          var layer, candidateHoveredLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
              candidateHoveredLayer = layer;
            }
          }
          if (candidateHoveredLayer !== this._hoveredLayer) {
            this._handleMouseOut(e);
            if (candidateHoveredLayer) {
              addClass(this._container, "leaflet-interactive");
              this._fireEvent([candidateHoveredLayer], e, "mouseover");
              this._hoveredLayer = candidateHoveredLayer;
            }
          }
          this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
          this._mouseHoverThrottled = true;
          setTimeout(bind(function() {
            this._mouseHoverThrottled = false;
          }, this), 32);
        },
        _fireEvent: function(layers2, e, type) {
          this._map._fireDOMEvent(e, type || e.type, layers2);
        },
        _bringToFront: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            return;
          }
          if (prev) {
            prev.next = next;
          } else if (next) {
            this._drawFirst = next;
          }
          order.prev = this._drawLast;
          this._drawLast.next = order;
          order.next = null;
          this._drawLast = order;
          this._requestRedraw(layer);
        },
        _bringToBack: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (prev) {
            prev.next = next;
          } else {
            return;
          }
          if (next) {
            next.prev = prev;
          } else if (prev) {
            this._drawLast = prev;
          }
          order.prev = null;
          order.next = this._drawFirst;
          this._drawFirst.prev = order;
          this._drawFirst = order;
          this._requestRedraw(layer);
        }
      });
      function canvas(options) {
        return Browser.canvas ? new Canvas(options) : null;
      }
      var vmlCreate = function() {
        try {
          document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
          return function(name) {
            return document.createElement("<lvml:" + name + ' class="lvml">');
          };
        } catch (e) {
        }
        return function(name) {
          return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }();
      var vmlMixin = {
        _initContainer: function() {
          this._container = create$1("div", "leaflet-vml-container");
        },
        _update: function() {
          if (this._map._animatingZoom) {
            return;
          }
          Renderer.prototype._update.call(this);
          this.fire("update");
        },
        _initPath: function(layer) {
          var container = layer._container = vmlCreate("shape");
          addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
          container.coordsize = "1 1";
          layer._path = vmlCreate("path");
          container.appendChild(layer._path);
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          var container = layer._container;
          this._container.appendChild(container);
          if (layer.options.interactive) {
            layer.addInteractiveTarget(container);
          }
        },
        _removePath: function(layer) {
          var container = layer._container;
          remove(container);
          layer.removeInteractiveTarget(container);
          delete this._layers[stamp(layer)];
        },
        _updateStyle: function(layer) {
          var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
          container.stroked = !!options.stroke;
          container.filled = !!options.fill;
          if (options.stroke) {
            if (!stroke) {
              stroke = layer._stroke = vmlCreate("stroke");
            }
            container.appendChild(stroke);
            stroke.weight = options.weight + "px";
            stroke.color = options.color;
            stroke.opacity = options.opacity;
            if (options.dashArray) {
              stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
            } else {
              stroke.dashStyle = "";
            }
            stroke.endcap = options.lineCap.replace("butt", "flat");
            stroke.joinstyle = options.lineJoin;
          } else if (stroke) {
            container.removeChild(stroke);
            layer._stroke = null;
          }
          if (options.fill) {
            if (!fill) {
              fill = layer._fill = vmlCreate("fill");
            }
            container.appendChild(fill);
            fill.color = options.fillColor || options.color;
            fill.opacity = options.fillOpacity;
          } else if (fill) {
            container.removeChild(fill);
            layer._fill = null;
          }
        },
        _updateCircle: function(layer) {
          var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
          this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
        },
        _setPath: function(layer, path) {
          layer._path.v = path;
        },
        _bringToFront: function(layer) {
          toFront(layer._container);
        },
        _bringToBack: function(layer) {
          toBack(layer._container);
        }
      };
      var create = Browser.vml ? vmlCreate : svgCreate;
      var SVG = Renderer.extend({
        _initContainer: function() {
          this._container = create("svg");
          this._container.setAttribute("pointer-events", "none");
          this._rootGroup = create("g");
          this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          remove(this._container);
          off(this._container);
          delete this._container;
          delete this._rootGroup;
          delete this._svgSize;
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, size = b.getSize(), container = this._container;
          if (!this._svgSize || !this._svgSize.equals(size)) {
            this._svgSize = size;
            container.setAttribute("width", size.x);
            container.setAttribute("height", size.y);
          }
          setPosition(container, b.min);
          container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
          this.fire("update");
        },
        // methods below are called by vector layers implementations
        _initPath: function(layer) {
          var path = layer._path = create("path");
          if (layer.options.className) {
            addClass(path, layer.options.className);
          }
          if (layer.options.interactive) {
            addClass(path, "leaflet-interactive");
          }
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          if (!this._rootGroup) {
            this._initContainer();
          }
          this._rootGroup.appendChild(layer._path);
          layer.addInteractiveTarget(layer._path);
        },
        _removePath: function(layer) {
          remove(layer._path);
          layer.removeInteractiveTarget(layer._path);
          delete this._layers[stamp(layer)];
        },
        _updatePath: function(layer) {
          layer._project();
          layer._update();
        },
        _updateStyle: function(layer) {
          var path = layer._path, options = layer.options;
          if (!path) {
            return;
          }
          if (options.stroke) {
            path.setAttribute("stroke", options.color);
            path.setAttribute("stroke-opacity", options.opacity);
            path.setAttribute("stroke-width", options.weight);
            path.setAttribute("stroke-linecap", options.lineCap);
            path.setAttribute("stroke-linejoin", options.lineJoin);
            if (options.dashArray) {
              path.setAttribute("stroke-dasharray", options.dashArray);
            } else {
              path.removeAttribute("stroke-dasharray");
            }
            if (options.dashOffset) {
              path.setAttribute("stroke-dashoffset", options.dashOffset);
            } else {
              path.removeAttribute("stroke-dashoffset");
            }
          } else {
            path.setAttribute("stroke", "none");
          }
          if (options.fill) {
            path.setAttribute("fill", options.fillColor || options.color);
            path.setAttribute("fill-opacity", options.fillOpacity);
            path.setAttribute("fill-rule", options.fillRule || "evenodd");
          } else {
            path.setAttribute("fill", "none");
          }
        },
        _updatePoly: function(layer, closed) {
          this._setPath(layer, pointsToPath(layer._parts, closed));
        },
        _updateCircle: function(layer) {
          var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
          var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
          this._setPath(layer, d);
        },
        _setPath: function(layer, path) {
          layer._path.setAttribute("d", path);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(layer) {
          toFront(layer._path);
        },
        _bringToBack: function(layer) {
          toBack(layer._path);
        }
      });
      if (Browser.vml) {
        SVG.include(vmlMixin);
      }
      function svg(options) {
        return Browser.svg || Browser.vml ? new SVG(options) : null;
      }
      Map.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(layer) {
          var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
          if (!renderer) {
            renderer = this._renderer = this._createRenderer();
          }
          if (!this.hasLayer(renderer)) {
            this.addLayer(renderer);
          }
          return renderer;
        },
        _getPaneRenderer: function(name) {
          if (name === "overlayPane" || name === void 0) {
            return false;
          }
          var renderer = this._paneRenderers[name];
          if (renderer === void 0) {
            renderer = this._createRenderer({ pane: name });
            this._paneRenderers[name] = renderer;
          }
          return renderer;
        },
        _createRenderer: function(options) {
          return this.options.preferCanvas && canvas(options) || svg(options);
        }
      });
      var Rectangle = Polygon.extend({
        initialize: function(latLngBounds, options) {
          Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(latLngBounds) {
          return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function(latLngBounds) {
          latLngBounds = toLatLngBounds(latLngBounds);
          return [
            latLngBounds.getSouthWest(),
            latLngBounds.getNorthWest(),
            latLngBounds.getNorthEast(),
            latLngBounds.getSouthEast()
          ];
        }
      });
      function rectangle(latLngBounds, options) {
        return new Rectangle(latLngBounds, options);
      }
      SVG.create = create;
      SVG.pointsToPath = pointsToPath;
      GeoJSON.geometryToLayer = geometryToLayer;
      GeoJSON.coordsToLatLng = coordsToLatLng;
      GeoJSON.coordsToLatLngs = coordsToLatLngs;
      GeoJSON.latLngToCoords = latLngToCoords;
      GeoJSON.latLngsToCoords = latLngsToCoords;
      GeoJSON.getFeature = getFeature;
      GeoJSON.asFeature = asFeature;
      Map.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: true
      });
      var BoxZoom = Handler.extend({
        initialize: function(map2) {
          this._map = map2;
          this._container = map2._container;
          this._pane = map2._panes.overlayPane;
          this._resetStateTimeout = 0;
          map2.on("unload", this._destroy, this);
        },
        addHooks: function() {
          on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          off(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          remove(this._pane);
          delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0;
          this._moved = false;
        },
        _clearDeferredResetState: function() {
          if (this._resetStateTimeout !== 0) {
            clearTimeout(this._resetStateTimeout);
            this._resetStateTimeout = 0;
          }
        },
        _onMouseDown: function(e) {
          if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
            return false;
          }
          this._clearDeferredResetState();
          this._resetState();
          disableTextSelection();
          disableImageDrag();
          this._startPoint = this._map.mouseEventToContainerPoint(e);
          on(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(e) {
          if (!this._moved) {
            this._moved = true;
            this._box = create$1("div", "leaflet-zoom-box", this._container);
            addClass(this._container, "leaflet-crosshair");
            this._map.fire("boxzoomstart");
          }
          this._point = this._map.mouseEventToContainerPoint(e);
          var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
          setPosition(this._box, bounds.min);
          this._box.style.width = size.x + "px";
          this._box.style.height = size.y + "px";
        },
        _finish: function() {
          if (this._moved) {
            remove(this._box);
            removeClass(this._container, "leaflet-crosshair");
          }
          enableTextSelection();
          enableImageDrag();
          off(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(e) {
          if (e.which !== 1 && e.button !== 1) {
            return;
          }
          this._finish();
          if (!this._moved) {
            return;
          }
          this._clearDeferredResetState();
          this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
          var bounds = new LatLngBounds(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
        },
        _onKeyDown: function(e) {
          if (e.keyCode === 27) {
            this._finish();
            this._clearDeferredResetState();
            this._resetState();
          }
        }
      });
      Map.addInitHook("addHandler", "boxZoom", BoxZoom);
      Map.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: true
      });
      var DoubleClickZoom = Handler.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e) {
          var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
          if (map2.options.doubleClickZoom === "center") {
            map2.setZoom(zoom2);
          } else {
            map2.setZoomAround(e.containerPoint, zoom2);
          }
        }
      });
      Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
      Map.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: true,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: true,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second².
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Drag = Handler.extend({
        addHooks: function() {
          if (!this._draggable) {
            var map2 = this._map;
            this._draggable = new Draggable(map2._mapPane, map2._container);
            this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this);
            this._draggable.on("predrag", this._onPreDragLimit, this);
            if (map2.options.worldCopyJump) {
              this._draggable.on("predrag", this._onPreDragWrap, this);
              map2.on("zoomend", this._onZoomEnd, this);
              map2.whenReady(this._onZoomEnd, this);
            }
          }
          addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
          this._draggable.enable();
          this._positions = [];
          this._times = [];
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-grab");
          removeClass(this._map._container, "leaflet-touch-drag");
          this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var map2 = this._map;
          map2._stop();
          if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var bounds = toLatLngBounds(this._map.options.maxBounds);
            this._offsetLimit = toBounds(
              this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            );
            this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else {
            this._offsetLimit = null;
          }
          map2.fire("movestart").fire("dragstart");
          if (map2.options.inertia) {
            this._positions = [];
            this._times = [];
          }
        },
        _onDrag: function(e) {
          if (this._map.options.inertia) {
            var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(pos);
            this._times.push(time);
            this._prunePositions(time);
          }
          this._map.fire("move", e).fire("drag", e);
        },
        _prunePositions: function(time) {
          while (this._positions.length > 1 && time - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
          }
        },
        _onZoomEnd: function() {
          var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
          this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(value, threshold) {
          return value - (value - threshold) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!this._viscosity || !this._offsetLimit) {
            return;
          }
          var offset = this._draggable._newPos.subtract(this._draggable._startPos);
          var limit = this._offsetLimit;
          if (offset.x < limit.min.x) {
            offset.x = this._viscousLimit(offset.x, limit.min.x);
          }
          if (offset.y < limit.min.y) {
            offset.y = this._viscousLimit(offset.y, limit.min.y);
          }
          if (offset.x > limit.max.x) {
            offset.x = this._viscousLimit(offset.x, limit.max.x);
          }
          if (offset.y > limit.max.y) {
            offset.y = this._viscousLimit(offset.y, limit.max.y);
          }
          this._draggable._newPos = this._draggable._startPos.add(offset);
        },
        _onPreDragWrap: function() {
          var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
          this._draggable._absPos = this._draggable._newPos.clone();
          this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e) {
          var map2 = this._map, options = map2.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
          map2.fire("dragend", e);
          if (noInertia) {
            map2.fire("moveend");
          } else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
            if (!offset.x && !offset.y) {
              map2.fire("moveend");
            } else {
              offset = map2._limitOffset(offset, map2.options.maxBounds);
              requestAnimFrame(function() {
                map2.panBy(offset, {
                  duration: decelerationDuration,
                  easeLinearity: ease,
                  noMoveStart: true,
                  animate: true
                });
              });
            }
          }
        }
      });
      Map.addInitHook("addHandler", "dragging", Drag);
      Map.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: true,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Keyboard = Handler.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(map2) {
          this._map = map2;
          this._setPanDelta(map2.options.keyboardPanDelta);
          this._setZoomDelta(map2.options.zoomDelta);
        },
        addHooks: function() {
          var container = this._map._container;
          if (container.tabIndex <= 0) {
            container.tabIndex = "0";
          }
          on(container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks();
          off(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (this._focused) {
            return;
          }
          var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
          this._map._container.focus();
          window.scrollTo(left, top);
        },
        _onFocus: function() {
          this._focused = true;
          this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = false;
          this._map.fire("blur");
        },
        _setPanDelta: function(panDelta) {
          var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
          for (i = 0, len = codes.left.length; i < len; i++) {
            keys[codes.left[i]] = [-1 * panDelta, 0];
          }
          for (i = 0, len = codes.right.length; i < len; i++) {
            keys[codes.right[i]] = [panDelta, 0];
          }
          for (i = 0, len = codes.down.length; i < len; i++) {
            keys[codes.down[i]] = [0, panDelta];
          }
          for (i = 0, len = codes.up.length; i < len; i++) {
            keys[codes.up[i]] = [0, -1 * panDelta];
          }
        },
        _setZoomDelta: function(zoomDelta) {
          var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
          for (i = 0, len = codes.zoomIn.length; i < len; i++) {
            keys[codes.zoomIn[i]] = zoomDelta;
          }
          for (i = 0, len = codes.zoomOut.length; i < len; i++) {
            keys[codes.zoomOut[i]] = -zoomDelta;
          }
        },
        _addHooks: function() {
          on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e) {
          if (e.altKey || e.ctrlKey || e.metaKey) {
            return;
          }
          var key = e.keyCode, map2 = this._map, offset;
          if (key in this._panKeys) {
            if (!map2._panAnim || !map2._panAnim._inProgress) {
              offset = this._panKeys[key];
              if (e.shiftKey) {
                offset = toPoint(offset).multiplyBy(3);
              }
              if (map2.options.maxBounds) {
                offset = map2._limitOffset(toPoint(offset), map2.options.maxBounds);
              }
              if (map2.options.worldCopyJump) {
                var newLatLng = map2.wrapLatLng(map2.unproject(map2.project(map2.getCenter()).add(offset)));
                map2.panTo(newLatLng);
              } else {
                map2.panBy(offset);
              }
            }
          } else if (key in this._zoomKeys) {
            map2.setZoom(map2.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
          } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
            map2.closePopup();
          } else {
            return;
          }
          stop(e);
        }
      });
      Map.addInitHook("addHandler", "keyboard", Keyboard);
      Map.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var ScrollWheelZoom = Handler.extend({
        addHooks: function() {
          on(this._map._container, "wheel", this._onWheelScroll, this);
          this._delta = 0;
        },
        removeHooks: function() {
          off(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(e) {
          var delta = getWheelDelta(e);
          var debounce = this._map.options.wheelDebounceTime;
          this._delta += delta;
          this._lastMousePos = this._map.mouseEventToContainerPoint(e);
          if (!this._startTime) {
            this._startTime = +/* @__PURE__ */ new Date();
          }
          var left = Math.max(debounce - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer);
          this._timer = setTimeout(bind(this._performZoom, this), left);
          stop(e);
        },
        _performZoom: function() {
          var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
          map2._stop();
          var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
          this._delta = 0;
          this._startTime = null;
          if (!delta) {
            return;
          }
          if (map2.options.scrollWheelZoom === "center") {
            map2.setZoom(zoom2 + delta);
          } else {
            map2.setZoomAround(this._lastMousePos, zoom2 + delta);
          }
        }
      });
      Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
      var tapHoldDelay = 600;
      Map.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var TapHold = Handler.extend({
        addHooks: function() {
          on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e) {
          clearTimeout(this._holdTimeout);
          if (e.touches.length !== 1) {
            return;
          }
          var first = e.touches[0];
          this._startPos = this._newPos = new Point(first.clientX, first.clientY);
          this._holdTimeout = setTimeout(bind(function() {
            this._cancel();
            if (!this._isTapValid()) {
              return;
            }
            on(document, "touchend", preventDefault);
            on(document, "touchend touchcancel", this._cancelClickPrevent);
            this._simulateEvent("contextmenu", first);
          }, this), tapHoldDelay);
          on(document, "touchend touchcancel contextmenu", this._cancel, this);
          on(document, "touchmove", this._onMove, this);
        },
        _cancelClickPrevent: function cancelClickPrevent() {
          off(document, "touchend", preventDefault);
          off(document, "touchend touchcancel", cancelClickPrevent);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout);
          off(document, "touchend touchcancel contextmenu", this._cancel, this);
          off(document, "touchmove", this._onMove, this);
        },
        _onMove: function(e) {
          var first = e.touches[0];
          this._newPos = new Point(first.clientX, first.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(type, e) {
          var simulatedEvent = new MouseEvent(type, {
            bubbles: true,
            cancelable: true,
            view: window,
            // detail: 1,
            screenX: e.screenX,
            screenY: e.screenY,
            clientX: e.clientX,
            clientY: e.clientY
            // button: 2,
            // buttons: 2
          });
          simulatedEvent._simulated = true;
          e.target.dispatchEvent(simulatedEvent);
        }
      });
      Map.addInitHook("addHandler", "tapHold", TapHold);
      Map.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Browser.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: true
      });
      var TouchZoom = Handler.extend({
        addHooks: function() {
          addClass(this._map._container, "leaflet-touch-zoom");
          on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-touch-zoom");
          off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e) {
          var map2 = this._map;
          if (!e.touches || e.touches.length !== 2 || map2._animatingZoom || this._zooming) {
            return;
          }
          var p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]);
          this._centerPoint = map2.getSize()._divideBy(2);
          this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
          if (map2.options.touchZoom !== "center") {
            this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p2)._divideBy(2));
          }
          this._startDist = p1.distanceTo(p2);
          this._startZoom = map2.getZoom();
          this._moved = false;
          this._zooming = true;
          map2._stop();
          on(document, "touchmove", this._onTouchMove, this);
          on(document, "touchend touchcancel", this._onTouchEnd, this);
          preventDefault(e);
        },
        _onTouchMove: function(e) {
          if (!e.touches || e.touches.length !== 2 || !this._zooming) {
            return;
          }
          var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
          this._zoom = map2.getScaleZoom(scale2, this._startZoom);
          if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale2 < 1 || this._zoom > map2.getMaxZoom() && scale2 > 1)) {
            this._zoom = map2._limitZoom(this._zoom);
          }
          if (map2.options.touchZoom === "center") {
            this._center = this._startLatLng;
            if (scale2 === 1) {
              return;
            }
          } else {
            var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
            if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
              return;
            }
            this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
          }
          if (!this._moved) {
            map2._moveStart(true, false);
            this._moved = true;
          }
          cancelAnimFrame(this._animRequest);
          var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false }, void 0);
          this._animRequest = requestAnimFrame(moveFn, this, true);
          preventDefault(e);
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
          }
          this._zooming = false;
          cancelAnimFrame(this._animRequest);
          off(document, "touchmove", this._onTouchMove, this);
          off(document, "touchend touchcancel", this._onTouchEnd, this);
          if (this._map.options.zoomAnimation) {
            this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
          } else {
            this._map._resetView(this._center, this._map._limitZoom(this._zoom));
          }
        }
      });
      Map.addInitHook("addHandler", "touchZoom", TouchZoom);
      Map.BoxZoom = BoxZoom;
      Map.DoubleClickZoom = DoubleClickZoom;
      Map.Drag = Drag;
      Map.Keyboard = Keyboard;
      Map.ScrollWheelZoom = ScrollWheelZoom;
      Map.TapHold = TapHold;
      Map.TouchZoom = TouchZoom;
      exports2.Bounds = Bounds;
      exports2.Browser = Browser;
      exports2.CRS = CRS;
      exports2.Canvas = Canvas;
      exports2.Circle = Circle;
      exports2.CircleMarker = CircleMarker;
      exports2.Class = Class;
      exports2.Control = Control;
      exports2.DivIcon = DivIcon;
      exports2.DivOverlay = DivOverlay;
      exports2.DomEvent = DomEvent;
      exports2.DomUtil = DomUtil;
      exports2.Draggable = Draggable;
      exports2.Evented = Evented;
      exports2.FeatureGroup = FeatureGroup;
      exports2.GeoJSON = GeoJSON;
      exports2.GridLayer = GridLayer;
      exports2.Handler = Handler;
      exports2.Icon = Icon;
      exports2.ImageOverlay = ImageOverlay;
      exports2.LatLng = LatLng2;
      exports2.LatLngBounds = LatLngBounds;
      exports2.Layer = Layer;
      exports2.LayerGroup = LayerGroup;
      exports2.LineUtil = LineUtil;
      exports2.Map = Map;
      exports2.Marker = Marker;
      exports2.Mixin = Mixin;
      exports2.Path = Path;
      exports2.Point = Point;
      exports2.PolyUtil = PolyUtil;
      exports2.Polygon = Polygon;
      exports2.Polyline = Polyline;
      exports2.Popup = Popup;
      exports2.PosAnimation = PosAnimation;
      exports2.Projection = index;
      exports2.Rectangle = Rectangle;
      exports2.Renderer = Renderer;
      exports2.SVG = SVG;
      exports2.SVGOverlay = SVGOverlay;
      exports2.TileLayer = TileLayer;
      exports2.Tooltip = Tooltip;
      exports2.Transformation = Transformation;
      exports2.Util = Util;
      exports2.VideoOverlay = VideoOverlay;
      exports2.bind = bind;
      exports2.bounds = toBounds;
      exports2.canvas = canvas;
      exports2.circle = circle;
      exports2.circleMarker = circleMarker;
      exports2.control = control;
      exports2.divIcon = divIcon2;
      exports2.extend = extend;
      exports2.featureGroup = featureGroup;
      exports2.geoJSON = geoJSON;
      exports2.geoJson = geoJson;
      exports2.gridLayer = gridLayer;
      exports2.icon = icon;
      exports2.imageOverlay = imageOverlay;
      exports2.latLng = toLatLng;
      exports2.latLngBounds = toLatLngBounds;
      exports2.layerGroup = layerGroup;
      exports2.map = createMap;
      exports2.marker = marker2;
      exports2.point = toPoint;
      exports2.polygon = polygon;
      exports2.polyline = polyline;
      exports2.popup = popup;
      exports2.rectangle = rectangle;
      exports2.setOptions = setOptions;
      exports2.stamp = stamp;
      exports2.svg = svg;
      exports2.svgOverlay = svgOverlay;
      exports2.tileLayer = tileLayer2;
      exports2.tooltip = tooltip;
      exports2.transformation = toTransformation;
      exports2.version = version;
      exports2.videoOverlay = videoOverlay;
      var oldL = window.L;
      exports2.noConflict = function() {
        window.L = oldL;
        return this;
      };
      window.L = exports2;
    });
  }
});

// resources/js/index.js
var L2 = __toESM(require_leaflet_src(), 1);

// node_modules/leaflet-fullscreen/dist/Leaflet.fullscreen.js
L.Control.Fullscreen = L.Control.extend({
  options: {
    position: "topleft",
    title: {
      "false": "View Fullscreen",
      "true": "Exit Fullscreen"
    }
  },
  onAdd: function(map2) {
    var container = L.DomUtil.create("div", "leaflet-control-fullscreen leaflet-bar leaflet-control");
    this.link = L.DomUtil.create("a", "leaflet-control-fullscreen-button leaflet-bar-part", container);
    this.link.href = "#";
    this._map = map2;
    this._map.on("fullscreenchange", this._toggleTitle, this);
    this._toggleTitle();
    L.DomEvent.on(this.link, "click", this._click, this);
    return container;
  },
  _click: function(e) {
    L.DomEvent.stopPropagation(e);
    L.DomEvent.preventDefault(e);
    this._map.toggleFullscreen(this.options);
  },
  _toggleTitle: function() {
    this.link.title = this.options.title[this._map.isFullscreen()];
  }
});
L.Map.include({
  isFullscreen: function() {
    return this._isFullscreen || false;
  },
  toggleFullscreen: function(options) {
    var container = this.getContainer();
    if (this.isFullscreen()) {
      if (options && options.pseudoFullscreen) {
        this._disablePseudoFullscreen(container);
      } else if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      } else {
        this._disablePseudoFullscreen(container);
      }
    } else {
      if (options && options.pseudoFullscreen) {
        this._enablePseudoFullscreen(container);
      } else if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else {
        this._enablePseudoFullscreen(container);
      }
    }
  },
  _enablePseudoFullscreen: function(container) {
    L.DomUtil.addClass(container, "leaflet-pseudo-fullscreen");
    this._setFullscreen(true);
    this.fire("fullscreenchange");
  },
  _disablePseudoFullscreen: function(container) {
    L.DomUtil.removeClass(container, "leaflet-pseudo-fullscreen");
    this._setFullscreen(false);
    this.fire("fullscreenchange");
  },
  _setFullscreen: function(fullscreen) {
    this._isFullscreen = fullscreen;
    var container = this.getContainer();
    if (fullscreen) {
      L.DomUtil.addClass(container, "leaflet-fullscreen-on");
    } else {
      L.DomUtil.removeClass(container, "leaflet-fullscreen-on");
    }
    this.invalidateSize();
  },
  _onFullscreenChange: function(e) {
    var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
    if (fullscreenElement === this.getContainer() && !this._isFullscreen) {
      this._setFullscreen(true);
      this.fire("fullscreenchange");
    } else if (fullscreenElement !== this.getContainer() && this._isFullscreen) {
      this._setFullscreen(false);
      this.fire("fullscreenchange");
    }
  }
});
L.Map.mergeOptions({
  fullscreenControl: false
});
L.Map.addInitHook(function() {
  if (this.options.fullscreenControl) {
    this.fullscreenControl = new L.Control.Fullscreen(this.options.fullscreenControl);
    this.addControl(this.fullscreenControl);
  }
  var fullscreenchange;
  if ("onfullscreenchange" in document) {
    fullscreenchange = "fullscreenchange";
  } else if ("onmozfullscreenchange" in document) {
    fullscreenchange = "mozfullscreenchange";
  } else if ("onwebkitfullscreenchange" in document) {
    fullscreenchange = "webkitfullscreenchange";
  } else if ("onmsfullscreenchange" in document) {
    fullscreenchange = "MSFullscreenChange";
  }
  if (fullscreenchange) {
    var onFullscreenChange = L.bind(this._onFullscreenChange, this);
    this.whenReady(function() {
      L.DomEvent.on(document, fullscreenchange, onFullscreenChange);
    });
    this.on("unload", function() {
      L.DomEvent.off(document, fullscreenchange, onFullscreenChange);
    });
  }
});
L.control.fullscreen = function(options) {
  return new L.Control.Fullscreen(options);
};

// resources/js/index.js
document.addEventListener("DOMContentLoaded", () => {
  const mapPicker = ($wire, config, state) => {
    return {
      map: null,
      tile: null,
      marker: null,
      createMap: function(el) {
        const that = this;
        this.map = L2.map(el, config.controls);
        this.map.on("load", () => {
          setTimeout(() => this.map.invalidateSize(true), 0);
          if (config.showMarker) {
            this.marker.setLatLng(this.map.getCenter());
          }
        });
        if (!config.draggable) {
          this.map.dragging.disable();
        }
        this.tile = L2.tileLayer(config.tilesUrl, {
          attribution: config.attribution,
          minZoom: config.minZoom,
          maxZoom: config.maxZoom,
          tileSize: config.tileSize,
          zoomOffset: config.zoomOffset,
          detectRetina: config.detectRetina
        }).addTo(this.map);
        if (config.showMarker) {
          const markerColor = config.markerColor || "#3b82f6";
          const svgIcon = L2.divIcon({
            html: `<svg xmlns="http://www.w3.org/2000/svg" class="map-icon" fill="${markerColor}" width="36" height="36" viewBox="0 0 24 24"><path d="M12 0c-4.198 0-8 3.403-8 7.602 0 4.198 3.469 9.21 8 16.398 4.531-7.188 8-12.2 8-16.398 0-4.199-3.801-7.602-8-7.602zm0 11c-1.657 0-3-1.343-3-3s1.343-3 3-3 3 1.343 3 3-1.343 3-3 3z"/></svg>`,
            className: "",
            iconSize: [36, 36],
            iconAnchor: [18, 36]
          });
          this.marker = L2.marker([0, 0], {
            icon: svgIcon,
            draggable: false,
            autoPan: true
          }).addTo(this.map);
          this.map.on("move", () => this.marker.setLatLng(this.map.getCenter()));
        }
        this.map.on("moveend", () => setTimeout(() => this.updateLocation(), 500));
        this.map.on("locationfound", function() {
          that.map.setZoom(config.controls.zoom);
        });
        let location = state ?? this.getCoordinates();
        if (!location.lat && !location.lng) {
          this.map.locate({
            setView: true,
            maxZoom: config.controls.maxZoom,
            enableHighAccuracy: true,
            watch: false
            // this can be used to update the map in real time but works kinda weird
          });
        } else {
          this.map.setView(new L2.LatLng(location.lat, location.lng));
        }
        if (config.showMyLocationButton) {
          this.addLocationButton();
        }
        if (config.liveLocation.send && config.liveLocation.realtime) {
          setInterval(() => {
            this.fetchCurrentLocation();
          }, config.liveLocation.miliseconds);
        }
      },
      updateLocation: function() {
        let coordinates = this.getCoordinates();
        let currentCenter = this.map.getCenter();
        if (
          //config.draggable && 
          coordinates.lng !== currentCenter.lng || coordinates.lat !== currentCenter.lat
        ) {
          $wire.set(config.statePath, this.map.getCenter(), false);
          if (config.liveLocation.send) {
            $wire.$refresh();
          }
        }
      },
      removeMap: function(el) {
        if (this.marker) {
          this.marker.remove();
          this.marker = null;
        }
        this.tile.remove();
        this.tile = null;
        this.map.off();
        this.map.remove();
        this.map = null;
      },
      getCoordinates: function() {
        let location = $wire.get(config.statePath) ?? {};
        const hasValidCoordinates = location.hasOwnProperty("lat") && location.hasOwnProperty("lng") && location.lat !== null && location.lng !== null;
        if (!hasValidCoordinates) {
          location = {
            lat: config.default.lat,
            lng: config.default.lng
          };
        }
        return location;
      },
      attach: function(el) {
        this.createMap(el);
        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.intersectionRatio > 0) {
              if (!this.map)
                this.createMap(el);
            } else {
              this.removeMap(el);
            }
          });
        }, {
          root: null,
          rootMargin: "0px",
          threshold: 1
        });
        observer.observe(el);
      },
      fetchCurrentLocation: function() {
        if ("geolocation" in navigator) {
          navigator.geolocation.getCurrentPosition(async (position) => {
            const currentPosition = new L2.LatLng(position.coords.latitude, position.coords.longitude);
            await this.map.flyTo(currentPosition);
            this.updateLocation();
            this.updateMarker();
          }, (error) => {
            console.error("Error fetching current location:", error);
          });
        } else {
          alert("Geolocation is not supported by this browser.");
        }
      },
      addLocationButton: function() {
        const locationButton = document.createElement("button");
        locationButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="currentColor" d="M12 0C8.25 0 5 3.25 5 7c0 5.25 7 13 7 13s7-7.75 7-13c0-3.75-3.25-7-7-7zm0 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm0-5c-1.11 0-2 .89-2 2s.89 2 2 2 2-.89 2-2-.89-2-2-2z"/></svg>';
        locationButton.type = "button";
        locationButton.classList.add("map-location-button");
        locationButton.onclick = () => this.fetchCurrentLocation();
        this.map.getContainer().appendChild(locationButton);
      },
      init: function() {
        this.$wire = $wire;
        this.config = config;
        this.state = state;
        $wire.on("refreshMap", this.refreshMap.bind(this));
      },
      updateMarker: function() {
        if (config.showMarker) {
          this.marker.setLatLng(this.getCoordinates());
          setTimeout(() => this.updateLocation(), 500);
        }
      },
      refreshMap: function() {
        this.map.flyTo(this.getCoordinates());
        this.updateMarker();
      }
    };
  };
  window.mapPicker = mapPicker;
  window.dispatchEvent(new CustomEvent("map-script-loaded"));
});
/*! Bundled license information:

leaflet/dist/leaflet-src.js:
  (* @preserve
   * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
   * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvVXRpbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9DbGFzcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9FdmVudHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L1BvaW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Cb3VuZHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9MYXRMbmdCb3VuZHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9MYXRMbmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FYXJ0aC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQnJvd3Nlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZG9tL0RvbUV2ZW50LlBvaW50ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21VdGlsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tRXZlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Qb3NBbmltYXRpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9NYXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0hhbmRsZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9EcmFnZ2FibGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L1BvbHlVdGlsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9MaW5lVXRpbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyR3JvdXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0dlb0pTT04uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9TVkdPdmVybGF5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9EaXZPdmVybGF5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9Qb3B1cC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVG9vbHRpcC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLkJveFpvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5UYXBIb2xkLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuVG91Y2hab29tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaW5kZXguanMiLCAiLi4vanMvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQtZnVsbHNjcmVlbi9kaXN0L0xlYWZsZXQuZnVsbHNjcmVlbi5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuZXhwb3J0IHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5leHBvcnQgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHRpZiAoISgnX2xlYWZsZXRfaWQnIGluIG9iaikpIHtcclxuXHRcdG9ialsnX2xlYWZsZXRfaWQnXSA9ICsrbGFzdElkO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHdpdGggc3BlY2lmaWVkIGBwcmVjaXNpb25gLlxyXG4vLyBUaGUgZGVmYXVsdCBgcHJlY2lzaW9uYCB2YWx1ZSBpcyA2IGRlY2ltYWwgcGxhY2VzLlxyXG4vLyBgZmFsc2VgIGNhbiBiZSBwYXNzZWQgdG8gc2tpcCBhbnkgcHJvY2Vzc2luZyAoY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCByb3VuZC1vZmYgZXJyb3JzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIHByZWNpc2lvbikge1xyXG5cdGlmIChwcmVjaXNpb24gPT09IGZhbHNlKSB7IHJldHVybiBudW07IH1cclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNiA6IHByZWNpc2lvbik7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKHN0cikge1xyXG5cdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbi8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcblx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcblx0aWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfIC1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5leHBvcnQgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwczovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbmZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxufVxyXG5cclxudmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG5leHBvcnQgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuLy8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG4vLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbi8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbi8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcblx0aWYgKGlkKSB7XHJcblx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcyk7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBVdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0VXRpbC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG5cdFx0VXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdFV0aWwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblx0ZGVsZXRlIHByb3RvLnN0YXRpY3M7XHJcblx0ZGVsZXRlIHByb3RvLmluY2x1ZGVzO1xyXG5cclxuXHQvLyBtZXJnZSBvcHRpb25zXHJcblx0aWYgKHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3RvLm9wdGlvbnMgPSBwYXJlbnRQcm90by5vcHRpb25zID8gVXRpbC5jcmVhdGUocGFyZW50UHJvdG8ub3B0aW9ucykgOiB7fTtcclxuXHRcdFV0aWwuZXh0ZW5kKHByb3RvLm9wdGlvbnMsIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdHZhciBwYXJlbnRPcHRpb25zID0gdGhpcy5wcm90b3R5cGUub3B0aW9ucztcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdGlmIChwcm9wcy5vcHRpb25zKSB7XHJcblx0XHR0aGlzLnByb3RvdHlwZS5vcHRpb25zID0gcGFyZW50T3B0aW9ucztcclxuXHRcdHRoaXMubWVyZ2VPcHRpb25zKHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uczogT2JqZWN0KTogdGhpc1xyXG4vLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbi8vIEFkZHMgYSBbY29uc3RydWN0b3IgaG9va10oI2NsYXNzLWNvbnN0cnVjdG9yLWhvb2tzKSB0byB0aGUgY2xhc3MuXHJcbkNsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdHZhciBpbml0ID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xyXG5cdC8qIGdsb2JhbCBMOiB0cnVlICovXHJcblx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcblx0aW5jbHVkZXMgPSBVdGlsLmlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEV2ZW50ZWRcclxuICogQGFrYSBMLkV2ZW50ZWRcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAqIH0gKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVhbHMgd2l0aCBldmVudCBsaXN0ZW5lcnMgYnkgcmVmZXJlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgYSBsaXN0ZW5lciBhbmQgdGhlbiByZW1vdmUgaXQsIGRlZmluZSBpdCBhcyBhIGZ1bmN0aW9uOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiBvbkNsaWNrKGUpIHsgLi4uIH1cclxuICpcclxuICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBtYXAub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEV2ZW50cyA9IHtcclxuXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgb2YgdGhlIG9iamVjdC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyIChvYmplY3QgdGhlIHRoaXMga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb24oZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0ICovXHJcblx0b246IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcblx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuIFRoaXMgaW5jbHVkZXMgaW1wbGljaXRseSBhdHRhY2hlZCBldmVudHMuXHJcblx0ICovXHJcblx0b2ZmOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdHZhciByZW1vdmVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRpZiAocmVtb3ZlQWxsKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCwgX29uY2UpIHtcclxuXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBsaXN0ZW5lciB0eXBlOiAnICsgdHlwZW9mIGZuKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcclxuXHRcdGlmICh0aGlzLl9saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0KSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9O1xyXG5cdFx0aWYgKF9vbmNlKSB7XHJcblx0XHRcdG5ld0xpc3RlbmVyLm9uY2UgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcclxuXHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKG5ld0xpc3RlbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMsXHJcblx0XHQgICAgaSxcclxuXHRcdCAgICBsZW47XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyAvLyByZW1vdmUgYWxsXHJcblx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcFxyXG5cdFx0XHRcdC8vIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdHZhciBpbmRleCA9IHRoaXMuX2xpc3RlbnModHlwZSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0aWYgKGluZGV4ICE9PSBmYWxzZSkge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaW5kZXhdO1xyXG5cdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0bGlzdGVuZXIuZm4gPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcblx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gVXRpbC5leHRlbmQoe30sIGRhdGEsIHtcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG5cdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0Ly8gb2ZmIG92ZXJ3cml0ZXMgbC5mbiwgc28gd2UgbmVlZCB0byBjb3B5IGZuIHRvIGEgdmFyXHJcblx0XHRcdFx0XHR2YXIgZm4gPSBsLmZuO1xyXG5cdFx0XHRcdFx0aWYgKGwub25jZSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLm9mZih0eXBlLCBmbiwgbC5jdHgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZywgcHJvcGFnYXRlPzogQm9vbGVhbik6IEJvb2xlYW5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcblx0Ly8gVGhlIHZlcmlmaWNhdGlvbiBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkLCBpdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgcGFyZW50cyBoYXZlIHRoZSBsaXN0ZW5lciBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ1wic3RyaW5nXCIgdHlwZSBhcmd1bWVudCBleHBlY3RlZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgaW5wdXQgYGZuYCB2YWx1ZSwgYmVjYXVzZSB3ZSBuZWVkIHRvIHVzZSBpdCBmb3IgcHJvcGFnYXRpb25cclxuXHRcdHZhciBfZm4gPSBmbjtcclxuXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0cHJvcGFnYXRlID0gISFmbjtcclxuXHRcdFx0X2ZuID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7XHJcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5zKHR5cGUsIF9mbiwgY29udGV4dCkgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50c1tpZF0ubGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyB0aGUgaW5kZXggKG51bWJlcikgb3IgZmFsc2VcclxuXHRfbGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0cmV0dXJuICEhbGlzdGVuZXJzLmxlbmd0aDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuIGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbiwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcblx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcblx0XHRcdH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbkV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG5leHBvcnQgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcclxuIiwgImltcG9ydCB7aXNBcnJheSwgZm9ybWF0TnVtfSBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvaW50XHJcbiAqIEBha2EgTC5Qb2ludFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcbnZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcblx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcblx0fSxcclxuXHJcblx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuIiwgImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEJvdW5kc1xyXG4gKiBAYWthIEwuQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kcyB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIG1pbjIsIG1heDI7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBQb2ludCB8fCB0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCAneCcgaW4gb2JqKSB7XHJcblx0XHRcdG1pbjIgPSBtYXgyID0gdG9Qb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuXHRcdFx0bWluMiA9IG9iai5taW47XHJcblx0XHRcdG1heDIgPSBvYmoubWF4O1xyXG5cclxuXHRcdFx0aWYgKCFtaW4yIHx8ICFtYXgyKSB7IHJldHVybiB0aGlzOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcclxuXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtYXg6IFBvaW50XHJcblx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuXHRcdFx0dGhpcy5taW4gPSBtaW4yLmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gbWF4Mi5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKG1pbjIueCwgdGhpcy5taW4ueCk7XHJcblx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChtYXgyLngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4obWluMi55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KG1heDIueSwgdGhpcy5tYXgueSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcihyb3VuZD86IEJvb2xlYW4pOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKHJvdW5kKSB7XHJcblx0XHRyZXR1cm4gdG9Qb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1pbmBdKCNib3VuZHMtbWluKSkuXHJcblx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWluOyAvLyBsZWZ0LCB0b3BcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1heGBdKCNib3VuZHMtbWF4KSkuXHJcblx0Z2V0Qm90dG9tUmlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKHBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcblx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG5cdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHRtYXggPSB0aGlzLm1heCxcclxuXHRcdGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKG1pbi54IC0gbWF4LngpICogYnVmZmVyUmF0aW8sXHJcblx0XHR3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKG1pbi55IC0gbWF4LnkpICogYnVmZmVyUmF0aW87XHJcblxyXG5cclxuXHRcdHJldHVybiB0b0JvdW5kcyhcclxuXHRcdFx0dG9Qb2ludChtaW4ueCAtIGhlaWdodEJ1ZmZlciwgbWluLnkgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHRcdHRvUG9pbnQobWF4LnggKyBoZWlnaHRCdWZmZXIsIG1heC55ICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIGJvdW5kcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWluLmVxdWFscyhib3VuZHMuZ2V0VG9wTGVmdCgpKSAmJlxyXG5cdFx0XHR0aGlzLm1heC5lcXVhbHMoYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkpO1xyXG5cdH0sXHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsICJpbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4vTGF0TG5nJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICogQGFrYSBMLkxhdExuZ0JvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBjb3JuZXIxID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICogY29ybmVyMiA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmdCb3VuZHMgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5maXRCb3VuZHMoW1xyXG4gKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAqIF0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQ2F1dGlvbjogaWYgdGhlIGFyZWEgY3Jvc3NlcyB0aGUgYW50aW1lcmlkaWFuIChvZnRlbiBjb25mdXNlZCB3aXRoIHRoZSBJbnRlcm5hdGlvbmFsIERhdGUgTGluZSksIHlvdSBtdXN0IHNwZWNpZnkgY29ybmVycyBfb3V0c2lkZV8gdGhlIFstMTgwLCAxODBdIGRlZ3JlZXMgbG9uZ2l0dWRlIHJhbmdlLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYExhdExuZ0JvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gY29ybmVyMiA/IFtjb3JuZXIxLCBjb3JuZXIyXSA6IGNvcm5lcjE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0XHRzdzIgPSBvYmo7XHJcblx0XHRcdG5lMiA9IG9iajtcclxuXHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcblx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG5cdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG5cdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG5cdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIExhdExuZyB8fCAnbGF0JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcblx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vY3JzL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcbiIsICJcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5CYXNlXHJcbiAqIE9iamVjdCB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gKiBjb29yZGluYXRlcyBpbiBvdGhlciB1bml0cyBmb3IgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuIFNlZVxyXG4gKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGF0aWFsX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIENSUyBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG5cdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ0JvdW5kc2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXHJcblx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuXHRcdGlmIChsYXRTaGlmdCA9PT0gMCAmJiBsbmdTaGlmdCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuXHRcdCAgICBuZXdOZSA9IG5ldyBMYXRMbmcobmUubGF0IC0gbGF0U2hpZnQsIG5lLmxuZyAtIGxuZ1NoaWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG5cdH1cclxufTtcclxuIiwgImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5FYXJ0aFxuICpcbiAqIFNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgQ1JTIHRoYXQgYXJlIGdsb2JhbCBzdWNoIHRoYXQgdGhleSBjb3ZlciB0aGUgZWFydGguXG4gKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBtZXRlcnMuXG4gKi9cblxuZXhwb3J0IHZhciBFYXJ0aCA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcblx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcblx0Ly8gc2VlIGh0dHBzOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG5cdFx0ICAgIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBzaW5ETG9uICogc2luRExvbixcblx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG5cdH1cbn0pO1xuIiwgImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxudmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbmV4cG9ydCB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IGVhcnRoUmFkaXVzLFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcbiIsICJpbXBvcnQge1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXHJcbiAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjogYSBzZXQgb2YgY29lZmZpY2llbnRzIGBhYCwgYGJgLCBgY2AsIGBkYFxyXG4gKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IEwudHJhbnNmb3JtYXRpb24oMiwgNSwgLTEsIDEwKSxcclxuICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICogXHRwMiA9IHRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShwKSwgLy8gIEwucG9pbnQoNywgOClcclxuICogXHRwMyA9IHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHAyKTsgLy8gIEwucG9pbnQoMSwgMilcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgbmV3IEwuVHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkpIHtcclxuXHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXHJcblx0XHR0aGlzLl9hID0gYVswXTtcclxuXHRcdHRoaXMuX2IgPSBhWzFdO1xyXG5cdFx0dGhpcy5fYyA9IGFbMl07XHJcblx0XHR0aGlzLl9kID0gYVszXTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn1cclxuXHJcblRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIHRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcblx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gUG9pbnRcclxuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRlc3RydWN0aXZlIHRyYW5zZm9ybSAoZmFzdGVyKVxyXG5cdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHBvaW50LnggPSBzY2FsZSAqICh0aGlzLl9hICogcG9pbnQueCArIHRoaXMuX2IpO1xyXG5cdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcblx0Ly8gYnkgdGhlIGdpdmVuIHNjYWxlLiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcblx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gSW5zdGFudGlhdGVzIGEgVHJhbnNmb3JtYXRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGNvZWZmaWNpZW50czogQXJyYXkpOiBUcmFuc2Zvcm1hdGlvblxyXG4vLyBFeHBlY3RzIGFuIGNvZWZmaWNpZW50cyBhcnJheSBvZiB0aGUgZm9ybVxyXG4vLyBgW2E6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcl1gLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbn1cclxuIiwgImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHMzg1NyA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgRVBTRzkwMDkxMyA9IFV0aWwuZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcbiIsICJpbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbi8vIEBmdW5jdGlvbiBjcmVhdGUobmFtZTogU3RyaW5nKTogU1ZHRWxlbWVudFxuLy8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG4vLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuLy8gYW4gaW5zdGFuY2Ugb2YgW1NWR0xpbmVFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHTGluZUVsZW1lbnQpLlxuZXhwb3J0IGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuLy8gR2VuZXJhdGVzIGEgU1ZHIHBhdGggc3RyaW5nIGZvciBtdWx0aXBsZSByaW5ncywgd2l0aCBlYWNoIHJpbmcgdHVybmluZ1xuLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG5cdHZhciBzdHIgPSAnJyxcblx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRwID0gcG9pbnRzW2pdO1xuXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHR9XG5cblx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG5cdFx0c3RyICs9IGNsb3NlZCA/IChCcm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0fVxuXG5cdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdHJldHVybiBzdHIgfHwgJ00wIDAnO1xufVxuXG5cblxuXG4iLCAiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5pbXBvcnQge3N2Z0NyZWF0ZX0gZnJvbSAnLi4vbGF5ZXIvdmVjdG9yL1NWRy5VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gKiBAYWthIEwuQnJvd3NlclxyXG4gKlxyXG4gKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxudmFyIGllID0gJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdztcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhbjsgYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxudmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4vLyBAcHJvcGVydHkgZWRnZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgRWRnZSB3ZWIgYnJvd3Nlci5cclxudmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbi8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG52YXIgd2Via2l0ID0gdXNlckFnZW50Q29udGFpbnMoJ3dlYmtpdCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuLy8gKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG52YXIgYW5kcm9pZCA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbnZhciBhbmRyb2lkMjMgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAyJykgfHwgdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMycpO1xyXG5cclxuLyogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzk2MTI2NiBmb3IgZGV0YWlscyBvbiBkZXRlY3Rpbmcgc3RvY2sgQW5kcm9pZCAqL1xyXG52YXIgd2Via2l0VmVyID0gcGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKTsgLy8gYWxzbyBtYXRjaGVzIEFwcGxlV2ViS2l0XHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkU3RvY2s6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIHRoZSBBbmRyb2lkIHN0b2NrIGJyb3dzZXIgKGkuZS4gbm90IENocm9tZSlcclxudmFyIGFuZHJvaWRTdG9jayA9IGFuZHJvaWQgJiYgdXNlckFnZW50Q29udGFpbnMoJ0dvb2dsZScpICYmIHdlYmtpdFZlciA8IDUzNyAmJiAhKCdBdWRpb05vZGUnIGluIHdpbmRvdyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXJcclxudmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxudmFyIGNocm9tZSA9ICFlZGdlICYmIHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbnZhciBnZWNrbyA9IHVzZXJBZ2VudENvbnRhaW5zKCdnZWNrbycpICYmICF3ZWJraXQgJiYgIW9wZXJhICYmICFpZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG52YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XHJcblxyXG52YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG52YXIgb3BlcmExMiA9ICdPVHJhbnNpdGlvbicgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG52YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW47IGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzO1xyXG5cclxuLy8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGdlY2tvM2QgPSAnTW96UGVyc3BlY3RpdmUnIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQ6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxudmFyIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3BvaW50ZXIgZXZlbnRzXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQ0JTI4dj12cy44NSUyOS5hc3B4KS5cclxudmFyIHBvaW50ZXIgPSAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcik7XHJcblxyXG4vLyBAcHJvcGVydHkgdG91Y2hOYXRpdmU6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbdG91Y2ggZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVG91Y2hfZXZlbnRzKS5cclxuLy8gKipUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4qKiB0aGF0IHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBjb21wdXRlciB3aXRoXHJcbi8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuLy8gdG91Y2ggZXZlbnRzLlxyXG52YXIgdG91Y2hOYXRpdmUgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgISF3aW5kb3cuVG91Y2hFdmVudDtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIGVpdGhlciBbdG91Y2hdKCNicm93c2VyLXRvdWNoKSBvciBbcG9pbnRlcl0oI2Jyb3dzZXItcG9pbnRlcikgZXZlbnRzLlxyXG4vLyBOb3RlOiBwb2ludGVyIGV2ZW50cyB3aWxsIGJlIHByZWZlcnJlZCAoaWYgYXZhaWxhYmxlKSwgYW5kIHByb2Nlc3NlZCBmb3IgYWxsIGB0b3VjaCpgIGxpc3RlbmVycy5cclxudmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmICh0b3VjaE5hdGl2ZSB8fCBwb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVPcGVyYSA9IG1vYmlsZSAmJiBvcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4vLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4gb3Igb24gYW55IHNjcmVlbiB3aGVuIGJyb3dzZXIncyBkaXNwbGF5IHpvb20gaXMgbW9yZSB0aGFuIDEwMCUuXHJcbnZhciByZXRpbmEgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDE7XHJcblxyXG4vLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBwYXNzaXZlIGV2ZW50cy5cclxudmFyIHBhc3NpdmVFdmVudHMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuXHR0cnkge1xyXG5cdFx0dmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXHJcblx0XHRcdFx0c3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBFcnJvcnMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIHNpbmNlIHRoaXMgaXMgb25seSBhIGJyb3dzZXIgc3VwcG9ydCB0ZXN0LlxyXG5cdH1cclxuXHRyZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uO1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxyXG52YXIgY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG52YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG52YXIgaW5saW5lU3ZnID0gISFzdmcgJiYgKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ZGl2LmlubmVySFRNTCA9ICc8c3ZnLz4nO1xyXG5cdHJldHVybiAoZGl2LmZpcnN0Q2hpbGQgJiYgZGl2LmZpcnN0Q2hpbGQubmFtZXNwYWNlVVJJKSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxufSkoKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB2bWw6IEJvb2xlYW5cclxuLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxyXG52YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcblxyXG4vLyBAcHJvcGVydHkgbWFjOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgTWFjIHBsYXRmb3JtXHJcbnZhciBtYWMgPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTWFjJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgbWFjOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgTGludXggcGxhdGZvcm1cclxudmFyIGxpbnV4ID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ0xpbnV4JykgPT09IDA7XHJcblxyXG5mdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGllOiBpZSxcclxuXHRpZWx0OTogaWVsdDksXHJcblx0ZWRnZTogZWRnZSxcclxuXHR3ZWJraXQ6IHdlYmtpdCxcclxuXHRhbmRyb2lkOiBhbmRyb2lkLFxyXG5cdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG5cdGFuZHJvaWRTdG9jazogYW5kcm9pZFN0b2NrLFxyXG5cdG9wZXJhOiBvcGVyYSxcclxuXHRjaHJvbWU6IGNocm9tZSxcclxuXHRnZWNrbzogZ2Vja28sXHJcblx0c2FmYXJpOiBzYWZhcmksXHJcblx0cGhhbnRvbTogcGhhbnRvbSxcclxuXHRvcGVyYTEyOiBvcGVyYTEyLFxyXG5cdHdpbjogd2luLFxyXG5cdGllM2Q6IGllM2QsXHJcblx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG5cdGdlY2tvM2Q6IGdlY2tvM2QsXHJcblx0YW55M2Q6IGFueTNkLFxyXG5cdG1vYmlsZTogbW9iaWxlLFxyXG5cdG1vYmlsZVdlYmtpdDogbW9iaWxlV2Via2l0LFxyXG5cdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGVXZWJraXQzZCxcclxuXHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuXHRwb2ludGVyOiBwb2ludGVyLFxyXG5cdHRvdWNoOiB0b3VjaCxcclxuXHR0b3VjaE5hdGl2ZTogdG91Y2hOYXRpdmUsXHJcblx0bW9iaWxlT3BlcmE6IG1vYmlsZU9wZXJhLFxyXG5cdG1vYmlsZUdlY2tvOiBtb2JpbGVHZWNrbyxcclxuXHRyZXRpbmE6IHJldGluYSxcclxuXHRwYXNzaXZlRXZlbnRzOiBwYXNzaXZlRXZlbnRzLFxyXG5cdGNhbnZhczogY2FudmFzLFxyXG5cdHN2Zzogc3ZnLFxyXG5cdHZtbDogdm1sLFxyXG5cdGlubGluZVN2ZzogaW5saW5lU3ZnLFxyXG5cdG1hYzogbWFjLFxyXG5cdGxpbnV4OiBsaW51eFxyXG59O1xyXG4iLCAiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtmYWxzZUZufSBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG52YXIgUE9JTlRFUl9ET1dOID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyAgIDogJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX01PVkUgPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnO1xudmFyIFBPSU5URVJfVVAgPSAgICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xudmFyIFBPSU5URVJfQ0FOQ0VMID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJztcbnZhciBwRXZlbnQgPSB7XG5cdHRvdWNoc3RhcnQgIDogUE9JTlRFUl9ET1dOLFxuXHR0b3VjaG1vdmUgICA6IFBPSU5URVJfTU9WRSxcblx0dG91Y2hlbmQgICAgOiBQT0lOVEVSX1VQLFxuXHR0b3VjaGNhbmNlbCA6IFBPSU5URVJfQ0FOQ0VMXG59O1xudmFyIGhhbmRsZSA9IHtcblx0dG91Y2hzdGFydCAgOiBfb25Qb2ludGVyU3RhcnQsXG5cdHRvdWNobW92ZSAgIDogX2hhbmRsZVBvaW50ZXIsXG5cdHRvdWNoZW5kICAgIDogX2hhbmRsZVBvaW50ZXIsXG5cdHRvdWNoY2FuY2VsIDogX2hhbmRsZVBvaW50ZXJcbn07XG52YXIgX3BvaW50ZXJzID0ge307XG52YXIgX3BvaW50ZXJEb2NMaXN0ZW5lciA9IGZhbHNlO1xuXG4vLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG4vLyByZWYgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpIHtcblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKTtcblx0fVxuXHRpZiAoIWhhbmRsZVt0eXBlXSkge1xuXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuXHRcdHJldHVybiBmYWxzZUZuO1xuXHR9XG5cdGhhbmRsZXIgPSBoYW5kbGVbdHlwZV0uYmluZCh0aGlzLCBoYW5kbGVyKTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG5cdHJldHVybiBoYW5kbGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuXHRpZiAoIXBFdmVudFt0eXBlXSkge1xuXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuXHRcdHJldHVybjtcblx0fVxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJEb3duKGUpIHtcblx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyTW92ZShlKSB7XG5cdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG5cdFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJVcChlKSB7XG5cdGRlbGV0ZSBfcG9pbnRlcnNbZS5wb2ludGVySWRdO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCkge1xuXHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cblx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKSB7XG5cdGlmIChlLnBvaW50ZXJUeXBlID09PSAoZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCAnbW91c2UnKSkgeyByZXR1cm47IH1cblxuXHRlLnRvdWNoZXMgPSBbXTtcblx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcblx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuXHR9XG5cdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0aGFuZGxlcihlKTtcbn1cblxuZnVuY3Rpb24gX29uUG9pbnRlclN0YXJ0KGhhbmRsZXIsIGUpIHtcblx0Ly8gSUUxMCBzcGVjaWZpYzogTXNUb3VjaCBuZWVkcyBwcmV2ZW50RGVmYXVsdC4gU2VlICMyMDAwXG5cdGlmIChlLk1TUE9JTlRFUl9UWVBFX1RPVUNIICYmIGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0gpIHtcblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fVxuXHRfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICpcclxuICogTm90ZTogY3VycmVudGx5IG1vc3QgYnJvd3NlcnMgZmlyZSBuYXRpdmUgZGJsY2xpY2ssIHdpdGggb25seSBhIGZldyBleGNlcHRpb25zXHJcbiAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNzAxMiNpc3N1ZWNvbW1lbnQtNTk1MDg3Mzg2KVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1ha2VEYmxjbGljayhldmVudCkge1xyXG5cdC8vIGluIG1vZGVybiBicm93c2VycyBgdHlwZWAgY2Fubm90IGJlIGp1c3Qgb3ZlcnJpZGRlbjpcclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHlcclxuXHR2YXIgbmV3RXZlbnQgPSB7fSxcclxuXHQgICAgcHJvcCwgaTtcclxuXHRmb3IgKGkgaW4gZXZlbnQpIHtcclxuXHRcdHByb3AgPSBldmVudFtpXTtcclxuXHRcdG5ld0V2ZW50W2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQoZXZlbnQpIDogcHJvcDtcclxuXHR9XHJcblx0ZXZlbnQgPSBuZXdFdmVudDtcclxuXHRuZXdFdmVudC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRuZXdFdmVudC5kZXRhaWwgPSAyO1xyXG5cdG5ld0V2ZW50LmlzVHJ1c3RlZCA9IGZhbHNlO1xyXG5cdG5ld0V2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlOyAvLyBmb3IgZGVidWcgcHVycG9zZXNcclxuXHRyZXR1cm4gbmV3RXZlbnQ7XHJcbn1cclxuXHJcbnZhciBkZWxheSA9IDIwMDtcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcikge1xyXG5cdC8vIE1vc3QgYnJvd3NlcnMgaGFuZGxlIGRvdWJsZSB0YXAgbmF0aXZlbHlcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIG5hdGl2ZSBkYmxjbGlja3MgZm9yIHRvdWNoIGV2ZW50cy5cclxuXHQvLyBJdCBzZWVtcyB0aGF0IGluIGFsbCBzdWNoIGNhc2VzIGBkZXRhaWxgIHByb3BlcnR5IG9mIGBjbGlja2AgZXZlbnQgaXMgYWx3YXlzIGAxYC5cclxuXHQvLyBTbyBoZXJlIHdlIHJlbHkgb24gdGhhdCBmYWN0IHRvIGF2b2lkIGV4Y2Vzc2l2ZSAnZGJsY2xpY2snIHNpbXVsYXRpb24gd2hlbiBub3QgbmVlZGVkLlxyXG5cdHZhciBsYXN0ID0gMCxcclxuXHQgICAgZGV0YWlsO1xyXG5cdGZ1bmN0aW9uIHNpbURibGNsaWNrKGUpIHtcclxuXHRcdGlmIChlLmRldGFpbCAhPT0gMSkge1xyXG5cdFx0XHRkZXRhaWwgPSBlLmRldGFpbDsgLy8ga2VlcCBpbiBzeW5jIHRvIGF2b2lkIGZhbHNlIGRibGNsaWNrIGluIHNvbWUgY2FzZXNcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XHJcblx0XHRcdChlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiAhZS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykpIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXaGVuIGNsaWNraW5nIG9uIGFuIDxpbnB1dD4sIHRoZSBicm93c2VyIGdlbmVyYXRlcyBhIGNsaWNrIG9uIGl0c1xyXG5cdFx0Ly8gPGxhYmVsPiAoYW5kIHZpY2UgdmVyc2EpIHRyaWdnZXJpbmcgdHdvIGNsaWNrcyBpbiBxdWljayBzdWNjZXNzaW9uLlxyXG5cdFx0Ly8gVGhpcyBpZ25vcmVzIGNsaWNrcyBvbiBlbGVtZW50cyB3aGljaCBhcmUgYSBsYWJlbCB3aXRoIGEgJ2ZvcidcclxuXHRcdC8vIGF0dHJpYnV0ZSAob3IgY2hpbGRyZW4gb2Ygc3VjaCBhIGxhYmVsKSwgYnV0IG5vdCBjaGlsZHJlbiBvZlxyXG5cdFx0Ly8gYSA8aW5wdXQ+LlxyXG5cdFx0dmFyIHBhdGggPSBEb21FdmVudC5nZXRQcm9wYWdhdGlvblBhdGgoZSk7XHJcblx0XHRpZiAocGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0XHRyZXR1cm4gZWwgaW5zdGFuY2VvZiBIVE1MTGFiZWxFbGVtZW50ICYmIGVsLmF0dHJpYnV0ZXMuZm9yO1xyXG5cdFx0fSkgJiZcclxuXHRcdFx0IXBhdGguc29tZShmdW5jdGlvbiAoZWwpIHtcclxuXHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0ZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8XHJcblx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50XHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSlcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCk7XHJcblx0XHRpZiAobm93IC0gbGFzdCA8PSBkZWxheSkge1xyXG5cdFx0XHRkZXRhaWwrKztcclxuXHRcdFx0aWYgKGRldGFpbCA9PT0gMikge1xyXG5cdFx0XHRcdGhhbmRsZXIobWFrZURibGNsaWNrKGUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGV0YWlsID0gMTtcclxuXHRcdH1cclxuXHRcdGxhc3QgPSBub3c7XHJcblx0fVxyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaW1EYmxjbGljayk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRkYmxjbGljazogaGFuZGxlcixcclxuXHRcdHNpbURibGNsaWNrOiBzaW1EYmxjbGlja1xyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXJzKSB7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcnMuZGJsY2xpY2spO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXJzLnNpbURibGNsaWNrKTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuZXhwb3J0IHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG5cdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4vLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4vLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdGlmIChjb250YWluZXIpIHtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCkge1xyXG5cdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcblx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuXHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0fVxyXG5cdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgY2xhc3NlcyA9IFV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzZXRDbGFzcyhlbCwgVXRpbC50cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcblx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuXHQvLyAoUmVxdWlyZWQgZm9yIGxpbmtlZCBTVkcgZWxlbWVudHMgaW4gSUUxMS4pXHJcblx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcblx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG5cdH1cclxuXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbi8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcblx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcblx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0dHJ5IHtcclxuXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0fVxyXG5cclxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRpZiAoZmlsdGVyKSB7XHJcblx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbi8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbi8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbi8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcblx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcblx0XHQoQnJvd3Nlci5pZTNkID9cclxuXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbi8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbi8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbi8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4vLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4vLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbi8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbmV4cG9ydCB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIF91c2VyU2VsZWN0O1xyXG5pZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSBlbHNlIHtcclxuXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcblx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4vLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbi8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG52YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4vLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4vLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4vLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbi8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRyZXN0b3JlT3V0bGluZSgpO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlO1xyXG5cdGVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlID0gJ25vbmUnO1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlID0gX291dGxpbmVTdHlsZTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB3aGljaCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBpcyBub3QgbnVsbC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcblx0ZG8ge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuXHRyZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4vLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG1lbWJlcnMgYXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGVzIHJlc3BlY3RpdmVseSxcclxuLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XHJcblx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcclxuXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG5cdH07XHJcbn1cclxuIiwgImltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge2FkZFBvaW50ZXJMaXN0ZW5lciwgcmVtb3ZlUG9pbnRlckxpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LlBvaW50ZXInO1xyXG5pbXBvcnQge2FkZERvdWJsZVRhcExpc3RlbmVyLCByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Eb3VibGVUYXAnO1xyXG5pbXBvcnQge2dldFNjYWxlfSBmcm9tICcuL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG4vLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG4vLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG4vLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbmV4cG9ydCBmdW5jdGlvbiBvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZXMgJiYgdHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbi8vIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gb24sIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWVcclxuLy8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIG9mIGdpdmVuIHR5cGVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBmcm9tIGdpdmVuIEhUTUxFbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiBvZmYob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdGJhdGNoUmVtb3ZlKG9iaik7XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblxyXG5cdH0gZWxzZSBpZiAodHlwZXMgJiYgdHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdGJhdGNoUmVtb3ZlKG9iaiwgZnVuY3Rpb24gKHR5cGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gVXRpbC5pbmRleE9mKHR5cGVzLCB0eXBlKSAhPT0gLTE7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhdGNoUmVtb3ZlKG9iaiwgZmlsdGVyRm4pIHtcclxuXHRmb3IgKHZhciBpZCBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0dmFyIHR5cGUgPSBpZC5zcGxpdCgvXFxkLylbMF07XHJcblx0XHRpZiAoIWZpbHRlckZuIHx8IGZpbHRlckZuKHR5cGUpKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIG51bGwsIG51bGwsIGlkKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbnZhciBtb3VzZVN1YnN0ID0ge1xyXG5cdG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxyXG5cdG1vdXNlbGVhdmU6ICdtb3VzZW91dCcsXHJcblx0d2hlZWw6ICEoJ29ud2hlZWwnIGluIHdpbmRvdykgJiYgJ21vdXNld2hlZWwnXHJcbn07XHJcblxyXG5mdW5jdGlvbiBhZGRPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdH07XHJcblxyXG5cdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRpZiAoIUJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG5cdFx0aGFuZGxlciA9IGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcblx0XHRoYW5kbGVyID0gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJyB8fCB0eXBlID09PSAnd2hlZWwnIHx8ICB0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xyXG5cdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRcdFx0aWYgKGlzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG5cdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG9yaWdpbmFsSGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQsIGlkKSB7XHJcblx0aWQgPSBpZCB8fCB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblx0dmFyIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG5cdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRpZiAoIUJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykpIHtcclxuXHRcdHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuLy8gYGBganNcclxuLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4vLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuLy8gfSk7XHJcbi8vIGBgYFxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcblx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcblx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ3doZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsKSB7XHJcblx0YWRkT25lKGVsLCAnd2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RibGNsaWNrJ2AsIGAnY29udGV4dG1lbnUnYCxcclxuLy8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWwpIHtcclxuXHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrIGNvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddID0gdHJ1ZTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG4vLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcbi8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcbi8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xyXG5cdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcChlKSB7XHJcblx0cHJldmVudERlZmF1bHQoZSk7XHJcblx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UHJvcGFnYXRpb25QYXRoKGV2OiBET01FdmVudCk6IEFycmF5XHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtgRXZlbnQuY29tcG9zZWRQYXRoKClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnQvY29tcG9zZWRQYXRoKS5cclxuLy8gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBgSFRNTEVsZW1lbnRgcyB0aGF0IHRoZSBnaXZlbiBET00gZXZlbnRcclxuLy8gc2hvdWxkIHByb3BhZ2F0ZSB0byAoaWYgbm90IHN0b3BwZWQpLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGFnYXRpb25QYXRoKGV2KSB7XHJcblx0aWYgKGV2LmNvbXBvc2VkUGF0aCkge1xyXG5cdFx0cmV0dXJuIGV2LmNvbXBvc2VkUGF0aCgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHBhdGggPSBbXTtcclxuXHR2YXIgZWwgPSBldi50YXJnZXQ7XHJcblxyXG5cdHdoaWxlIChlbCkge1xyXG5cdFx0cGF0aC5wdXNoKGVsKTtcclxuXHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0cmV0dXJuIHBhdGg7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcbi8vIGBjb250YWluZXJgIChib3JkZXIgZXhjbHVkZWQpIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xyXG5cdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHR9XHJcblxyXG5cdHZhciBzY2FsZSA9IGdldFNjYWxlKGNvbnRhaW5lciksXHJcblx0ICAgIG9mZnNldCA9IHNjYWxlLmJvdW5kaW5nQ2xpZW50UmVjdDsgLy8gbGVmdCBhbmQgdG9wICB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgdGhlIGV2ZW50IGNsaWVudFgvWSlcclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdC8vIG9mZnNldC5sZWZ0L3RvcCB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgY2xpZW50WC9ZKSxcclxuXHRcdC8vIHdoZXJlYXMgY2xpZW50TGVmdC9Ub3AgKGJvcmRlciB3aWR0aCkgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgdmFsdWVzIChiZWZvcmUgQ1NTIHNjYWxlIGFwcGxpZXMpLlxyXG5cdFx0KGUuY2xpZW50WCAtIG9mZnNldC5sZWZ0KSAvIHNjYWxlLnggLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuXHRcdChlLmNsaWVudFkgLSBvZmZzZXQudG9wKSAvIHNjYWxlLnkgLSBjb250YWluZXIuY2xpZW50VG9wXHJcblx0KTtcclxufVxyXG5cclxuXHJcbi8vICBleGNlcHQgLCBTYWZhcmkgYW5kXHJcbi8vIFdlIG5lZWQgZG91YmxlIHRoZSBzY3JvbGwgcGl4ZWxzIChzZWUgIzc0MDMgYW5kICM0NTM4KSBmb3IgYWxsIEJyb3dzZXJzXHJcbi8vIGV4Y2VwdCBPU1ggKE1hYykgLT4gM3gsIENocm9tZSBydW5uaW5nIG9uIExpbnV4IDF4XHJcblxyXG52YXIgd2hlZWxQeEZhY3RvciA9XHJcblx0KEJyb3dzZXIubGludXggJiYgQnJvd3Nlci5jaHJvbWUpID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG5cdEJyb3dzZXIubWFjID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gKiAzIDpcclxuXHR3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDAgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG4vLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuLy8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSB3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbi8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4vLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4vLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0ICAgICAgIDA7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuXHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdHRyeSB7XHJcblx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub25gXSgjZG9tZXZlbnQtb24pXHJcbmV4cG9ydCB7b24gYXMgYWRkTGlzdGVuZXJ9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9mZmBdKCNkb21ldmVudC1vZmYpXHJcbmV4cG9ydCB7b2ZmIGFzIHJlbW92ZUxpc3RlbmVyfTtcclxuIiwgImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlQb3NpdGlvbk1hcmtlciA9IEwubWFya2VyKFs0OC44NjQ3MTYsIDIuMjk0Njk0XSkuYWRkVG8obWFwKTtcbiAqXG4gKiBteVBvc2l0aW9uTWFya2VyLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gKiBcdHZhciBwb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KG15UG9zaXRpb25NYXJrZXIuZ2V0TGF0TG5nKCkpO1xuICogXHRwb3MueSAtPSAyNTtcbiAqIFx0dmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKlxuICogXHRmeC5vbmNlKCdlbmQnLGZ1bmN0aW9uKCkge1xuICogXHRcdHBvcy55ICs9IDI1O1xuICogXHRcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuOCk7XG4gKiBcdH0pO1xuICpcbiAqIFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC4zKTtcbiAqIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cHM6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuIiwgImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCB7RVBTRzM4NTd9IGZyb20gJy4uL2dlby9jcnMvQ1JTLkVQU0czODU3JztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge0JvdW5kcywgdG9Cb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1Bvc0FuaW1hdGlvbn0gZnJvbSAnLi4vZG9tL1Bvc0FuaW1hdGlvbic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG5cdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuXHRcdC8vIHRvIGF2b2lkIGluY29uc2lzdGVudCBzdGF0ZSBpbiBzb21lIGVkZ2UgY2FzZXMuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IFV0aWwuYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KHRvTGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IERvbVV0aWwuVFJBTlNJVElPTiAmJiBCcm93c2VyLmFueTNkICYmICFCcm93c2VyLm1vYmlsZU9wZXJhICYmXHJcblx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXHJcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKHRoaXMuX3Byb3h5LCBEb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG5cdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKHRvTGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcblx0XHRcdGlmIChtb3ZlZCkge1xyXG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tLCBvcHRpb25zLnBhbiAmJiBvcHRpb25zLnBhbi5ub01vdmVTdGFydCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0XHR6b29tOiB6b29tXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcblx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuXHRcdCAgICByaG8gPSAxLjQyLFxyXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG5cdFx0ZnVuY3Rpb24gcihpKSB7XHJcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG5cdFx0XHRpZiAodCA8PSAxKSB7XHJcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX21vdmUoXHJcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcblx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XHJcblxyXG5cdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcblx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMubGlzdGVucygnbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcykpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcblx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxyXG5cdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcblx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcblx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG5cdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IHBhZGRpbmcgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdGhlIG1pbmltdW0gYW1vdW50IHRvIG1ha2UgdGhlIGBsYXRsbmdgIHZpc2libGUuIFVzZVxyXG5cdC8vIHBhZGRpbmcgb3B0aW9ucyB0byBmaXQgdGhlIGRpc3BsYXkgdG8gbW9yZSByZXN0cmljdGVkIGJvdW5kcy5cclxuXHQvLyBJZiBgbGF0bG5nYCBpcyBhbHJlYWR5IHdpdGhpbiB0aGUgKG9wdGlvbmFsbHkgcGFkZGVkKSBkaXNwbGF5IGJvdW5kcyxcclxuXHQvLyB0aGUgbWFwIHdpbGwgbm90IGJlIHBhbm5lZC5cclxuXHRwYW5JbnNpZGU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwaXhlbENlbnRlciA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICBwaXhlbFBvaW50ID0gdGhpcy5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgcGl4ZWxCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKSxcclxuXHRcdCAgICBwYWRkZWRTaXplID0gcGFkZGVkQm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0XHR2YXIgY2VudGVyT2Zmc2V0ID0gcGl4ZWxQb2ludC5zdWJ0cmFjdChwYWRkZWRCb3VuZHMuZ2V0Q2VudGVyKCkpO1xyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFkZGVkQm91bmRzLmV4dGVuZChwaXhlbFBvaW50KS5nZXRTaXplKCkuc3VidHJhY3QocGFkZGVkU2l6ZSk7XHJcblx0XHRcdHBpeGVsQ2VudGVyLnggKz0gY2VudGVyT2Zmc2V0LnggPCAwID8gLW9mZnNldC54IDogb2Zmc2V0Lng7XHJcblx0XHRcdHBpeGVsQ2VudGVyLnkgKz0gY2VudGVyT2Zmc2V0LnkgPCAwID8gLW9mZnNldC55IDogb2Zmc2V0Lnk7XHJcblx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QocGl4ZWxDZW50ZXIpLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcblx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcblx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcblx0XHRcdHBhbjogdHJ1ZVxyXG5cdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0dGltZW91dDogMTAwMDAsXHJcblx0XHRcdHdhdGNoOiBmYWxzZVxyXG5cdFx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG5cdFx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG5cdFx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcblx0XHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gVXRpbC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0ICAgIG9uRXJyb3IgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG5cdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG5cdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTGF0TG5nKGxhdCwgbG5nKSxcclxuXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSAqIDIpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcblx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcblx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gQXBwcm9wcmlhdGUgZG9jcyBzZWN0aW9uP1xyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcblx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG5cdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7IHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9yZXNpemVSZXF1ZXN0KSB7XHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX3BhbmVzID0gW107XHJcblx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9yZW5kZXJlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG5cdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkIG9mIGBjb250YWluZXJgLCBvclxyXG5cdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmIChuYW1lKSB7XHJcblx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXIuY2xvbmUoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbiwgcGFkZGluZz86IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcblx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG5cdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblx0XHRwYWRkaW5nID0gdG9Qb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcblx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG5cdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG5cdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcblx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gRG9tRXZlbnQuZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG5cdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IFV0aWwuc3RhbXAoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBCcm93c2VyLmFueTNkO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJyAmJiBwb3NpdGlvbiAhPT0gJ3N0aWNreScpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHRcdHpvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cHJlcmVzZXQnKTtcclxuXHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cdFx0dGhpc1xyXG5cdFx0XHQuX21vdmVTdGFydCh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpXHJcblx0XHRcdC5fbW92ZShjZW50ZXIsIHpvb20pXHJcblx0XHRcdC5fbW92ZUVuZCh6b29tQ2hhbmdlZCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHZpZXdyZXNldDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBuZWVkcyB0byByZWRyYXcgaXRzIGNvbnRlbnQgKHRoaXMgdXN1YWxseSBoYXBwZW5zXHJcblx0XHQvLyBvbiBtYXAgem9vbSBvciBsb2FkKS4gVmVyeSB1c2VmdWwgZm9yIGNyZWF0aW5nIGN1c3RvbSBvdmVybGF5cy5cclxuXHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgaW5pdGlhbGl6ZWQgKHdoZW4gaXRzIGNlbnRlciBhbmQgem9vbSBhcmUgc2V0XHJcblx0XHQvLyBmb3IgdGhlIGZpcnN0IHRpbWUpLlxyXG5cdFx0aWYgKGxvYWRpbmcpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVTdGFydDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkLCBub01vdmVTdGFydCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdGlmICghbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhLCBzdXByZXNzRXZlbnQpIHtcclxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcblx0XHR9XHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcblx0XHRpZiAoIXN1cHJlc3NFdmVudCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLFxyXG5cdFx0XHQvLyBpbmNsdWRpbmcgem9vbSBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLFxyXG5cdFx0XHQvLyBpbmNsdWRpbmcgcGFuIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0XHR9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5waW5jaCkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmdcclxuXHRcdC8vIChlLmcuIHVzZXIgc3RvcHBlZCBkcmFnZ2luZyB0aGUgbWFwIG9yIGFmdGVyIG5vbi1jZW50ZXJlZCB6b29tKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmx5VG9GcmFtZSk7XHJcblx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yYXdQYW5CeTogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuXHRcdHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gRG9tRXZlbnQub2ZmIDogRG9tRXZlbnQub247XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLiBVbmxpa2UgdGhlIGBrZXlwcmVzc2AgZXZlbnQsXHJcblx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcblx0XHQvLyBAZXZlbnQga2V5dXA6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzIGtleWRvd24ga2V5dXAnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwczovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyICYmICFEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG5cdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIHRoaXMubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0X2lzQ2xpY2tEaXNhYmxlZDogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR3aGlsZSAoZWwgJiYgZWwgIT09IHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHRpZiAoZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGVsID0gKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBlbFsnX2xlYWZsZXRfZGlzYWJsZV9ldmVudHMnXSB8fCBlLnR5cGUgPT09ICdjbGljaycgJiYgdGhpcy5faXNDbGlja0Rpc2FibGVkKGVsKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKGVsKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgY2FudmFzVGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IFV0aWwuZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgY2FudmFzVGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dmFyIHRhcmdldHMgPSB0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpO1xyXG5cclxuXHRcdGlmIChjYW52YXNUYXJnZXRzKSB7XHJcblx0XHRcdHZhciBmaWx0ZXJlZCA9IFtdOyAvLyBwaWNrIG9ubHkgdGFyZ2V0cyB3aXRoIGxpc3RlbmVyc1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbnZhc1RhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAoY2FudmFzVGFyZ2V0c1tpXS5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGNhbnZhc1RhcmdldHNbaV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0YXJnZXRzID0gZmlsdGVyZWQuY29uY2F0KHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuXHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQuZ2V0TGF0TG5nICYmICghdGFyZ2V0Ll9yYWRpdXMgfHwgdGFyZ2V0Ll9yYWRpdXMgPD0gMTApO1xyXG5cdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG5cdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBVdGlsLmluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpXHJcblx0XHRdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpIDw9IDEgJiYgTWF0aC5hYnMob2Zmc2V0LnkpIDw9IDEpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBCb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcclxuXHJcblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciBwcm9wID0gRG9tVXRpbC5UUkFOU0ZPUk0sXHJcblx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcclxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcHJveHkpO1xyXG5cdFx0dGhpcy5vZmYoJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbU1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcblx0fSxcclxuXHJcblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXHJcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCB8fCBmYWxzZSlcclxuXHRcdFx0ICAgIC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCB0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgc3RhcnRBbmltLCBub1VwZGF0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXBQYW5lKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChzdGFydEFuaW0pIHtcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IHRydWU7XHJcblxyXG5cdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gT3RoZXIgRXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcclxuXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG5cdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb20sXHJcblx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG5cdFx0XHR0aGlzLl90ZW1wRmlyZVpvb21FdmVudCA9IHRoaXMuX3pvb20gIT09IHRoaXMuX2FuaW1hdGVUb1pvb207XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG5cdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xyXG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XHJcblx0fSxcclxuXHJcblx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodGhpcy5fbWFwUGFuZSkge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcblx0XHRpZiAodGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJyk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5fdGVtcEZpcmVab29tRXZlbnQ7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuXHJcbi8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuLy9cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xyXG59XHJcbiIsICJcclxuaW1wb3J0IHtDbGFzc30gZnJvbSAnLi4vY29yZS9DbGFzcyc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sXHJcbiAqIEBha2EgTC5Db250cm9sXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENvbnRyb2wgPSBDbGFzcy5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sIE9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXHJcblx0XHQvLyBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgKG9uZSBvZiB0aGUgbWFwIGNvcm5lcnMpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndG9wbGVmdCdgLFxyXG5cdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRQb3NpdGlvbjogc3RyaW5nXHJcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0ICovXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2wuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcblx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcblx0XHRcdHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub2ZmKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IHZhciBjb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IENvbnRyb2wob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gKiBAdW5pbmhlcml0YWJsZVxyXG4gKlxyXG4gKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICovXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAqL1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwXHJcblx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcFxyXG5cdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcblx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcblx0XHQgICAgICAgICAgICBEb21VdGlsLmNyZWF0ZSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuXHRcdFx0Y29ybmVyc1t2U2lkZSArIGhTaWRlXSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29ybmVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycztcclxuXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xyXG5cdH1cclxufSk7XHJcbiIsICJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAqIFx0XCJPcGVuU3RyZWV0TWFwXCI6IG9zbVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgb3ZlcmxheXMgPSB7XHJcbiAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gKiB9O1xyXG4gKlxyXG4gKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XHJcbiAqICAgICBcIjxzb21lTmFtZTE+XCI6IGxheWVyMSxcclxuICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVycyA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyLCB0b3VjaCwgb3Iga2V5Ym9hcmQgYWN0aXZhdGlvbi5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fcHJldmVudENsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdENvbnRyb2wucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcywgbWFwKTtcclxuXHRcdC8vIFRyaWdnZXIgZXhwYW5kIGFmdGVyIExheWVycyBDb250cm9sIGhhcyBiZWVuIGluc2VydGVkIGludG8gRE9NIHNvIHRoYXQgaXMgbm93IGhhcyBhbiBhY3R1YWwgaGVpZ2h0LlxyXG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChsYXllcikpO1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG5cdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuXHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fc2VjdGlvbi5jbGllbnRIZWlnaHQpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcblx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXHJcblx0XHQgICAgY29sbGFwc2VkID0gdGhpcy5vcHRpb25zLmNvbGxhcHNlZDtcclxuXHJcblx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cclxuXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IERvbVV0aWwuY3JlYXRlKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKGNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblxyXG5cdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLl9leHBhbmRTYWZlbHksXHJcblx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBEb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssIHtcclxuXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHRcdFx0dGhpcy5fZXhwYW5kU2FmZWx5KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBDZXJ0YWluIHNjcmVlbiByZWFkZXJzIGludGVyY2VwdCB0aGUga2V5IGV2ZW50IGFuZCBpbnN0ZWFkIHNlbmQgYSBjbGljayBldmVudFxyXG5cdFx0XHRjbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIFV0aWwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KFV0aWwuYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE5MDc5KVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIFV0aWwuc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuXHRcdGlucHV0LmxheWVySWQgPSBVdGlsLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGV4cGFuZGluZyB0aGUgY29udHJvbCBvbiBtb2JpbGUgd2l0aCBhIGNsaWNrIGNhbiBjYXVzZSBhZGRpbmcgYSBsYXllciAtIHdlIGRvbid0IHdhbnQgdGhpc1xyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRDbGljaykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kU2FmZWx5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb247XHJcblx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSB0cnVlO1xyXG5cdFx0RG9tRXZlbnQub24oc2VjdGlvbiwgJ2NsaWNrJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHREb21FdmVudC5vZmYoc2VjdGlvbiwgJ2NsaWNrJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0XHR0aGF0Ll9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgbGF5ZXJzIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG5leHBvcnQgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcclxuIiwgIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRleHQ6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG5cdFx0ICovXHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0XHR0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0XHR0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdHpvb21Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHQvLyBAc2VjdGlvbiBDb250cm9sc1xyXG5cdFx0Ly8gQHByb3BlcnR5IHpvb21Db250cm9sOiBDb250cm9sLlpvb21cclxuXHRcdC8vIFRoZSBkZWZhdWx0IHpvb20gY29udHJvbCAob25seSBhdmFpbGFibGUgaWYgdGhlXHJcblx0XHQvLyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHdhcyBgdHJ1ZWAgd2hlbiBjcmVhdGluZyB0aGUgbWFwKS5cclxuXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG5leHBvcnQgdmFyIHpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxufTtcclxuIiwgIlxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCB2YXIgc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xufTtcbiIsICJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG52YXIgdWtyYWluaWFuRmxhZyA9ICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiOFwiIHZpZXdCb3g9XCIwIDAgMTIgOFwiIGNsYXNzPVwibGVhZmxldC1hdHRyaWJ1dGlvbi1mbGFnXCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+JztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nfGZhbHNlID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+JyArIChCcm93c2VyLmlubGluZVN2ZyA/IHVrcmFpbmlhbkZsYWcgKyAnICcgOiAnJykgKyAnTGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRtYXAub24oJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKGV2KSB7XHJcblx0XHRpZiAoZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0ZXYubGF5ZXIub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nfGZhbHNlKTogdGhpc1xyXG5cdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnJmNvcHk7IE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj58PC9zcGFuPiAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5leHBvcnQgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG4iLCAiaW1wb3J0IHtDb250cm9sLCBjb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0IHtMYXllcnMsIGxheWVyc30gZnJvbSAnLi9Db250cm9sLkxheWVycyc7XG5pbXBvcnQge1pvb20sIHpvb219IGZyb20gJy4vQ29udHJvbC5ab29tJztcbmltcG9ydCB7U2NhbGUsIHNjYWxlfSBmcm9tICcuL0NvbnRyb2wuU2NhbGUnO1xuaW1wb3J0IHtBdHRyaWJ1dGlvbiwgYXR0cmlidXRpb259IGZyb20gJy4vQ29udHJvbC5BdHRyaWJ1dGlvbic7XG5cbkNvbnRyb2wuTGF5ZXJzID0gTGF5ZXJzO1xuQ29udHJvbC5ab29tID0gWm9vbTtcbkNvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbkNvbnRyb2wuQXR0cmlidXRpb24gPSBBdHRyaWJ1dGlvbjtcblxuY29udHJvbC5sYXllcnMgPSBsYXllcnM7XG5jb250cm9sLnpvb20gPSB6b29tO1xuY29udHJvbC5zY2FsZSA9IHNjYWxlO1xuY29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG5leHBvcnQge0NvbnRyb2wsIGNvbnRyb2x9O1xuIiwgImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG5leHBvcnQgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG5cdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxufSk7XG5cbi8vIEBzZWN0aW9uIFRoZXJlIGlzIHN0YXRpYyBmdW5jdGlvbiB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkhhbmRsZXI6XG4vLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbi8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5IYW5kbGVyLmFkZFRvID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuIiwgImltcG9ydCBCcm93c2VyIGZyb20gJy4vQnJvd3Nlcic7XG5leHBvcnQge0Jyb3dzZXJ9O1xuXG5leHBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuL0V2ZW50cyc7XG5pbXBvcnQge0V2ZW50c30gZnJvbSAnLi9FdmVudHMnO1xuZXhwb3J0IHtFdmVudGVkfTtcbmV4cG9ydCB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG5leHBvcnQge0hhbmRsZXJ9IGZyb20gJy4vSGFuZGxlcic7XG5cbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcbmV4cG9ydCB7VXRpbH07XG5leHBvcnQge2V4dGVuZCwgYmluZCwgc3RhbXAsIHNldE9wdGlvbnN9IGZyb20gJy4vVXRpbCc7XG4iLCAiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIFNUQVJUID0gQnJvd3Nlci50b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJztcclxuXHJcbmV4cG9ydCB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG5cdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHR0aGlzLmZpbmlzaERyYWcodHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKERvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XHJcblx0XHRcdC8vIEZpbmlzaCBkcmFnZ2luZyB0byBhdm9pZCBjb25mbGljdCB3aXRoIHRvdWNoWm9vbVxyXG5cdFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0aGlzOyAgLy8gUHJldmVudCBkcmFnZ2luZyBtdWx0aXBsZSBvYmplY3RzIGF0IG9uY2UuXHJcblxyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUodGhpcy5fZWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG5cdFx0dGhpcy5maXJlKCdkb3duJyk7XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcclxuXHRcdCAgICBzaXplZFBhcmVudCA9IERvbVV0aWwuZ2V0U2l6ZWRQYXJlbnROb2RlKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0Ly8gQ2FjaGUgdGhlIHNjYWxlLCBzbyB0aGF0IHdlIGNhbiBjb250aW51b3VzbHkgY29tcGVuc2F0ZSBmb3IgaXQgZHVyaW5nIGRyYWcgKF9vbk1vdmUpLlxyXG5cdFx0dGhpcy5fcGFyZW50U2NhbGUgPSBEb21VdGlsLmdldFNjYWxlKHNpemVkUGFyZW50KTtcclxuXHJcblx0XHR2YXIgbW91c2VldmVudCA9IGUudHlwZSA9PT0gJ21vdXNlZG93bic7XHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZW1vdmUnIDogJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZXVwJyA6ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuXHRcdC8vIFRoZXJlZm9yZSB0aGVyZSBpcyBubyBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBwb3NpdGlvbiBhbmQgYm9yZGVyICh0aGV5IGFyZSBlbGltaW5hdGVkIGJ5IHRoZSBzdWJ0cmFjdGlvbilcclxuXHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cclxuXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcblx0XHRvZmZzZXQueSAvPSB0aGlzLl9wYXJlbnRTY2FsZS55O1xyXG5cclxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGlmICh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlICYmIHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSB7XHJcblx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG5cdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9sYXN0RXZlbnQgPSBlO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG5cdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0fSxcclxuXHJcblx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKG5vSW5lcnRpYSkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlIHRvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICdtb3VzZXVwIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblxyXG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdHZhciBmaXJlRHJhZ2VuZCA9IHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZztcclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoZmlyZURyYWdlbmQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuXHRcdFx0XHRub0luZXJ0aWE6IG5vSW5lcnRpYSxcclxuXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbn0pO1xyXG4iLCAiaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi9MaW5lVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuLypcclxuICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29uIGdlb21ldHJpZXMuXHJcbiAqL1xyXG5cclxuLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICogQ2xpcHMgdGhlIHBvbHlnb24gZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYHBvaW50c2AgYnkgdGhlIGdpdmVuIGJvdW5kcyAodXNpbmcgdGhlIFtTdXRoZXJsYW5kLUhvZGdtYW4gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXRoZXJsYW5kJUUyJTgwJTkzSG9kZ21hbl9hbGdvcml0aG0pKS5cclxuICogVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5Z29uIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmdcclxuICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gKiB0aGFuIHBvbHlsaW5lLCBzbyB0aGVyZSdzIGEgc2VwYXJhdGUgbWV0aG9kIGZvciBpdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcblx0ICAgIGksIGosIGssXHJcblx0ICAgIGEsIGIsXHJcblx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gTGluZVV0aWwuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKGEpO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcblx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHRwID0gTGluZVV0aWwuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuLyogQGZ1bmN0aW9uIHBvbHlnb25DZW50ZXIobGF0bG5nczogTGF0TG5nW10sIGNyczogQ1JTKTogTGF0TG5nXHJcbiAqIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBhc3NlZCBMYXRMbmdzIChmaXJzdCByaW5nKSBmcm9tIGEgcG9seWdvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3MsIGNycykge1xyXG5cdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcjtcclxuXHJcblx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFMaW5lVXRpbC5pc0ZsYXQobGF0bG5ncykpIHtcclxuXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcblx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuXHR9XHJcblxyXG5cdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG5cdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRsbmdzKTtcclxuXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG5cdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuXHRpZiAoYXJlYUJvdW5kcyA8IDE3MDApIHtcclxuXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuXHR9XHJcblxyXG5cdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuXHR2YXIgcG9pbnRzID0gW107XHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcblx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcblx0fVxyXG5cclxuXHRhcmVhID0geCA9IHkgPSAwO1xyXG5cclxuXHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTtcclxuXHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0cDEgPSBwb2ludHNbaV07XHJcblx0XHRwMiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcclxuXHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XHJcblx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xyXG5cdFx0YXJlYSArPSBmICogMztcclxuXHR9XHJcblxyXG5cdGlmIChhcmVhID09PSAwKSB7XHJcblx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cclxuXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XHJcblx0fVxyXG5cclxuXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG5cdHJldHVybiB0b0xhdExuZyhbbGF0bG5nQ2VudGVyLmxhdCArIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nQ2VudGVyLmxuZyArIGNlbnRyb2lkTGF0TG5nLmxuZ10pO1xyXG59XHJcblxyXG4vKiBAZnVuY3Rpb24gY2VudHJvaWQobGF0bG5nczogTGF0TG5nW10pOiBMYXRMbmdcclxuICogUmV0dXJucyB0aGUgJ2NlbnRlciBvZiBtYXNzJyBvZiB0aGUgcGFzc2VkIExhdExuZ3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2VudHJvaWQoY29vcmRzKSB7XHJcblx0dmFyIGxhdFN1bSA9IDA7XHJcblx0dmFyIGxuZ1N1bSA9IDA7XHJcblx0dmFyIGxlbiA9IDA7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0bGF0U3VtICs9IGxhdGxuZy5sYXQ7XHJcblx0XHRsbmdTdW0gKz0gbGF0bG5nLmxuZztcclxuXHRcdGxlbisrO1xyXG5cdH1cclxuXHRyZXR1cm4gdG9MYXRMbmcoW2xhdFN1bSAvIGxlbiwgbG5nU3VtIC8gbGVuXSk7XHJcbn1cclxuIiwgImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge2NlbnRyb2lkfSBmcm9tICcuL1BvbHlVdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbi8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4vLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuLy8gW1JhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cHM6Ly9tb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qcy8pLlxyXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuXHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG5cdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdHZhciBpLFxyXG5cdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1BvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbmZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0cHJldiA9IGk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0fVxyXG5cdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG59XHJcblxyXG52YXIgX2xhc3RDb2RlO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbi8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4vLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbi8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG5cdHZhciBjb2RlID0gMDtcclxuXHJcblx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRjb2RlIHw9IDE7XHJcblx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdGNvZGUgfD0gMjtcclxuXHR9XHJcblxyXG5cdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRjb2RlIHw9IDQ7XHJcblx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRjb2RlIHw9IDg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufVxyXG5cclxuLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbmZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcblx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuZXhwb3J0IGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIVV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5bGluZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuXHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sIGNlbnRlcjtcclxuXHJcblx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFpc0ZsYXQobGF0bG5ncykpIHtcclxuXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcblx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuXHR9XHJcblxyXG5cdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG5cdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRsbmdzKTtcclxuXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG5cdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuXHRpZiAoYXJlYUJvdW5kcyA8IDE3MDApIHtcclxuXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuXHR9XHJcblxyXG5cdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuXHR2YXIgcG9pbnRzID0gW107XHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcblx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcblx0fVxyXG5cclxuXHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcclxuXHR9XHJcblxyXG5cdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cclxuXHRpZiAoaGFsZkRpc3QgPT09IDApIHtcclxuXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdFx0cDEgPSBwb2ludHNbaV07XHJcblx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcclxuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xyXG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XHJcblxyXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XHJcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XHJcblx0XHRcdFx0Y2VudGVyID0gW1xyXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcclxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcclxuXHRcdFx0XHRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG5cdHJldHVybiB0b0xhdExuZyhbbGF0bG5nQ2VudGVyLmxhdCArIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nQ2VudGVyLmxuZyArIGNlbnRyb2lkTGF0TG5nLmxuZ10pO1xyXG59XHJcbiIsICJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAc2VjdGlvblxyXG4gKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gKlxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAqXHJcbiAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gKiBgRVBTRzo0MzI2YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG59O1xyXG4iLCAiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAqXHJcbiAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuIiwgIi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwX3Byb2plY3Rpb24pLlxuXG4gKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG5cbiAqIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XG4gKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG4gKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogTm90ZSB0aGF0IHRoZSBwcm9qZWN0aW9uIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcbiIsICJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5NZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAqXHJcbiAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgdmFyIEVQU0czMzk1ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG4iLCAiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAqXHJcbiAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKlxyXG4gKiBMZWFmbGV0IDEuMC54IGNvbXBsaWVzIHdpdGggdGhlIFtUTVMgY29vcmRpbmF0ZSBzY2hlbWUgZm9yIEVQU0c6NDMyNl0oaHR0cHM6Ly93aWtpLm9zZ2VvLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2VfU3BlY2lmaWNhdGlvbiNnbG9iYWwtZ2VvZGV0aWMpLFxyXG4gKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAqIHdob2xlIGVhcnRoIGF0IHpvb20gbGV2ZWwgemVybywgYW5kIHRoYXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBvcmlnaW4gaXMgKC0xODAsKzkwKSxcclxuICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHNDMyNiA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cdHByb2plY3Rpb246IExvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcclxuIiwgImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcbiIsICJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xuaW1wb3J0IHtFUFNHMzM5NX0gZnJvbSAnLi9DUlMuRVBTRzMzOTUnO1xuaW1wb3J0IHtFUFNHMzg1NywgRVBTRzkwMDkxM30gZnJvbSAnLi9DUlMuRVBTRzM4NTcnO1xuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi9DUlMuRVBTRzQzMjYnO1xuaW1wb3J0IHtTaW1wbGV9IGZyb20gJy4vQ1JTLlNpbXBsZSc7XG5cbkNSUy5FYXJ0aCA9IEVhcnRoO1xuQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5DUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbkNSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbkNSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuZXhwb3J0IHtDUlN9O1xuIiwgImltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIExheWVyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogQGFrYSBMLkxheWVyXG4gKiBAYWthIElMYXllclxuICpcbiAqIEEgc2V0IG9mIG1ldGhvZHMgZnJvbSB0aGUgTGF5ZXIgYmFzZSBjbGFzcyB0aGF0IGFsbCBMZWFmbGV0IGxheWVycyB1c2UuXG4gKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5tYXJrZXIobGF0bG5nKS5hZGRUbyhtYXApO1xuICogbGF5ZXIuYWRkVG8obWFwKTtcbiAqIGxheWVyLnJlbW92ZSgpO1xuICogYGBgXG4gKlxuICogQGV2ZW50IGFkZDogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyBhZGRlZCB0byBhIG1hcFxuICpcbiAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgbWFwXG4gKi9cblxuXG5leHBvcnQgdmFyIExheWVyID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnb3ZlcmxheVBhbmUnXG5cdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBlLmcuIFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIi4gSXQgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhIGFuZCBpcyBvZnRlbiBhIGxlZ2FsIG9ibGlnYXRpb24gdG93YXJkcyBjb3B5cmlnaHQgaG9sZGVycyBhbmQgdGlsZSBwcm92aWRlcnMuXG5cdFx0YXR0cmlidXRpb246IG51bGwsXG5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0LyogQHNlY3Rpb25cblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXB8TGF5ZXJHcm91cCk6IHRoaXNcblx0ICogQWRkcyB0aGUgbGF5ZXIgdG8gdGhlIGdpdmVuIG1hcCBvciBsYXllciBncm91cC5cblx0ICovXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBtYXBcblx0Ly9cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShncm91cDogTGF5ZXJHcm91cCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gYExheWVyR3JvdXBgXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gKiBAdW5pbmhlcml0YWJsZVxuICpcbiAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAqXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICpcbiAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICpcbiAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICpcbiAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcFxuICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gKlxuICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAqXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gKi9cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgTGF5ZXIuJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cblx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiBVdGlsLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnM7XG5cdH0sXG5cblx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHQgKiBgYGBcblx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG5cdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKFV0aWwuaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNYXhab29tICYmIHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5fbGF5ZXJzTWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNaW5ab29tICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5fbGF5ZXJzTWluWm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuXHRcdH1cblx0fVxufSk7XG4iLCAiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgbGF5ZXJJZCA9IHR5cGVvZiBsYXllciA9PT0gJ251bWJlcicgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAuYWRkTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5yZW1vdmVMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobGF5ZXJzLnB1c2gsIGxheWVycyk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIFV0aWwuc3RhbXAobGF5ZXIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCAiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdpdmVuIHBhdGggb3B0aW9ucyB0byBlYWNoIGxheWVyIG9mIHRoZSBncm91cCB0aGF0IGhhcyBhIGBzZXRTdHlsZWAgbWV0aG9kLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCAiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi4vLi4vY29yZS9DbGFzcyc7XHJcbmltcG9ydCB7c2V0T3B0aW9uc30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG5cdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHRvb2x0aXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdCAqL1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG5cdFx0dG9vbHRpcEFuY2hvcjogWzAsIDBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpemUgPSBwb2ludChzaXplT3B0aW9uKSxcclxuXHRcdCAgICBhbmNob3IgPSBwb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIEJyb3dzZXIucmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbn1cclxuIiwgImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICh0eXBlb2YgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoICE9PSAnc3RyaW5nJykge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X3N0cmlwVXJsOiBmdW5jdGlvbiAocGF0aCkge1x0Ly8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gdXNlIGluIHRlc3RzXG5cdFx0dmFyIHN0cmlwID0gZnVuY3Rpb24gKHN0ciwgcmUsIGlkeCkge1xuXHRcdFx0dmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuXHRcdFx0cmV0dXJuIG1hdGNoICYmIG1hdGNoW2lkeF07XG5cdFx0fTtcblx0XHRwYXRoID0gc3RyaXAocGF0aCwgL151cmxcXCgoWydcIl0pPyguKylcXDFcXCkkLywgMik7XG5cdFx0cmV0dXJuIHBhdGggJiYgc3RyaXAocGF0aCwgL14oLiopbWFya2VyLWljb25cXC5wbmckLywgMSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblx0XHRwYXRoID0gdGhpcy5fc3RyaXBVcmwocGF0aCk7XG5cdFx0aWYgKHBhdGgpIHsgcmV0dXJuIHBhdGg7IH1cblx0XHR2YXIgbGluayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZiQ9XCJsZWFmbGV0LmNzc1wiXScpO1xuXHRcdGlmICghbGluaykgeyByZXR1cm4gJyc7IH1cblx0XHRyZXR1cm4gbGluay5ocmVmLnN1YnN0cmluZygwLCBsaW5rLmhyZWYubGVuZ3RoIC0gJ2xlYWZsZXQuY3NzJy5sZW5ndGggLSAxKTtcblx0fVxufSk7XG4iLCAiaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge3JlcXVlc3RBbmltRnJhbWUsIGNhbmNlbEFuaW1GcmFtZX0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXJrZXJEcmFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBMLk1hcmtlciB0byBtYWtlIHRoZSBtYXJrZXJzIGRyYWdnYWJsZS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFya2VyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBoYW5kbGVyc1xuICpcbiAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAqIGBgYFxuICpcbiAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICogTWFya2VyIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS4gT25seSB2YWxpZCB3aGVuIHRoZSBtYXJrZXIgaXMgb24gdGhlIG1hcCAoT3RoZXJ3aXNlIHNldCBbYG1hcmtlci5vcHRpb25zLmRyYWdnYWJsZWBdKCNtYXJrZXItZHJhZ2dhYmxlKSkuXG4gKi9cblxuZXhwb3J0IHZhciBNYXJrZXJEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5kaXNhYmxlKCk7XG5cblx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHRcdH1cblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIG1hcCA9IG1hcmtlci5fbWFwLFxuXHRcdCAgICBzcGVlZCA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxcblx0XHQgICAgcGFkZGluZyA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBib3VuZHMgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcblx0XHQgICAgb3JpZ2luID0gbWFwLmdldFBpeGVsT3JpZ2luKCk7XG5cblx0XHR2YXIgcGFuQm91bmRzID0gdG9Cb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLl9zdWJ0cmFjdChvcmlnaW4pLmFkZChwYWRkaW5nKSxcblx0XHRcdGJvdW5kcy5tYXguX3N1YnRyYWN0KG9yaWdpbikuc3VidHJhY3QocGFkZGluZylcblx0XHQpO1xuXG5cdFx0aWYgKCFwYW5Cb3VuZHMuY29udGFpbnMoaWNvblBvcykpIHtcblx0XHRcdC8vIENvbXB1dGUgaW5jcmVtZW50YWwgbW92ZW1lbnRcblx0XHRcdHZhciBtb3ZlbWVudCA9IHRvUG9pbnQoXG5cdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWF4LngpIC8gKGJvdW5kcy5tYXgueCAtIHBhbkJvdW5kcy5tYXgueCkgLVxuXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1pbi54KSAvIChib3VuZHMubWluLnggLSBwYW5Cb3VuZHMubWluLngpLFxuXG5cdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWF4LnkpIC8gKGJvdW5kcy5tYXgueSAtIHBhbkJvdW5kcy5tYXgueSkgLVxuXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1pbi55KSAvIChib3VuZHMubWluLnkgLSBwYW5Cb3VuZHMubWluLnkpXG5cdFx0XHQpLm11bHRpcGx5Qnkoc3BlZWQpO1xuXG5cdFx0XHRtYXAucGFuQnkobW92ZW1lbnQsIHthbmltYXRlOiBmYWxzZX0pO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5fYWRkKG1vdmVtZW50KTtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuX2FkZChtb3ZlbWVudCk7XG5cblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG5cdFx0XHR0aGlzLl9vbkRyYWcoZSk7XG5cblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cblx0XHQvLyBXaGVuIHVzaW5nIEVTNiBpbXBvcnRzIGl0IGNvdWxkIG5vdCBiZSBzZXQgd2hlbiBgUG9wdXBgIHdhcyBub3QgaW1wb3J0ZWQgYXMgd2VsbFxuXHRcdHRoaXMuX21hcmtlci5jbG9zZVBvcHVwICYmIHRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCk7XG5cblx0XHR0aGlzLl9tYXJrZXJcblx0XHRcdC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdFx0LmZpcmUoJ2RyYWdzdGFydCcpO1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcblx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG5cdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuXHRcdGlmIChzaGFkb3cpIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuIiwgImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcclxuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcgYXMgbGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQge01hcmtlckRyYWd9IGZyb20gJy4vTWFya2VyLkRyYWcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcmtlclxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICogQGFrYSBMLk1hcmtlclxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcblx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcblx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG5cdFx0Ly8gW1VzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2FjY2Vzc2liaWxpdHkvI21hcmtlcnMtbXVzdC1iZS1sYWJlbGxlZCkuXHJcblx0XHR0aXRsZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICdNYXJrZXInXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlLlxyXG5cdFx0Ly8gW1VzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2FjY2Vzc2liaWxpdHkvI21hcmtlcnMtbXVzdC1iZS1sYWJlbGxlZCkuXHJcblx0XHRhbHQ6ICdNYXJrZXInLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc2hhZG93UGFuZTogU3RyaW5nID0gJ3NoYWRvd1BhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIHNoYWRvdyB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5PbkZvY3VzOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXAgd2lsbCBwYW4gd2hlbmV2ZXIgdGhlIG1hcmtlciBpcyBmb2N1c2VkICh2aWFcclxuXHRcdC8vIGUuZy4gcHJlc3NpbmcgYHRhYmAgb24gdGhlIGtleWJvYXJkKSB0byBlbnN1cmUgdGhlIG1hcmtlciBpc1xyXG5cdFx0Ly8gdmlzaWJsZSB3aXRoaW4gdGhlIG1hcCdzIGJvdW5kc1xyXG5cdFx0YXV0b1Bhbk9uRm9jdXM6IHRydWUsXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dhYmxlIG1hcmtlciBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGRyYWdnYWJsZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG5cdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBwYW4gdGhlIG1hcCB3aGVuIGRyYWdnaW5nIHRoaXMgbWFya2VyIG5lYXIgaXRzIGVkZ2Ugb3Igbm90LlxyXG5cdFx0YXV0b1BhbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1MCwgNTApXHJcblx0XHQvLyBEaXN0YW5jZSAoaW4gcGl4ZWxzIHRvIHRoZSBsZWZ0L3JpZ2h0IGFuZCB0byB0aGUgdG9wL2JvdHRvbSkgb2YgdGhlXHJcblx0XHQvLyBtYXAgZWRnZSB0byBzdGFydCBwYW5uaW5nIHRoZSBtYXAuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUwLCA1MF0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuU3BlZWQ6IE51bWJlciA9IDEwXHJcblx0XHQvLyBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBtYXAgc2hvdWxkIHBhbiBieS5cclxuXHRcdGF1dG9QYW5TcGVlZDogMTBcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqXHJcblx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5kcmFnZ2luZy5yZW1vdmVIb29rcygpO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMuZHJhZ2dpbmc7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMudXBkYXRlXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEljb246IEljb25cclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGljb24gdXNlZCBieSB0aGUgbWFya2VyXHJcblx0Z2V0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uICYmIHRoaXMuX21hcCkge1xyXG5cdFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0ICAgIGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGljb24udGFnTmFtZSA9PT0gJ0lNRycpIHtcclxuXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0IHx8ICcnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG5cdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0XHRpY29uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG5cdFx0XHREb21FdmVudC5vbihpY29uLCAnZm9jdXMnLCB0aGlzLl9wYW5PbkZvY3VzLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdFx0bmV3U2hhZG93LmFsdCA9ICcnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcblx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGlmIChhZGRJY29uKSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ljb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5faW5pdEludGVyYWN0aW9uKCk7XHJcblx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUob3B0aW9ucy5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG5cdFx0XHREb21FdmVudC5vZmYodGhpcy5faWNvbiwgJ2ZvY3VzJywgdGhpcy5fcGFuT25Gb2N1cywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faWNvbik7XHJcblx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcclxuXHJcblx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHRoaXMuX2ljb24uc3R5bGUuekluZGV4ID0gdGhpcy5fekluZGV4ICsgb2Zmc2V0O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKG9wdCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XHJcblxyXG5cdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbnRlcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHJcblx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdGlmIChNYXJrZXJEcmFnKSB7XHJcblx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG5cdFx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG5cdFx0XHRcdGRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpO1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IE1hcmtlckRyYWcodGhpcyk7XHJcblxyXG5cdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5PbkZvY3VzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGljb25PcHRzID0gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucztcclxuXHRcdHZhciBzaXplID0gaWNvbk9wdHMuaWNvblNpemUgPyBwb2ludChpY29uT3B0cy5pY29uU2l6ZSkgOiBwb2ludCgwLCAwKTtcclxuXHRcdHZhciBhbmNob3IgPSBpY29uT3B0cy5pY29uQW5jaG9yID8gcG9pbnQoaWNvbk9wdHMuaWNvbkFuY2hvcikgOiBwb2ludCgwLCAwKTtcclxuXHJcblx0XHRtYXAucGFuSW5zaWRlKHRoaXMuX2xhdGxuZywge1xyXG5cdFx0XHRwYWRkaW5nVG9wTGVmdDogYW5jaG9yLFxyXG5cdFx0XHRwYWRkaW5nQm90dG9tUmlnaHQ6IHNpemUuc3VidHJhY3QoYW5jaG9yKVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvcjtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvcjtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59XHJcbiIsICJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxuZXhwb3J0IHZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgJ3dlaWdodCcpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICtcblx0XHQgICh0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZSB8fCAwKTtcblx0fVxufSk7XG4iLCAiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLnJlZHJhdygpO1xuXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xufVxuIiwgImltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5pbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7RWFydGh9IGZyb20gJy4uLy4uL2dlby9jcnMvQ1JTLkVhcnRoJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZVxuICogQGFrYSBMLkNpcmNsZVxuICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICpcbiAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGUgPSBDaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG5cdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcblx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SKSAvIGQsXG5cdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogcC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54O1xuXHRcdFx0dGhpcy5fcmFkaXVzWSA9IHAueSAtIHRvcC55O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4vLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xufVxuIiwgImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICogXHRbMzQuMDQsIC0xMTguMl1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gKiBcdFtbNDAuNzgsIC03My45MV0sXG4gKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuXG5leHBvcnQgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IExpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXHRcdHJldHVybiBMaW5lVXRpbC5wb2x5bGluZUNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/OiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG5cdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSBMaW5lVXRpbC5pc0ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cdFx0dGhpcy5fcmluZ3MgPSBbXTtcblx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHRpZiAoIXRoaXMuX3Jhd1B4Qm91bmRzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1heC5hZGQocClcblx0XHRdKTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTGluZVV0aWwuY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IExpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRpZiAoTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbi8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbi8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuUG9seWxpbmUuX2ZsYXQgPSBMaW5lVXRpbC5fZmxhdDtcbiIsICJpbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0ICogYXMgUG9seVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9seVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIFBvbHlnb24uXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cdFx0cmV0dXJuIFBvbHlVdGlsLnBvbHlnb25DZW50ZXIodGhpcy5fZGVmYXVsdFNoYXBlKCksIHRoaXMuX21hcC5vcHRpb25zLmNycyk7XG5cdH0sXG5cblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcblx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcblx0XHRpZiAoTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG5cdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdH1cblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG5cdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBQb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRwMSA9IHBhcnRbal07XG5cdFx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2Vcblx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuXHR9XG5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn1cbiIsICJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtNYXJrZXJ9IGZyb20gJy4vbWFya2VyL01hcmtlcic7XHJcbmltcG9ydCB7Q2lyY2xlfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGUnO1xyXG5pbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlTWFya2VyJztcclxuaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi92ZWN0b3IvUG9seWxpbmUnO1xyXG5pbXBvcnQge1BvbHlnb259IGZyb20gJy4vdmVjdG9yL1BvbHlnb24nO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuXHQgKiBXaGV0aGVyIGRlZmF1bHQgTWFya2VycyBmb3IgXCJQb2ludFwiIHR5cGUgRmVhdHVyZXMgaW5oZXJpdCBmcm9tIGdyb3VwIG9wdGlvbnMuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IFV0aWwuaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyPyApOiB0aGlzXHJcblx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG5cdC8vIElmIGBsYXllcmAgaXMgb21pdHRlZCwgdGhlIHN0eWxlIG9mIGFsbCBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBsYXllciBpcyByZXNldC5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbi8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbi8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcblx0ICAgIGxheWVycyA9IFtdLFxyXG5cdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdCAgICBfY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcsXHJcblx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRsYXllcnMucHVzaChfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnUG9seWdvbic6XHJcblx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGdlb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0aWYgKGdlb0xheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2goZ2VvTGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5mZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR2YXIgZmVhdHVyZUxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb21ldHJ5LmZlYXR1cmVzW2ldLCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChmZWF0dXJlTGF5ZXIpIHtcclxuXHRcdFx0XHRsYXllcnMucHVzaChmZWF0dXJlTGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRkZWZhdWx0OlxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXJGbiwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuXHRcdHBvaW50VG9MYXllckZuKGdlb2pzb24sIGxhdGxuZykgOlxyXG5cdFx0bmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJzSW5oZXJpdE9wdGlvbnMgJiYgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbi8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcblx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGF0bG5ncztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuXHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbiwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuXHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHQvLyBDaGVjayBmb3IgZmxhdCBhcnJheXMgcmVxdWlyZWQgdG8gZW5zdXJlIHVuYmFsYW5jZWQgYXJyYXlzIGFyZSBjb3JyZWN0bHkgY29udmVydGVkIGluIHJlY3Vyc2lvblxyXG5cdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBMaW5lVXRpbC5pc0ZsYXQobGF0bG5nc1tpXSkgPyAwIDogbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcblx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xyXG5cdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdLnNsaWNlKCkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvb3JkcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZlYXR1cmUobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG5cdFx0VXRpbC5leHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRhc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4vLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcblx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0cmV0dXJuIGdlb2pzb247XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0cHJvcGVydGllczoge30sXHJcblx0XHRnZW9tZXRyeTogZ2VvanNvblxyXG5cdH07XHJcbn1cclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ1BvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCksIHByZWNpc2lvbilcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbi8vIEBzZWN0aW9uIE90aGVyIG1ldGhvZHNcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuQ2lyY2xlLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5DaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcblBvbHlsaW5lLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIG11bHRpID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMSA6IDAsIGZhbHNlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuUG9seWdvbi5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBob2xlcyA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyksXHJcblx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRpZiAoIWhvbGVzKSB7XHJcblx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG5cdC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG5cdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgRmVhdHVyZUNvbGxlY3Rpb25gLCBgR2VvbWV0cnlDb2xsZWN0aW9uYCwgb3IgYE11bHRpUG9pbnRgKS5cclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcclxuXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdGpzb25zLnB1c2goanNvbi5nZW9tZXRyeSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG5cdFx0XHRcdFx0Ly8gU3F1YXNoIG5lc3RlZCBmZWF0dXJlIGNvbGxlY3Rpb25zXHJcblx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4vLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG5leHBvcnQgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xyXG4iLCAiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHBzOi8vbWFwcy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcblx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG5cdFx0ekluZGV4OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ2ltZycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0aW1nLm9ubG9hZCA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IFV0aWwuYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgSW1hZ2VPdmVybGF5LlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5leHBvcnQgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuIiwgImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVmlkZW9PdmVybGF5XHJcbiAqIEBha2EgTC5WaWRlb092ZXJsYXlcclxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSB2aWRlbyBwbGF5ZXIgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cclxuICpcclxuICogQSB2aWRlbyBvdmVybGF5IHVzZXMgdGhlIFtgPHZpZGVvPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbylcclxuICogSFRNTDUgZWxlbWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHZpZGVvVXJsID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYml0ZXMvMDAxODgvcGF0cmljaWFfbmFzYS53ZWJtJyxcclxuICogXHR2aWRlb0JvdW5kcyA9IFtbIDMyLCAtMTMwXSwgWyAxMywgLTEwMF1dO1xyXG4gKiBMLnZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFZpZGVvT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGF1dG9wbGF5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuXHRcdC8vIE9uIHNvbWUgYnJvd3NlcnMgYXV0b3BsYXkgd2lsbCBvbmx5IHdvcmsgd2l0aCBgbXV0ZWQ6IHRydWVgXHJcblx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG5cdFx0bG9vcDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgc2F2ZSBhc3BlY3QgcmF0aW8gYWZ0ZXIgdGhlIHByb2plY3Rpb24uXHJcblx0XHQvLyBSZWxldmFudCBmb3Igc3VwcG9ydGVkIGJyb3dzZXJzLiBTZWUgW2Jyb3dzZXIgY29tcGF0aWJpbGl0eV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL29iamVjdC1maXQpXHJcblx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtdXRlZDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgb24gbXV0ZSB3aGVuIGxvYWRlZC5cclxuXHRcdG11dGVkOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBsYXlzSW5saW5lOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gTW9iaWxlIGJyb3dzZXJzIHdpbGwgcGxheSB0aGUgdmlkZW8gcmlnaHQgd2hlcmUgaXQgaXMgaW5zdGVhZCBvZiBvcGVuIGl0IHVwIGluIGZ1bGxzY3JlZW4gbW9kZS5cclxuXHRcdHBsYXlzSW5saW5lOiB0cnVlXHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG5cdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ3ZpZGVvJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0dmlkLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcblx0XHR2aWQub25sb2FkZWRkYXRhID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcblx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghVXRpbC5pc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5rZWVwQXNwZWN0UmF0aW8gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZpZC5zdHlsZSwgJ29iamVjdEZpdCcpKSB7XHJcblx0XHRcdHZpZC5zdHlsZVsnb2JqZWN0Rml0J10gPSAnZmlsbCc7XHJcblx0XHR9XHJcblx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuXHRcdHZpZC5tdXRlZCA9ICEhdGhpcy5vcHRpb25zLm11dGVkO1xyXG5cdFx0dmlkLnBsYXlzSW5saW5lID0gISF0aGlzLm9wdGlvbnMucGxheXNJbmxpbmU7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3VybC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgc291cmNlID0gRG9tVXRpbC5jcmVhdGUoJ3NvdXJjZScpO1xyXG5cdFx0XHRzb3VyY2Uuc3JjID0gdGhpcy5fdXJsW2ldO1xyXG5cdFx0XHR2aWQuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MVmlkZW9FbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIHZpZGVvIChvciBhcnJheSBvZiBVUkxzLCBvciBldmVuIGEgdmlkZW8gZWxlbWVudCkgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKTtcclxufVxyXG4iLCAiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFNWR092ZXJsYXlcbiAqIEBha2EgTC5TVkdPdmVybGF5XG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XG4gKlxuICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAqXG4gKiBBbiBTVkcgb3ZlcmxheSB1c2VzIHRoZSBbYDxzdmc+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3ZnKSBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICogc3ZnRWxlbWVudC5pbm5lckhUTUwgPSAnPHJlY3Qgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMDBcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOnJlZFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMTIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOiMwMDEzZmZcIi8+JztcbiAqIHZhciBzdmdFbGVtZW50Qm91bmRzID0gWyBbIDMyLCAtMTMwIF0sIFsgMTMsIC0xMDAgXSBdO1xuICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWR092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cblx0XHRlbC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdGVsLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXHR9XG5cblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIGFuIFNWRyBlbGVtZW50IGFuZCB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuLy8gQSB2aWV3Qm94IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvbiB0aGUgU1ZHIGVsZW1lbnQgdG8gem9vbSBpbiBhbmQgb3V0IHByb3Blcmx5LlxuXG5leHBvcnQgZnVuY3Rpb24gc3ZnT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU1ZHT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKTtcbn1cbiIsICJpbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcsIExhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIG92ZXJsYXlzIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuZXhwb3J0IHZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHBvcHVwL3Rvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIG1vdXNlIGV2ZW50cy5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgb3ZlcmxheSBwb3NpdGlvbi5cclxuXHRcdG9mZnNldDogWzAsIDBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uID0gJydcclxuXHRcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheSB3aGlsZSBpbml0aWFsaXppbmcuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZVxyXG5cdFx0Ly8gcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcblx0XHRjb250ZW50OiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdGlmIChvcHRpb25zICYmIChvcHRpb25zIGluc3RhbmNlb2YgTGF0TG5nIHx8IFV0aWwuaXNBcnJheShvcHRpb25zKSkpIHtcclxuXHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcob3B0aW9ucyk7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzb3VyY2UpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQpIHtcclxuXHRcdFx0dGhpcy5fY29udGVudCA9IHRoaXMub3B0aW9ucy5jb250ZW50O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIG92ZXJsYXkgdG8gdGhlIG1hcC5cclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgL2Aub3BlblRvb2x0aXAodG9vbHRpcClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkge1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIG92ZXJsYXkuXHJcblx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5jbG9zZVBvcHVwKHBvcHVwKWAvYC5jbG9zZVRvb2x0aXAodG9vbHRpcClgXHJcblx0Ly8gYW5kIGBsYXllci5jbG9zZVBvcHVwKClgL2AuY2xvc2VUb29sdGlwKClgLlxyXG5cdGNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlKGxheWVyPzogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBvdmVybGF5IGJvdW5kIHRvIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuXHQvLyBBcmd1bWVudCBtYXkgYmUgb21pdHRlZCBvbmx5IGZvciBvdmVybGF5IGJvdW5kIHRvIGxheWVyLlxyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBsYXllci50b2dnbGVQb3B1cCgpYC9gLnRvZ2dsZVRvb2x0aXAoKWAuXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2UgPSBsYXllcjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsYXllciA9IHRoaXMuX3NvdXJjZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wcmVwYXJlT3BlbigpO1xyXG5cclxuXHRcdFx0Ly8gb3BlbiB0aGUgb3ZlcmxheSBvbiB0aGUgbWFwXHJcblx0XHRcdHRoaXMub3Blbk9uKGxheWVyLl9tYXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChEb21VdGlsLnJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiB0aGUgb3ZlcmxheS5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheS4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcblx0Ly8gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBjb250YWluZXIgb2YgdGhlIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIG92ZXJsYXkgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgb3ZlcmxheSBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSBpbiBmcm9udCBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IHRvIHRoZSBiYWNrIG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIHByZXBhcmUgYm91bmQgb3ZlcmxheSB0byBvcGVuOiB1cGRhdGUgbGF0bG5nIHBvcyAvIGNvbnRlbnQgc291cmNlIChmb3IgRmVhdHVyZUdyb3VwKVxyXG5cdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuXHRcdGlmICghc291cmNlLl9tYXApIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRzb3VyY2UgPSBudWxsO1xyXG5cdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5fc291cmNlLl9sYXllcnM7XHJcblx0XHRcdGZvciAodmFyIGlkIGluIGxheWVycykge1xyXG5cdFx0XHRcdGlmIChsYXllcnNbaWRdLl9tYXApIHtcclxuXHRcdFx0XHRcdHNvdXJjZSA9IGxheWVyc1tpZF07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFzb3VyY2UpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIFVuYWJsZSB0byBnZXQgc291cmNlIGxheWVyLlxyXG5cclxuXHRcdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghbGF0bG5nKSB7XHJcblx0XHRcdGlmIChzb3VyY2UuZ2V0Q2VudGVyKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRMYXRMbmcpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0TGF0TG5nKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoc291cmNlLmdldEJvdW5kcykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy4nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBldGMuLi4pXHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcblx0XHQvLyBAc2VjdGlvbiBEaXZPdmVybGF5IGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGNvbnRlbnR1cGRhdGU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5IGlzIHVwZGF0ZWRcclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIG92ZXJsYXkgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuTWFwLmluY2x1ZGUoe1xyXG5cdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgY29udGVudCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcblx0XHRpZiAoIShvdmVybGF5IGluc3RhbmNlb2YgT3ZlcmxheUNsYXNzKSkge1xyXG5cdFx0XHRvdmVybGF5ID0gbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zKS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRvdmVybGF5LnNldExhdExuZyhsYXRsbmcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG92ZXJsYXk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5MYXllci5pbmNsdWRlKHtcclxuXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIG9sZCwgY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG5cdFx0aWYgKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKG92ZXJsYXksIG9wdGlvbnMpO1xyXG5cdFx0XHRvdmVybGF5Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3ZlcmxheSA9IChvbGQgJiYgIW9wdGlvbnMpID8gb2xkIDogbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0b3ZlcmxheS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG92ZXJsYXk7XHJcblx0fVxyXG59KTtcclxuIiwgImltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0IHtQYXRofSBmcm9tICcuL3ZlY3Rvci9QYXRoJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqXHJcbiAqIEEgcG9wdXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqIG9yXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb3B1cCA9IEwucG9wdXAobGF0bG5nLCB7Y29udGVudDogJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuZXhwb3J0IHZhciBQb3B1cCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ3BvcHVwUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLlxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcblx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcblx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcblx0XHQvLyBUaGUgc2Nyb2xsYWJsZSBjb250YWluZXIgY2FuIGJlIHN0eWxlZCB1c2luZyB0aGVcclxuXHRcdC8vIGBsZWFmbGV0LXBvcHVwLXNjcm9sbGVkYCBDU1MgY2xhc3Mgc2VsZWN0b3IuXHJcblx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG5cdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcblx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBFU0Mga2V5IGZvciBjbG9zaW5nIG9mIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uQ2xpY2s6IEJvb2xlYW4gPSAqXHJcblx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xyXG5cdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcblxyXG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVMYXllcihtYXAuX3BvcHVwKTtcclxuXHRcdH1cclxuXHRcdG1hcC5fcG9wdXAgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBEaXZPdmVybGF5LnByb3RvdHlwZS5vcGVuT24uY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG5cdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTsgLy8gb3ZlcnJpZGVzIHRoZSBpbXBsaWNpdCByb2xlPWxpbmsgb2YgPGE+IGVsZW1lbnRzICM3Mzk5XHJcblx0XHRcdGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdDbG9zZSBwb3B1cCcpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mIzIxNTs8L3NwYW4+JztcclxuXHJcblx0XHRcdERvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChldik7XHJcblx0XHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuXHRcdC8vIFdlIGNhbiBlbmRsZXNzbHkgcmVjdXJzZSBpZiBrZWVwSW5WaWV3IGlzIHNldCBhbmQgdGhlIHZpZXcgcmVzZXRzLlxyXG5cdFx0Ly8gTGV0J3MgZ3VhcmQgYWdhaW5zdCB0aGF0IGJ5IGV4aXRpbmcgZWFybHkgaWYgd2UncmUgcmVzcG9uZGluZyB0byBvdXIgb3duIGF1dG9wYW4uXHJcblx0XHRpZiAodGhpcy5fYXV0b3Bhbm5pbmcpIHtcclxuXHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSBmYWxzZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoRG9tVXRpbC5nZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0Ly8gVHJhY2sgdGhhdCB3ZSdyZSBhdXRvcGFubmluZywgYXMgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlLXJhbiBvbiBtb3ZlZW5kXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRcdHRoaXMuX2F1dG9wYW5uaW5nID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yID8gdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcigpIDogWzAsIDBdKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuLy8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb3B1cChsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGBsYXRsbmdgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxyXG5leHBvcnQgdmFyIHBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdHJldHVybiBuZXcgUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxufTtcclxuXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAqIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHBvcHVwcyB0byBjbG9zZSB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAuXHJcbiAqL1xyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChwb3B1cDogUG9wdXApOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCBwb3B1cCB3aGlsZSBjbG9zaW5nIHRoZSBwcmV2aW91c2x5IG9wZW5lZCAodG8gbWFrZSBzdXJlIG9ubHkgb25lIGlzIG9wZW5lZCBhdCBvbmUgdGltZSBmb3IgdXNhYmlsaXR5KS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDcmVhdGVzIGEgcG9wdXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW5zIGl0IGluIHRoZSBnaXZlbiBwb2ludCBvbiBhIG1hcC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9pbml0T3ZlcmxheShQb3B1cCwgcG9wdXAsIGxhdGxuZywgb3B0aW9ucylcclxuXHRcdCAgLm9wZW5Pbih0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAocG9wdXA/OiBQb3B1cCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAocG9wdXApIHtcclxuXHRcdHBvcHVwID0gYXJndW1lbnRzLmxlbmd0aCA/IHBvcHVwIDogdGhpcy5fcG9wdXA7XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0cG9wdXAuY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExheWVyXHJcbiAqIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHMgZXhhbXBsZVxyXG4gKlxyXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyBwb3B1cHMgdG8gaXQuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kUG9wdXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XHJcbiAqIGxheWVyLm9wZW5Qb3B1cCgpO1xyXG4gKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICovXHJcblxyXG4vLyBAc2VjdGlvbiBQb3B1cCBtZXRob2RzXHJcbkxheWVyLmluY2x1ZGUoe1xyXG5cclxuXHQvLyBAbWV0aG9kIGJpbmRQb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258UG9wdXAsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIEJpbmRzIGEgcG9wdXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXHJcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcclxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9wb3B1cCA9IHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCB0aGlzLl9wb3B1cCwgY29udGVudCwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSkge1xyXG5cdFx0XHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4obGF0bG5nIHx8IHRoaXMuX2xhdGxuZykpIHtcclxuXHRcdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBvbiB0aGUgbWFwXHJcblx0XHRcdFx0dGhpcy5fcG9wdXAub3Blbk9uKHRoaXMuX21hcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cCgpOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLmNsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG5cdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAudG9nZ2xlKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcblx0aXNQb3B1cE9wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAodGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuXHQvLyBSZXR1cm5zIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcblx0fSxcclxuXHJcblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fcG9wdXAgfHwgIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gZS5sYXllciB8fCBlLnRhcmdldDtcclxuXHRcdGlmICh0aGlzLl9wb3B1cC5fc291cmNlID09PSB0YXJnZXQgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHQvLyB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHRcdC8vIGlmIHdlIHNob3VsZCB0b2dnbGUgaXQgb3Blbi9jbG9zZWRcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkpIHtcclxuXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRhcmdldDtcclxuXHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcbiIsICJpbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcblxuLypcbiAqIEBjbGFzcyBUb29sdGlwXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICogQGFrYSBMLlRvb2x0aXBcbiAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgdG9vbHRpcCB0byBtYXJrZXI6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kVG9vbHRpcGAgbWV0aG9kLlxuICpcbiAqIEEgdG9vbHRpcCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgdG9vbHRpcCA9IEwudG9vbHRpcCgpXG4gKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxuICogXHQuc2V0Q29udGVudCgnSGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgdG9vbHRpcC4nKVxuICogXHQuYWRkVG8obWFwKTtcbiAqIGBgYFxuICogb3JcbiAqIGBgYGpzXG4gKiB2YXIgdG9vbHRpcCA9IEwudG9vbHRpcChsYXRsbmcsIHtjb250ZW50OiAnSGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgdG9vbHRpcC4nfSlcbiAqIFx0LmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKlxuICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAqL1xuXG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuZXhwb3J0IHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG5cdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuXHRcdG9mZnNldDogWzAsIDBdLFxuXG5cdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG5cdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbGx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcblx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG5cdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cblx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cblx0XHRzdGlja3k6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0dGhpcy5hZGRFdmVudFBhcmVudCh0aGlzLl9zb3VyY2UpO1xuXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcblxuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2xlYWZsZXQtdG9vbHRpcC0nICsgVXRpbC5zdGFtcCh0aGlzKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge30sXG5cblx0X3NldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG5cdFx0dmFyIHN1YlgsIHN1YlksXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG5cdFx0ICAgIHRvb2x0aXBQb2ludCA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChwb3MpLFxuXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG5cdFx0ICAgIHRvb2x0aXBIZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuXHRcdGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0O1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gMDtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG5cdFx0XHRzdWJYID0gMDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAodG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0c3ViWCA9IDA7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0Jztcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggKyAob2Zmc2V0LnggKyBhbmNob3IueCkgKiAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHN1YlgsIHN1YlksIHRydWUpKS5hZGQob2Zmc2V0KS5hZGQoYW5jaG9yKTtcblxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXRvcCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBwb3MpO1xuXHR9LFxuXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdH1cblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBgVG9vbHRpcGAgb2JqZWN0IGdpdmVuIGBsYXRsbmdgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXG5leHBvcnQgdmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKVxuXHRcdCAgLm9wZW5Pbih0aGlzKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHR0b29sdGlwLmNsb3NlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gKiBgYGBcbiAqL1xuXG4vLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5pc1Rvb2x0aXBPcGVuKCkpIHtcblx0XHRcdHRoaXMudW5iaW5kVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Rvb2x0aXAgPSB0aGlzLl9pbml0T3ZlcmxheShUb29sdGlwLCB0aGlzLl90b29sdGlwLCBjb250ZW50LCBvcHRpb25zKTtcblx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuXHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG5cdHVuYmluZFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG5cdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdGlmICghcmVtb3ZlICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcblx0XHQgICAgZXZlbnRzID0ge1xuXHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlVG9vbHRpcCxcblx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG5cdFx0ICAgIH07XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHR0aGlzLl9hZGRGb2N1c0xpc3RlbmVycygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG5cdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG5cdFx0fVxuXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG5cdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gdGhpcztcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9wcmVwYXJlT3BlbihsYXRsbmcpKSB7XG5cdFx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0XHR0aGlzLl90b29sdGlwLm9wZW5Pbih0aGlzLl9tYXApO1xuXG5cdFx0XHRcdGlmICh0aGlzLmdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHR0aGlzLl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyKHRoaXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZWFjaExheWVyKSB7XG5cdFx0XHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllciwgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuY2xvc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudG9nZ2xlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fSxcblxuXHRfYWRkRm9jdXNMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG5cdFx0XHR0aGlzLl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIodGhpcyk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuXHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGVsID0gdHlwZW9mIGxheWVyLmdldEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgbGF5ZXIuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbCkge1xuXHRcdFx0RG9tRXZlbnQub24oZWwsICdmb2N1cycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0RG9tRXZlbnQub24oZWwsICdibHVyJywgdGhpcy5jbG9zZVRvb2x0aXAsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGVsID0gdHlwZW9mIGxheWVyLmdldEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgbGF5ZXIuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLmlkKTtcblx0XHR9XG5cdH0sXG5cblxuXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbWFwIGlzIG1vdmluZywgd2Ugd2lsbCBzaG93IHRoZSB0b29sdGlwIGFmdGVyIGl0J3MgZG9uZS5cblx0XHRpZiAodGhpcy5fbWFwLmRyYWdnaW5nICYmIHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSAmJiAhdGhpcy5fb3Blbk9uY2VGbGFnKSB7XG5cdFx0XHR0aGlzLl9vcGVuT25jZUZsYWcgPSB0cnVlO1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0dGhpcy5fbWFwLm9uY2UoJ21vdmVlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoYXQuX29wZW5PbmNlRmxhZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGF0Ll9vcGVuVG9vbHRpcChlKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHR0aGlzLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdH0sXG5cblx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdH1cblx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHR9XG59KTtcbiIsICJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7ZW1wdHl9IGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbmV4cG9ydCB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0ZW1wdHkoZGl2KTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBwb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xufVxuIiwgImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmV4cG9ydCB7aWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0Jztcbkljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuZXhwb3J0IHtJY29ufTtcblxuZXhwb3J0IHtEaXZJY29uLCBkaXZJY29ufSBmcm9tICcuL0Rpdkljb24nO1xuZXhwb3J0IHtNYXJrZXIsIG1hcmtlcn0gZnJvbSAnLi9NYXJrZXInO1xuIiwgImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG5cdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cblx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0dXBkYXRlV2hlbklkbGU6IEJyb3dzZXIubW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG5cdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuXHRcdHRoaXMuX3RpbGVzID0ge307XG5cblx0XHR0aGlzLl9yZXNldFZpZXcoKTsgLy8gaW1wbGljaXQgX3VwZGF0ZSgpIGNhbGxcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cblx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcblx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHR2YXIgdGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xuXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG5cdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuXHRcdFx0XHR0aGlzLl9vbk1vdmUgPSBVdGlsLnRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBgR3JpZExheWVyYC5cblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQG1ldGhvZCBnZXRUaWxlU2l6ZTogUG9pbnRcblx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG5cdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG5cdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBQb2ludCA/IHMgOiBuZXcgUG9pbnQocywgcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcblx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cblx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cblx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcblx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkgeyByZXR1cm47IH1cblxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdHZhciBub3cgPSArbmV3IERhdGUoKSxcblx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG5cdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuXHRcdFx0dmFyIGZhZGUgPSBNYXRoLm1pbigxLCAobm93IC0gdGlsZS5sb2FkZWQpIC8gMjAwKTtcblxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG5cdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR3aWxsUHJ1bmUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX29uT3BhcXVlVGlsZSh0aWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuXHRcdGlmIChuZXh0RnJhbWUpIHtcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk9wYXF1ZVRpbGU6IFV0aWwuZmFsc2VGbixcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXIgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuXHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR6ID0gTnVtYmVyKHopO1xuXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cblx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRVdGlsLmZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9vblVwZGF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uUmVtb3ZlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25DcmVhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKE51bWJlcih6KSk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdH1cblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcblx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcblx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcblx0XHQgICAgejIgPSB6IC0gMSxcblx0XHQgICAgY29vcmRzMiA9IG5ldyBQb2ludCgreDIsICt5Mik7XG5cdFx0Y29vcmRzMi56ID0gK3oyO1xuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcblx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHogKyAxO1xuXG5cdFx0XHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKSxcblx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6ICsgMSA8IG1heFpvb20pIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihpLCBqLCB6ICsgMSwgbWF4Wm9vbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcblx0XHR0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSwgYW5pbWF0aW5nLCBhbmltYXRpbmcpO1xuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9zZXRWaWV3KGUuY2VudGVyLCBlLnpvb20sIHRydWUsIGUubm9VcGRhdGUpO1xuXHR9LFxuXG5cdF9jbGFtcFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1pbk5hdGl2ZVpvb20gJiYgem9vbSA8IG9wdGlvbnMubWluTmF0aXZlWm9vbSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluTmF0aXZlWm9vbTtcblx0XHR9XG5cblx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1heE5hdGl2ZVpvb20gJiYgb3B0aW9ucy5tYXhOYXRpdmVab29tIDwgem9vbSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gem9vbTtcblx0fSxcblxuXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcblx0XHR2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRpbGVab29tKTtcblx0XHR9XG5cblx0XHR2YXIgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuXG5cdFx0aWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcblxuXHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblxuXHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG5cdFx0XHR0aGlzLl9yZXNldEdyaWQoKTtcblxuXHRcdFx0aWYgKHRpbGVab29tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghbm9QcnVuZSkge1xuXHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZsYWcgdG8gcHJldmVudCBfdXBkYXRlT3BhY2l0eSBmcm9tIHBydW5pbmcgdGlsZXMgZHVyaW5nXG5cdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcblx0XHRcdHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybXM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sIGNlbnRlciwgem9vbSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbiAobGV2ZWwsIGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgbGV2ZWwuem9vbSksXG5cdFx0ICAgIHRyYW5zbGF0ZSA9IGxldmVsLm9yaWdpbi5tdWx0aXBseUJ5KHNjYWxlKVxuXHRcdCAgICAgICAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24obGV2ZWwuZWwsIHRyYW5zbGF0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldEdyaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnMsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIHRpbGVab29tID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHRoaXMuX2dsb2JhbFRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoYm91bmRzKTtcblx0XHR9XG5cblx0XHR0aGlzLl93cmFwWCA9IGNycy53cmFwTG5nICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzBdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0XHR0aGlzLl93cmFwWSA9IGNycy53cmFwTGF0ICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0fSxcblxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2dldFRpbGVkUGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBtYXBab29tID0gbWFwLl9hbmltYXRpbmdab29tID8gTWF0aC5tYXgobWFwLl9hbmltYXRlVG9ab29tLCBtYXAuZ2V0Wm9vbSgpKSA6IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNjYWxlID0gbWFwLmdldFpvb21TY2FsZShtYXBab29tLCB0aGlzLl90aWxlWm9vbSksXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcblx0XHQgICAgaGFsZlNpemUgPSBtYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KHNjYWxlICogMik7XG5cblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuXHR9LFxuXG5cdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cblx0XHR2YXIgem9vbSA9IHRoaXMuX2NsYW1wWm9vbShtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cblx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cdC8vIGlmIG91dCBvZiBtaW56b29tL21heHpvb21cblxuXHRcdHZhciBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcblx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG5cdFx0ICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG5cdFx0ICAgIHF1ZXVlID0gW10sXG5cdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuXHRcdCAgICBub1BydW5lUmFuZ2UgPSBuZXcgQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG5cdFx0Ly8gU2FuaXR5IGNoZWNrOiBwYW5pYyBpZiB0aGUgdGlsZSByYW5nZSBjb250YWlucyBJbmZpbml0eSBzb21ld2hlcmUuXG5cdFx0aWYgKCEoaXNGaW5pdGUodGlsZVJhbmdlLm1pbi54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueSkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC55KSkpIHsgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXMnKTsgfVxuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKSkge1xuXHRcdFx0XHR0aGlzLl90aWxlc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBfdXBkYXRlIGp1c3QgbG9hZHMgbW9yZSB0aWxlcy4gSWYgdGhlIHRpbGUgem9vbSBsZXZlbCBkaWZmZXJzIHRvbyBtdWNoXG5cdFx0Ly8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cblx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuXHRcdC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuXHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcblx0XHRcdGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcblx0XHRcdFx0aWYgKHRpbGUpIHtcblx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG5cdFx0fSk7XG5cblx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG5cdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG5cdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcblx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG5cdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdHJldHVybiBsYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG5cdH0sXG5cblx0X2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG5cdH0sXG5cblx0X3RpbGVDb29yZHNUb053U2U6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcblx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcblx0XHQgICAgc2UgPSBtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KTtcblx0XHRyZXR1cm4gW253LCBzZV07XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBpdHMgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGJwID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxuXHRcdCAgICBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKGJwWzBdLCBicFsxXSk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKGJvdW5kcyk7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcblx0XHQgICAgY29vcmRzID0gbmV3IFBvaW50KCtrWzBdLCAra1sxXSk7XG5cdFx0Y29vcmRzLnogPSAra1syXTtcblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdERvbVV0aWwucmVtb3ZlKHRpbGUuZWwpO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcblx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXG5cdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcblx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcblx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlcnIpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKEJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyBVdGlsLndyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuXHRcdFx0dGhpcy5fd3JhcFkgPyBVdGlsLndyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBncmlkTGF5ZXIob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbn1cbiIsICJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBOb3RlIHRoYXQgbW9zdCB0aWxlIHNlcnZlcnMgcmVxdWlyZSBhdHRyaWJ1dGlvbiwgd2hpY2ggeW91IGNhbiBzZXQgdW5kZXIgYExheWVyYC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJywgYXR0cmlidXRpb246ICcmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycyd9KS5hZGRUbyhtYXApO1xuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVmZXJyZXJQb2xpY3k6IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC5cclxuXHRcdC8vIFRoaXMgbWF5IGJlIG5lZWRlZCBpZiB5b3VyIG1hcCdzIHJlbmRlcmluZyBjb250ZXh0IGhhcyBhIHN0cmljdCBkZWZhdWx0IGJ1dCB5b3VyIHRpbGUgcHJvdmlkZXIgZXhwZWN0cyBhIHZhbGlkIHJlZmVycmVyXHJcblx0XHQvLyAoZS5nLiB0byB2YWxpZGF0ZSBhbiBBUEkgdG9rZW4pLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0hUTUxJbWFnZUVsZW1lbnQucmVmZXJyZXJQb2xpY3ldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50L3JlZmVycmVyUG9saWN5KSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdHJlZmVycmVyUG9saWN5OiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tID0gTWF0aC5tYXgob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20gLSAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSArIDEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fSBlbHNlIGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgbWF4Wm9vbSBpcyBndGUgbWluWm9vbVxyXG5cdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgbWluWm9vbSBpcyBsdGUgbWF4Wm9vbVxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG5cdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgdGhpcyBuZXcgb3B0aW9uIHdlIGZvbGxvdyB0aGUgZG9jdW1lbnRlZCBiZWhhdmlvclxyXG5cdFx0Ly8gbW9yZSBjbG9zZWx5IGJ5IG9ubHkgc2V0dGluZyB0aGUgcHJvcGVydHkgd2hlbiBzdHJpbmdcclxuXHRcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR0aWxlLnJlZmVycmVyUG9saWN5ID0gdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBhbHQgYXR0cmlidXRlIGlzIHNldCB0byB0aGUgZW1wdHkgc3RyaW5nLFxyXG5cdFx0Ly8gYWxsb3dpbmcgc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoZSBkZWNvcmF0aXZlIGltYWdlIHRpbGVzLlxyXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS90dXRvcmlhbHMvaW1hZ2VzL2RlY29yYXRpdmUvXHJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hcmlhLyNlbC1pbWctZW1wdHktYWx0XHJcblx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuXHQvLyBAdW5pbmhlcml0YWJsZVxyXG5cdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcblx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBVdGlsLmV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcblx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcblx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBVdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHR2YXIgY29vcmRzID0gdGhpcy5fdGlsZXNbaV0uY29vcmRzO1xyXG5cdFx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcblx0XHRcdFx0XHQvLyBAZXZlbnQgdGlsZWFib3J0OiBUaWxlRXZlbnRcclxuXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIHdhcyBsb2FkaW5nIGJ1dCBpcyBub3cgbm90IHdhbnRlZC5cclxuXHRcdFx0XHRcdHRoaXMuZmlyZSgndGlsZWFib3J0Jywge1xyXG5cdFx0XHRcdFx0XHR0aWxlOiB0aWxlLFxyXG5cdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcblx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgVXRpbC5lbXB0eUltYWdlVXJsKTtcclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsIGtleSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAodGlsZSAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IFV0aWwuZW1wdHlJbWFnZVVybCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwgImltcG9ydCB7VGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XHJcbmltcG9ydCB7ZXh0ZW5kLCBzZXRPcHRpb25zLCBnZXRQYXJhbVN0cmluZ30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRVBTRzQzMjYnO1xyXG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwczovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG5cdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG5cdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcblx0XHRsYXllcnM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuXHRcdHN0eWxlczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG5cdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcblx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcblx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG5cdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG5cdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIHJlYWxSZXRpbmEgPSBvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSA/IDIgOiAxO1xyXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XHJcblx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXHJcblx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG5cdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcblx0XHQgICAgW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6XHJcblx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG5cdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyV01TKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwgImV4cG9ydCB7R3JpZExheWVyLCBncmlkTGF5ZXJ9IGZyb20gJy4vR3JpZExheWVyJztcbmltcG9ydCB7VGlsZUxheWVyLCB0aWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcbmltcG9ydCB7VGlsZUxheWVyV01TLCB0aWxlTGF5ZXJXTVN9IGZyb20gJy4vVGlsZUxheWVyLldNUyc7XG5UaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xudGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcbmV4cG9ydCB7VGlsZUxheWVyLCB0aWxlTGF5ZXJ9O1xuIiwgImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxuZXhwb3J0IHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFV0aWwuc3RhbXAodGhpcyk7XG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0Ly8gYWx3YXlzIGtlZXAgdHJhbnNmb3JtLW9yaWdpbiBhcyAwIDBcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cblx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQoY3VycmVudENlbnRlclBvaW50KVxuXHRcdFx0XHQgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG4iLCAiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cHM6Ly9jYW5pdXNlLmNvbS9jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gKiBub3QgZGlzcGxheSBwcm9wZXJseSBpbiBzb21lIGVkZ2UgY2FzZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDYW52YXMgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaWNrIHRvbGVyYW5jZSBhcm91bmQgYSBwYXRoL29iamVjdCBvbiB0aGUgbWFwLlxuXHRcdHRvbGVyYW5jZTogMFxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gU2V0IGEgZmxhZyBzbyB0aGF0IGEgdmlld3ByZXJlc2V0K21vdmVlbmQrdmlld3Jlc2V0IG9ubHkgdXBkYXRlcyZyZWRyYXdzIG9uY2Vcblx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gdHJ1ZTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cdFx0Y29udGFpbmVyWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2N0eDtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbGF5ZXI7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0dGhpcy5fcmVkcmF3KCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdH1cblxuXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG5cdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuXHRcdFx0bGF5ZXI6IGxheWVyLFxuXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG5cdFx0XHRuZXh0OiBudWxsXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG5cdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KC9bLCBdKy8pLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGRhc2hWYWx1ZSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hWYWx1ZSA9IE51bWJlcihwYXJ0c1tpXSk7XG5cdFx0XHRcdC8vIElnbm9yZSBkYXNoIGFycmF5IGNvbnRhaW5pbmcgaW52YWxpZCBsZW5ndGhzXG5cdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChkYXNoVmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0XHR0aGlzLl9jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuXHRcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHRcdH1cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdGlmICghKGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdwcmVjbGljaycpIHx8ICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRcdGNsaWNrZWRMYXllciA9IGxheWVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2ZpcmVFdmVudChjbGlja2VkTGF5ZXIgPyBbY2xpY2tlZExheWVyXSA6IGZhbHNlLCBlKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuXHR9LFxuXG5cblx0X2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcblx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHRpZiAodGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpcmVFdmVudCh0aGlzLl9ob3ZlcmVkTGF5ZXIgPyBbdGhpcy5faG92ZXJlZExheWVyXSA6IGZhbHNlLCBlKTtcblxuXHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9LCB0aGlzKSwgMzIpO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cblx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGxhc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwcmV2KSB7XG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG5cdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcblx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBjYW52YXMob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsICJpbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuXG4vKlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG5cbmV4cG9ydCB2YXIgdm1sQ3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gRG8gbm90IHJldHVybiBmbiBmcm9tIGNhdGNoIGJsb2NrIHNvIGBlYCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzcyNzlcblx0fVxuXHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdH07XG59KSgpO1xuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5leHBvcnQgdmFyIHZtbE1peGluID0ge1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IHZtbENyZWF0ZSgnc2hhcGUnKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0RG9tVXRpbC5yZW1vdmUoY29udGFpbmVyKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBVdGlsLmlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn07XG4iLCAiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtzdGFtcH0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7c3ZnQ3JlYXRlLCBwb2ludHNUb1BhdGh9IGZyb20gJy4vU1ZHLlV0aWwnO1xuZXhwb3J0IHtwb2ludHNUb1BhdGh9O1xuaW1wb3J0IHt2bWxNaXhpbiwgdm1sQ3JlYXRlfSBmcm9tICcuL1NWRy5WTUwnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vc3ZnKSwgU1ZHIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAqIHRoaXMgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBjcmVhdGUoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7IHRoaXMuX2luaXRDb250YWluZXIoKTsgfVxuXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnJlbW92ZShsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoKTtcblx0fVxufSk7XG5cbmlmIChCcm93c2VyLnZtbCkge1xuXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG59XG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBzdmcob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5zdmcgfHwgQnJvd3Nlci52bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsICJpbXBvcnQge01hcH0gZnJvbSAnLi4vLi4vbWFwL01hcCc7XG5pbXBvcnQge2NhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtzdmd9IGZyb20gJy4vU1ZHJztcblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTogbmFtZX0pO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBjYW52YXMob3B0aW9ucykpIHx8IHN2ZyhvcHRpb25zKTtcblx0fVxufSk7XG4iLCAiaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG5leHBvcnQgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbn1cbiIsICJleHBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmV4cG9ydCB7Q2FudmFzLCBjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7U1ZHLCBjcmVhdGUsIHBvaW50c1RvUGF0aCwgc3ZnfSBmcm9tICcuL1NWRyc7XG5TVkcuY3JlYXRlID0gY3JlYXRlO1xuU1ZHLnBvaW50c1RvUGF0aCA9IHBvaW50c1RvUGF0aDtcbmV4cG9ydCB7U1ZHLCBzdmd9O1xuaW1wb3J0ICcuL1JlbmRlcmVyLmdldFJlbmRlcmVyJztcdC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgbmVlZGVkIGJlY2F1c2UgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbmV4cG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmV4cG9ydCB7Q2lyY2xlTWFya2VyLCBjaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmV4cG9ydCB7Q2lyY2xlLCBjaXJjbGV9IGZyb20gJy4vQ2lyY2xlJztcbmV4cG9ydCB7UG9seWxpbmUsIHBvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmV4cG9ydCB7UG9seWdvbiwgcG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmV4cG9ydCB7UmVjdGFuZ2xlLCByZWN0YW5nbGV9IGZyb20gJy4vUmVjdGFuZ2xlJztcbiIsICJleHBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmV4cG9ydCB7TGF5ZXJHcm91cCwgbGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcbmV4cG9ydCB7RmVhdHVyZUdyb3VwLCBmZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcbmltcG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbiwgZ2VvbWV0cnlUb0xheWVyLCBjb29yZHNUb0xhdExuZywgY29vcmRzVG9MYXRMbmdzLCBsYXRMbmdUb0Nvb3JkcywgbGF0TG5nc1RvQ29vcmRzLCBnZXRGZWF0dXJlLCBhc0ZlYXR1cmV9IGZyb20gJy4vR2VvSlNPTic7XG5HZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbkdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbkdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG5HZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5leHBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb259O1xuXG5leHBvcnQge0ltYWdlT3ZlcmxheSwgaW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5leHBvcnQge1ZpZGVvT3ZlcmxheSwgdmlkZW9PdmVybGF5fSBmcm9tICcuL1ZpZGVvT3ZlcmxheSc7XG5leHBvcnQge1NWR092ZXJsYXksIHN2Z092ZXJsYXl9IGZyb20gJy4vU1ZHT3ZlcmxheSc7XG5cbmV4cG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmV4cG9ydCB7UG9wdXAsIHBvcHVwfSBmcm9tICcuL1BvcHVwJztcbmV4cG9ydCB7VG9vbHRpcCwgdG9vbHRpcH0gZnJvbSAnLi9Ub29sdGlwJztcblxuZXhwb3J0ICogZnJvbSAnLi9tYXJrZXIvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi90aWxlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdmVjdG9yL2luZGV4JztcbiIsICJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG5cdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRib3hab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmUpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wYW5lO1xuXHR9LFxuXG5cdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBDbGVhciB0aGUgZGVmZXJyZWQgcmVzZXRTdGF0ZSBpZiBpdCBoYXNuJ3QgZXhlY3V0ZWQgeWV0LCBvdGhlcndpc2UgaXRcblx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cblx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuIiwgImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG4iLCAiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cblx0ZHJhZ2dpbmc6IHRydWUsXG5cblx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcblx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuXHQvLyBJZiBlbmFibGVkLCBwYW5uaW5nIG9mIHRoZSBtYXAgd2lsbCBoYXZlIGFuIGluZXJ0aWEgZWZmZWN0IHdoZXJlXG5cdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG5cdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcblx0Ly8gZGV2aWNlcy4gRW5hYmxlZCBieSBkZWZhdWx0LlxuXHRpbmVydGlhOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cblx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcblx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG5cdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcblx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG5cdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG5cdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcblx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcblx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG59KTtcblxuZXhwb3J0IHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IGxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG5cdH0sXG5cblx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuXHR9LFxuXG5cdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG5cdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcblx0fSxcblxuXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcblx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG5cdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcblx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgZS5ub0luZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cblx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG5cdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuIiwgImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtvbiwgb2ZmLCBzdG9wfSBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cblxuLypcbiAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5leHBvcnQgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRvbihjb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vZmYoe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcblx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG5cdH0sXG5cblx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuXHR9LFxuXG5cdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2Zmc2V0O1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG5cdFx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcblx0XHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KHRvUG9pbnQob2Zmc2V0KSwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdFx0dmFyIG5ld0xhdExuZyA9IG1hcC53cmFwTGF0TG5nKG1hcC51bnByb2plY3QobWFwLnByb2plY3QobWFwLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSkpO1xuXHRcdFx0XHRcdG1hcC5wYW5UbyhuZXdMYXRMbmcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcblx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3ICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpIHtcblx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN0b3AoZSk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgS2V5Ym9hcmQpO1xuIiwgImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNlIHdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbmV4cG9ydCB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuIiwgImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBMLk1hcC5UYXBIb2xkIGlzIHVzZWQgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCBvbiBsb25nIGhvbGQsXG4gKiB3aGljaCBvdGhlcndpc2UgaXMgbm90IGZpcmVkIGJ5IG1vYmlsZSBTYWZhcmkuXG4gKi9cblxudmFyIHRhcEhvbGREZWxheSA9IDYwMDtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdGFwSG9sZDogQm9vbGVhblxuXHQvLyBFbmFibGVzIHNpbXVsYXRpb24gb2YgYGNvbnRleHRtZW51YCBldmVudCwgZGVmYXVsdCBpcyBgdHJ1ZWAgZm9yIG1vYmlsZSBTYWZhcmkuXG5cdHRhcEhvbGQ6IEJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5zYWZhcmkgJiYgQnJvd3Nlci5tb2JpbGUsXG5cblx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG5cdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxuZXhwb3J0IHZhciBUYXBIb2xkID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX2NhbmNlbCgpO1xuXHRcdFx0aWYgKCF0aGlzLl9pc1RhcFZhbGlkKCkpIHsgcmV0dXJuOyB9XG5cblx0XHRcdC8vIHByZXZlbnQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBodHRwczovL3czYy5naXRodWIuaW8vdG91Y2gtZXZlbnRzLyNtb3VzZS1ldmVudHNcblx0XHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XG5cdFx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fY2FuY2VsQ2xpY2tQcmV2ZW50KTtcblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdH0sIHRoaXMpLCB0YXBIb2xkRGVsYXkpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuXHR9LFxuXG5cdF9jYW5jZWxDbGlja1ByZXZlbnQ6IGZ1bmN0aW9uIGNhbmNlbENsaWNrUHJldmVudCgpIHtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGNhbmNlbENsaWNrUHJldmVudCk7XG5cdH0sXG5cblx0X2NhbmNlbDogZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgY29udGV4dG1lbnUnLCB0aGlzLl9jYW5jZWwsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXHR9LFxuXG5cdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKSA8PSB0aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2U7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwge1xuXHRcdFx0YnViYmxlczogdHJ1ZSxcblx0XHRcdGNhbmNlbGFibGU6IHRydWUsXG5cdFx0XHR2aWV3OiB3aW5kb3csXG5cdFx0XHQvLyBkZXRhaWw6IDEsXG5cdFx0XHRzY3JlZW5YOiBlLnNjcmVlblgsXG5cdFx0XHRzY3JlZW5ZOiBlLnNjcmVlblksXG5cdFx0XHRjbGllbnRYOiBlLmNsaWVudFgsXG5cdFx0XHRjbGllbnRZOiBlLmNsaWVudFksXG5cdFx0XHQvLyBidXR0b246IDIsXG5cdFx0XHQvLyBidXR0b25zOiAyXG5cdFx0fSk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXBIb2xkOiBIYW5kbGVyXG4vLyBMb25nIHRhcCBoYW5kbGVyIHRvIHNpbXVsYXRlIGBjb250ZXh0bWVudWAgZXZlbnQgKHVzZWZ1bCBpbiBtb2JpbGUgU2FmYXJpKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXBIb2xkJywgVGFwSG9sZCk7XG4iLCAiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMuXG5cdHRvdWNoWm9vbTogQnJvd3Nlci50b3VjaCxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcblx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdHZhciBtb3ZlRm4gPSBVdGlsLmJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9LCB1bmRlZmluZWQpO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKG1vdmVGbiwgdGhpcywgdHJ1ZSk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHR0aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSksIHRydWUsIHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbi8vIFRvdWNoIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBUb3VjaFpvb20pO1xuIiwgImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XG5pbXBvcnQge0JveFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuQm94Wm9vbSc7XG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5pbXBvcnQge0RvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20nO1xuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbmltcG9ydCB7RHJhZ30gZnJvbSAnLi9oYW5kbGVyL01hcC5EcmFnJztcbk1hcC5EcmFnID0gRHJhZztcbmltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJy4vaGFuZGxlci9NYXAuS2V5Ym9hcmQnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5pbXBvcnQge1Njcm9sbFdoZWVsWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20nO1xuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbmltcG9ydCB7VGFwSG9sZH0gZnJvbSAnLi9oYW5kbGVyL01hcC5UYXBIb2xkJztcbk1hcC5UYXBIb2xkID0gVGFwSG9sZDtcbmltcG9ydCB7VG91Y2hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRvdWNoWm9vbSc7XG5NYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG5leHBvcnQge01hcCwgY3JlYXRlTWFwIGFzIG1hcH0gZnJvbSAnLi9NYXAnO1xuIiwgImltcG9ydCAqIGFzIEwgZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCAnbGVhZmxldC1mdWxsc2NyZWVuJztcclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgICBjb25zdCBtYXBQaWNrZXIgPSAoJHdpcmUsIGNvbmZpZywgc3RhdGUpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYXA6IG51bGwsXHJcbiAgICAgICAgICAgIHRpbGU6IG51bGwsXHJcbiAgICAgICAgICAgIG1hcmtlcjogbnVsbCxcclxuICAgICAgICAgICAgY3JlYXRlTWFwOiBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubWFwID0gTC5tYXAoZWwsIGNvbmZpZy5jb250cm9scyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5vbignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubWFwLmludmFsaWRhdGVTaXplKHRydWUpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNob3dNYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0TGF0TG5nKHRoaXMubWFwLmdldENlbnRlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5kcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlID0gTC50aWxlTGF5ZXIoY29uZmlnLnRpbGVzVXJsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb246IGNvbmZpZy5hdHRyaWJ1dGlvbixcclxuICAgICAgICAgICAgICAgICAgICBtaW5ab29tOiBjb25maWcubWluWm9vbSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhab29tOiBjb25maWcubWF4Wm9vbSxcclxuICAgICAgICAgICAgICAgICAgICB0aWxlU2l6ZTogY29uZmlnLnRpbGVTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21PZmZzZXQ6IGNvbmZpZy56b29tT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdFJldGluYTogY29uZmlnLmRldGVjdFJldGluYSxcclxuICAgICAgICAgICAgICAgIH0pLmFkZFRvKHRoaXMubWFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNob3dNYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJDb2xvciA9IGNvbmZpZy5tYXJrZXJDb2xvciB8fCBcIiMzYjgyZjZcIjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdmdJY29uID0gTC5kaXZJY29uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwibWFwLWljb25cIiBmaWxsPVwiJHttYXJrZXJDb2xvcn1cIiB3aWR0aD1cIjM2XCIgaGVpZ2h0PVwiMzZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xMiAwYy00LjE5OCAwLTggMy40MDMtOCA3LjYwMiAwIDQuMTk4IDMuNDY5IDkuMjEgOCAxNi4zOTggNC41MzEtNy4xODggOC0xMi4yIDgtMTYuMzk4IDAtNC4xOTktMy44MDEtNy42MDItOC03LjYwMnptMCAxMWMtMS42NTcgMC0zLTEuMzQzLTMtM3MxLjM0My0zIDMtMyAzIDEuMzQzIDMgMy0xLjM0MyAzLTMgM3pcIi8+PC9zdmc+YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uU2l6ZTogWzM2LCAzNl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25BbmNob3I6IFsxOCwgMzZdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya2VyID0gTC5tYXJrZXIoWzAsIDBdLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHN2Z0ljb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9QYW46IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KS5hZGRUbyh0aGlzLm1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAub24oJ21vdmUnLCAoKSA9PiB0aGlzLm1hcmtlci5zZXRMYXRMbmcodGhpcy5tYXAuZ2V0Q2VudGVyKCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5vbignbW92ZWVuZCcsICgpID0+IHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVMb2NhdGlvbigpLCA1MDApKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5vbignbG9jYXRpb25mb3VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1hcC5zZXRab29tKGNvbmZpZy5jb250cm9scy56b29tKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IHN0YXRlID8/IHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKTtcclxuICAgICAgICAgICAgICAgIGlmICghbG9jYXRpb24ubGF0ICYmICFsb2NhdGlvbi5sbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5sb2NhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWaWV3OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhab29tOiBjb25maWcuY29udHJvbHMubWF4Wm9vbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaDogZmFsc2UgLy8gdGhpcyBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIG1hcCBpbiByZWFsIHRpbWUgYnV0IHdvcmtzIGtpbmRhIHdlaXJkXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldFZpZXcobmV3IEwuTGF0TG5nKGxvY2F0aW9uLmxhdCwgbG9jYXRpb24ubG5nKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5zaG93TXlMb2NhdGlvbkJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTG9jYXRpb25CdXR0b24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxpdmVMb2NhdGlvbi5zZW5kICYmIGNvbmZpZy5saXZlTG9jYXRpb24ucmVhbHRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hDdXJyZW50TG9jYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBjb25maWcubGl2ZUxvY2F0aW9uLm1pbGlzZWNvbmRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlTG9jYXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkaW5hdGVzID0gdGhpcy5nZXRDb29yZGluYXRlcygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDZW50ZXIgPSB0aGlzLm1hcC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIC8vY29uZmlnLmRyYWdnYWJsZSAmJiBcclxuICAgICAgICAgICAgICAgICAgICAoY29vcmRpbmF0ZXMubG5nICE9PSBjdXJyZW50Q2VudGVyLmxuZyB8fCBjb29yZGluYXRlcy5sYXQgIT09IGN1cnJlbnRDZW50ZXIubGF0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICR3aXJlLnNldChjb25maWcuc3RhdGVQYXRoLCB0aGlzLm1hcC5nZXRDZW50ZXIoKSwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxpdmVMb2NhdGlvbi5zZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR3aXJlLiRyZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZW1vdmVNYXA6IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLm9mZigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldENvb3JkaW5hdGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG9jYXRpb24gPSAkd2lyZS5nZXQoY29uZmlnLnN0YXRlUGF0aCkgPz8ge307XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzVmFsaWRDb29yZGluYXRlcyA9IGxvY2F0aW9uLmhhc093blByb3BlcnR5KCdsYXQnKSAmJiBsb2NhdGlvbi5oYXNPd25Qcm9wZXJ0eSgnbG5nJykgJiZcclxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5sYXQgIT09IG51bGwgJiYgbG9jYXRpb24ubG5nICE9PSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghaGFzVmFsaWRDb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXQ6IGNvbmZpZy5kZWZhdWx0LmxhdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBjb25maWcuZGVmYXVsdC5sbmdcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXR0YWNoOiBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlTWFwKGVsKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVNYXAoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXAoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luOiAnMHB4JyxcclxuICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEuMFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmV0Y2hDdXJyZW50TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oYXN5bmMgcG9zaXRpb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSBuZXcgTC5MYXRMbmcocG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLCBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tYXAuZmx5VG8oY3VycmVudFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTG9jYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNYXJrZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGN1cnJlbnQgbG9jYXRpb246JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGVydCgnR2VvbG9jYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFkZExvY2F0aW9uQnV0dG9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbkJ1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiPjxwYXRoIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBkPVwiTTEyIDBDOC4yNSAwIDUgMy4yNSA1IDdjMCA1LjI1IDcgMTMgNyAxM3M3LTcuNzUgNy0xM2MwLTMuNzUtMy4yNS03LTctN3ptMCAxMGMtMS42NiAwLTMtMS4zNC0zLTNzMS4zNC0zIDMtMyAzIDEuMzQgMyAzLTEuMzQgMy0zIDN6bTAtNWMtMS4xMSAwLTIgLjg5LTIgMnMuODkgMiAyIDIgMi0uODkgMi0yLS44OS0yLTItMnpcIi8+PC9zdmc+JztcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uQnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ21hcC1sb2NhdGlvbi1idXR0b24nKTtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLmZldGNoQ3VycmVudExvY2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChsb2NhdGlvbkJ1dHRvbik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kd2lyZSA9ICR3aXJlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAkd2lyZS5vbigncmVmcmVzaE1hcCcsIHRoaXMucmVmcmVzaE1hcC5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAoY29uZmlnLikge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMubWFwLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlTWFya2VyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2hvd01hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldExhdExuZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVMb2NhdGlvbigpLCA1MDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWZyZXNoTWFwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLmZseVRvKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1hcmtlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgd2luZG93Lm1hcFBpY2tlciA9IG1hcFBpY2tlcjtcclxuXHJcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ21hcC1zY3JpcHQtbG9hZGVkJykpO1xyXG59KTtcclxuIiwgIkwuQ29udHJvbC5GdWxsc2NyZWVuID0gTC5Db250cm9sLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgJ2ZhbHNlJzogJ1ZpZXcgRnVsbHNjcmVlbicsXG4gICAgICAgICAgICAndHJ1ZSc6ICdFeGl0IEZ1bGxzY3JlZW4nXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtZnVsbHNjcmVlbiBsZWFmbGV0LWJhciBsZWFmbGV0LWNvbnRyb2wnKTtcblxuICAgICAgICB0aGlzLmxpbmsgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgJ2xlYWZsZXQtY29udHJvbC1mdWxsc2NyZWVuLWJ1dHRvbiBsZWFmbGV0LWJhci1wYXJ0JywgY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5saW5rLmhyZWYgPSAnIyc7XG5cbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9tYXAub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLl90b2dnbGVUaXRsZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVRpdGxlKCk7XG5cbiAgICAgICAgTC5Eb21FdmVudC5vbih0aGlzLmxpbmssICdjbGljaycsIHRoaXMuX2NsaWNrLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgICAgICBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB0aGlzLl9tYXAudG9nZ2xlRnVsbHNjcmVlbih0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlVGl0bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbmsudGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGVbdGhpcy5fbWFwLmlzRnVsbHNjcmVlbigpXTtcbiAgICB9XG59KTtcblxuTC5NYXAuaW5jbHVkZSh7XG4gICAgaXNGdWxsc2NyZWVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Z1bGxzY3JlZW4gfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIHRvZ2dsZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wc2V1ZG9GdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVBzZXVkb0Z1bGxzY3JlZW4oY29udGFpbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlUHNldWRvRnVsbHNjcmVlbihjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wc2V1ZG9GdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlUHNldWRvRnVsbHNjcmVlbihjb250YWluZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbihFbGVtZW50LkFMTE9XX0tFWUJPQVJEX0lOUFVUKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVQc2V1ZG9GdWxsc2NyZWVuKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBfZW5hYmxlUHNldWRvRnVsbHNjcmVlbjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1wc2V1ZG8tZnVsbHNjcmVlbicpO1xuICAgICAgICB0aGlzLl9zZXRGdWxsc2NyZWVuKHRydWUpO1xuICAgICAgICB0aGlzLmZpcmUoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgX2Rpc2FibGVQc2V1ZG9GdWxsc2NyZWVuOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXBzZXVkby1mdWxsc2NyZWVuJyk7XG4gICAgICAgIHRoaXMuX3NldEZ1bGxzY3JlZW4oZmFsc2UpO1xuICAgICAgICB0aGlzLmZpcmUoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgX3NldEZ1bGxzY3JlZW46IGZ1bmN0aW9uKGZ1bGxzY3JlZW4pIHtcbiAgICAgICAgdGhpcy5faXNGdWxsc2NyZWVuID0gZnVsbHNjcmVlbjtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgIGlmIChmdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1mdWxsc2NyZWVuLW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1mdWxsc2NyZWVuLW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIH0sXG5cbiAgICBfb25GdWxsc2NyZWVuQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZnVsbHNjcmVlbkVsZW1lbnQgPVxuICAgICAgICAgICAgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcblxuICAgICAgICBpZiAoZnVsbHNjcmVlbkVsZW1lbnQgPT09IHRoaXMuZ2V0Q29udGFpbmVyKCkgJiYgIXRoaXMuX2lzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0RnVsbHNjcmVlbih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgICAgICB9IGVsc2UgaWYgKGZ1bGxzY3JlZW5FbGVtZW50ICE9PSB0aGlzLmdldENvbnRhaW5lcigpICYmIHRoaXMuX2lzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0RnVsbHNjcmVlbihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIGZ1bGxzY3JlZW5Db250cm9sOiBmYWxzZVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZ1bGxzY3JlZW5Db250cm9sKSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbkNvbnRyb2wgPSBuZXcgTC5Db250cm9sLkZ1bGxzY3JlZW4odGhpcy5vcHRpb25zLmZ1bGxzY3JlZW5Db250cm9sKTtcbiAgICAgICAgdGhpcy5hZGRDb250cm9sKHRoaXMuZnVsbHNjcmVlbkNvbnRyb2wpO1xuICAgIH1cblxuICAgIHZhciBmdWxsc2NyZWVuY2hhbmdlO1xuXG4gICAgaWYgKCdvbmZ1bGxzY3JlZW5jaGFuZ2UnIGluIGRvY3VtZW50KSB7XG4gICAgICAgIGZ1bGxzY3JlZW5jaGFuZ2UgPSAnZnVsbHNjcmVlbmNoYW5nZSc7XG4gICAgfSBlbHNlIGlmICgnb25tb3pmdWxsc2NyZWVuY2hhbmdlJyBpbiBkb2N1bWVudCkge1xuICAgICAgICBmdWxsc2NyZWVuY2hhbmdlID0gJ21vemZ1bGxzY3JlZW5jaGFuZ2UnO1xuICAgIH0gZWxzZSBpZiAoJ29ud2Via2l0ZnVsbHNjcmVlbmNoYW5nZScgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgZnVsbHNjcmVlbmNoYW5nZSA9ICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJztcbiAgICB9IGVsc2UgaWYgKCdvbm1zZnVsbHNjcmVlbmNoYW5nZScgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgZnVsbHNjcmVlbmNoYW5nZSA9ICdNU0Z1bGxzY3JlZW5DaGFuZ2UnO1xuICAgIH1cblxuICAgIGlmIChmdWxsc2NyZWVuY2hhbmdlKSB7XG4gICAgICAgIHZhciBvbkZ1bGxzY3JlZW5DaGFuZ2UgPSBMLmJpbmQodGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlLCB0aGlzKTtcblxuICAgICAgICB0aGlzLndoZW5SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCBmdWxsc2NyZWVuY2hhbmdlLCBvbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uKCd1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwgZnVsbHNjcmVlbmNoYW5nZSwgb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbkwuY29udHJvbC5mdWxsc2NyZWVuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEwuQ29udHJvbC5GdWxsc2NyZWVuKG9wdGlvbnMpO1xufTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRTyxlQUFTLE9BQU8sTUFBTTtBQUM1QixZQUFJLEdBQUcsR0FBRyxLQUFLO0FBRWYsYUFBSyxJQUFJLEdBQUcs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QztBQUFBLFFBQ0wsT0FBTztBQUNILGdCQUFNLCtDQUErQztBQUFBLFFBQ3pEO0FBQUEsTUFDSjtBQUFBLE1BQ0EsbUJBQW1CLFdBQVc7QUFDMUIsY0FBTSxpQkFBaUIsU0FBUyxjQUFjLFFBQVE7QUFDdEQsdUJBQWUsWUFBWTtBQUMzQix1QkFBZSxPQUFPO0FBQ3RCLHVCQUFlLFVBQVUsSUFBSSxxQkFBcUI7QUFDbEQsdUJBQWUsVUFBVSxNQUFNLEtBQUsscUJBQXFCO0FBQ3pELGFBQUssSUFBSSxhQUFhLEVBQUUsWUFBWSxjQUFjO0FBQUEsTUFDdEQ7QUFBQSxNQUNBLE1BQU0sV0FBVztBQUNiLGFBQUssUUFBUTtBQUNiLGFBQUssU0FBUztBQUNkLGFBQUssUUFBUTtBQUNiLGNBQU0sR0FBRyxjQUFjLEtBQUssV0FBVyxLQUFLLElBQUksQ0FBQztBQUFBLE1BS3JEO0FBQUEsTUFDQSxjQUFjLFdBQVc7QUFDckIsWUFBSSxPQUFPLFlBQVk7QUFDbkIsZUFBSyxPQUFPLFVBQVUsS0FBSyxlQUFlLENBQUM7QUFDM0MscUJBQVcsTUFBTSxLQUFLLGVBQWUsR0FBRyxHQUFHO0FBQUEsUUFDL0M7QUFBQSxNQUNKO0FBQUEsTUFDQSxZQUFZLFdBQVc7QUFDbkIsYUFBSyxJQUFJLE1BQU0sS0FBSyxlQUFlLENBQUM7QUFDcEMsYUFBSyxhQUFhO0FBQUEsTUFDdEI7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUVBLFNBQU8sWUFBWTtBQUVuQixTQUFPLGNBQWMsSUFBSSxZQUFZLG1CQUFtQixDQUFDO0FBQzdELENBQUM7IiwKICAibmFtZXMiOiBbImNyZWF0ZSIsICJzdHIiLCAiVXRpbC5zZXRPcHRpb25zIiwgIlV0aWwuY3JlYXRlIiwgIlV0aWwuZXh0ZW5kIiwgImkiLCAiVXRpbC5pc0FycmF5IiwgIlV0aWwuc3BsaXRXb3JkcyIsICJVdGlsLmZhbHNlRm4iLCAiaW5kZXgiLCAiVXRpbC5zdGFtcCIsICJMYXRMbmciLCAiVXRpbC5mb3JtYXROdW0iLCAiem9vbSIsICJzY2FsZSIsICJVdGlsLndyYXBOdW0iLCAiY2FudmFzIiwgInN2ZyIsICJEb21FdmVudC5wcmV2ZW50RGVmYXVsdCIsICJEb21FdmVudC5nZXRQcm9wYWdhdGlvblBhdGgiLCAic3R5bGUiLCAiVXRpbC50cmltIiwgIkRvbUV2ZW50Lm9uIiwgIkRvbUV2ZW50Lm9mZiIsICJ0eXBlIiwgIlV0aWwuaW5kZXhPZiIsICJEb21VdGlsLmdldFBvc2l0aW9uIiwgIlV0aWwucmVxdWVzdEFuaW1GcmFtZSIsICJEb21VdGlsLnNldFBvc2l0aW9uIiwgIlV0aWwuY2FuY2VsQW5pbUZyYW1lIiwgIlV0aWwuYmluZCIsICJEb21VdGlsLlRSQU5TSVRJT04iLCAiRG9tVXRpbC5UUkFOU0lUSU9OX0VORCIsICJEb21VdGlsLmFkZENsYXNzIiwgIkRvbVV0aWwucmVtb3ZlIiwgIkRvbVV0aWwuY3JlYXRlIiwgIkRvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24iLCAiRG9tVXRpbC5nZXQiLCAiRG9tVXRpbC5nZXRTdHlsZSIsICJyZW1vdmUiLCAiRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldCIsICJEb21VdGlsLnByZXZlbnRPdXRsaW5lIiwgIkRvbVV0aWwucmVtb3ZlQ2xhc3MiLCAiRG9tVXRpbC5UUkFOU0ZPUk0iLCAiRG9tVXRpbC5zZXRUcmFuc2Zvcm0iLCAibWFwIiwgImNvbnRyb2wiLCAiRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24iLCAiRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uIiwgIkRvbVV0aWwuZW1wdHkiLCAiRG9tRXZlbnQuc3RvcCIsICJwcmV2ZW50T3V0bGluZSIsICJEb21VdGlsLmhhc0NsYXNzIiwgIkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZyIsICJEb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uIiwgIkRvbVV0aWwuZ2V0U2l6ZWRQYXJlbnROb2RlIiwgIkRvbVV0aWwuZ2V0U2NhbGUiLCAiRG9tVXRpbC5lbmFibGVJbWFnZURyYWciLCAiRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uIiwgImVkZ2UiLCAiTGluZVV0aWwuX2dldEJpdENvZGUiLCAiTGluZVV0aWwuX2dldEVkZ2VJbnRlcnNlY3Rpb24iLCAiTGluZVV0aWwuaXNGbGF0IiwgImxheWVycyIsICJwb2ludCIsICJtYXJrZXIiLCAiaWNvbiIsICJsYXRMbmciLCAiRG9tVXRpbC5zZXRPcGFjaXR5IiwgIkxpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCIsICJMaW5lVXRpbC5wb2x5bGluZUNlbnRlciIsICJMaW5lVXRpbC5jbGlwU2VnbWVudCIsICJMaW5lVXRpbC5zaW1wbGlmeSIsICJMaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlIiwgIkxpbmVVdGlsLl9mbGF0IiwgIlBvbHlVdGlsLnBvbHlnb25DZW50ZXIiLCAiUG9seVV0aWwuY2xpcFBvbHlnb24iLCAiRG9tVXRpbC50b0Zyb250IiwgIkRvbVV0aWwudG9CYWNrIiwgIkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbiIsICJwb3B1cCIsICJ0b29sdGlwIiwgImRpdkljb24iLCAiVXRpbC50aHJvdHRsZSIsICJsYXRMbmdCb3VuZHMiLCAiVXRpbC50ZW1wbGF0ZSIsICJVdGlsLmVtcHR5SW1hZ2VVcmwiLCAidGlsZUxheWVyIiwgIkRvbUV2ZW50LmdldFdoZWVsRGVsdGEiLCAiTCIsICJtYXAiXQp9Cg==
